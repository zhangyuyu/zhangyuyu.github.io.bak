<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="行是知之始，知是行之成" />



  <meta name="keywords" content="webServer," />



  <link rel="alternate" href="/atom.xml" title="若见喻笺" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="还记得吗，在第一部分我问了一个问题：如何在你刚写出来的web server上运行一个Django应用，Flask应用和Pyramid应用，同时不做出改动就能适应这些不同的Web框架呢？往下读就可以找到答案。　　　　在以前，你选择的Python web框架会限制你可选择的web server，反之亦然。如果框架和服务器被设计成协同工作的话，那就是极好的。
　　但是当你试图去连接没有被设计成协同工作的">
<meta property="og:type" content="article">
<meta property="og:title" content="创建你自己的Web Server - part 2">
<meta property="og:url" content="http://yoursite.com/2016/03/06/WebServer2/index.html">
<meta property="og:site_name" content="若见喻笺">
<meta property="og:description" content="还记得吗，在第一部分我问了一个问题：如何在你刚写出来的web server上运行一个Django应用，Flask应用和Pyramid应用，同时不做出改动就能适应这些不同的Web框架呢？往下读就可以找到答案。　　　　在以前，你选择的Python web框架会限制你可选择的web server，反之亦然。如果框架和服务器被设计成协同工作的话，那就是极好的。
　　但是当你试图去连接没有被设计成协同工作的">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_before_wsgi.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_after_wsgi.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_wsgi_idea.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_wsgi_interop.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_browser_pyramid.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_browser_flask.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_browser_django.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_wsgi_interface.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_browser_simple_wsgi_app.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_http_response.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_http_response_explanation.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_environ.png">
<meta property="og:image" content="http://yoursite.com/imgs/WS_part2_server_summary.png">
<meta property="og:updated_time" content="2016-03-06T10:15:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="创建你自己的Web Server - part 2">
<meta name="twitter:description" content="还记得吗，在第一部分我问了一个问题：如何在你刚写出来的web server上运行一个Django应用，Flask应用和Pyramid应用，同时不做出改动就能适应这些不同的Web框架呢？往下读就可以找到答案。　　　　在以前，你选择的Python web框架会限制你可选择的web server，反之亦然。如果框架和服务器被设计成协同工作的话，那就是极好的。
　　但是当你试图去连接没有被设计成协同工作的">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> 创建你自己的Web Server - part 2 | 若见喻笺 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-hk">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">若见喻笺</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            標籤
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            <i class="menu-item-icon icon-next-guestbook"></i> <br />
            留言
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              创建你自己的Web Server - part 2
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-03-06T17:43:32+08:00" content="2016-03-06">
            2016-03-06
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Web-Server/" itemprop="url" rel="index">
                  <span itemprop="name">Web Server</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/03/06/WebServer2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/06/WebServer2/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>　　还记得吗，在第一部分我问了一个问题：如何在你刚写出来的web server上运行一个Django应用，Flask应用和Pyramid应用，同时不做出改动就能适应这些不同的Web框架呢？往下读就可以找到答案。<br>　　<br>　　在以前，你选择的Python web框架会限制你可选择的web server，反之亦然。如果框架和服务器被设计成协同工作的话，那就是极好的。<br><img src="/imgs/WS_part2_before_wsgi.png" width="400" height="250"></p>
<p>　　但是当你试图去连接没有被设计成协同工作的服务器和框架时， 你可能会遇到（可能你遇到过）下面的问题：<br><img src="/imgs/WS_part2_after_wsgi.png" width="400" height="250"></p>
<p>　　基本上，你不得不使用能协同工作的组件，而不是你想使用的组件。因此，你如何确保你的web server能够运行多种web框架，而不用改变web server和web框架的代码呢？问题的答案就是<em>Python Web Server GateWay Interface</em>(或简称WSHI，读作”wizgy”)。<br><img src="/imgs/WS_part2_wsgi_idea.png" width="400" height="250"></p>
<p>　　WSGI允许开发者自由选择web server和web框架。现在你可以混合搭配不同的web server和web框架，并选择一个满足你需求的组合。比如，你可以用Gunicorn，Nginx/uWSGI或者Waitress运行Django，Flask或者Pyramid。真正的混合搭配，多亏了服务器和框架对WSGI的支持。<br><img src="/imgs/WS_part2_wsgi_interop.png" width="400" height="250"></p>
<p>　　因此，WSGI是我在第一部分提出，并在本文开头重复的问题的答案。你的web server必须实现WSGI接口的服务器端部分，所有的Python web框架已经实现了WSGI接口的框架端部分。这样不用修改服务器的代码去适应指定的web框架，你就能使用你的web server。<br>　　现在你已经知道web server和web框架都支持WSGI，它允许你选择适合的组合，同时也有利与服务器和框架的开发者专注于他们擅长的领域，不会因为越界而踩到对方的脚趾。其他语言也有类似的接口：比如Java有Servlet API，Ruby有Rack。</p>
<p>　　一切都很好，但是我猜你会说：“把代码展示给我看！”好吧，一起看看这个简单的WSGI服务器的实现吧：</p>
<pre><code><span class="comment"># Tested with Python 2.7.9, Linux &amp; Mac OS X</span>
<span class="keyword">import</span> socket
<span class="keyword">import</span> StringIO
<span class="keyword">import</span> sys


<span class="class"><span class="keyword">class</span> <span class="title">WSGIServer</span><span class="params">(object)</span>:</span>

    address_family = socket.AF_INET
    socket_type = socket.SOCK_STREAM
    request_queue_size = <span class="number">1</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server_address)</span>:</span>
        <span class="comment"># Create a listening socket</span>
        self.listen_socket = listen_socket = socket.socket(
            self.address_family,
            self.socket_type
        )
        <span class="comment"># Allow to reuse the same address</span>
        listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)
        <span class="comment"># Bind</span>
        listen_socket.bind(server_address)
        <span class="comment"># Activate</span>
        listen_socket.listen(self.request_queue_size)
        <span class="comment"># Get server host name and port</span>
        host, port = self.listen_socket.getsockname()[:<span class="number">2</span>]
        self.server_name = socket.getfqdn(host)
        self.server_port = port
        <span class="comment"># Return headers set by Web framework/Web application</span>
        self.headers_set = []

    <span class="function"><span class="keyword">def</span> <span class="title">set_app</span><span class="params">(self, application)</span>:</span>
        self.application = application

    <span class="function"><span class="keyword">def</span> <span class="title">serve_forever</span><span class="params">(self)</span>:</span>
        listen_socket = self.listen_socket
        <span class="keyword">while</span> <span class="keyword">True</span>:
            <span class="comment"># New client connection</span>
            self.client_connection, client_address = listen_socket.accept()
            <span class="comment"># Handle one request and close the client connection. Then</span>
            <span class="comment"># loop over to wait for another client connection</span>
            self.handle_one_request()

    <span class="function"><span class="keyword">def</span> <span class="title">handle_one_request</span><span class="params">(self)</span>:</span>
        self.request_data = request_data = self.client_connection.recv(<span class="number">1024</span>)
        <span class="comment"># Print formatted request data a la 'curl -v'</span>
        print(<span class="string">''</span>.join(
            <span class="string">'&lt; {line}\n'</span>.format(line=line)
            <span class="keyword">for</span> line <span class="keyword">in</span> request_data.splitlines()
        ))

        self.parse_request(request_data)

        <span class="comment"># Construct environment dictionary using request data</span>
        env = self.get_environ()

        <span class="comment"># It's time to call our application callable and get</span>
        <span class="comment"># back a result that will become HTTP response body</span>
        result = self.application(env, self.start_response)

        <span class="comment"># Construct a response and send it back to the client</span>
        self.finish_response(result)

    <span class="function"><span class="keyword">def</span> <span class="title">parse_request</span><span class="params">(self, text)</span>:</span>
        request_line = text.splitlines()[<span class="number">0</span>]
        request_line = request_line.rstrip(<span class="string">'\r\n'</span>)
        <span class="comment"># Break down the request line into components</span>
        (self.request_method,  <span class="comment"># GET</span>
         self.path,            <span class="comment"># /hello</span>
         self.request_version  <span class="comment"># HTTP/1.1</span>
         ) = request_line.split()

    <span class="function"><span class="keyword">def</span> <span class="title">get_environ</span><span class="params">(self)</span>:</span>
        env = {}
        <span class="comment"># The following code snippet does not follow PEP8 conventions</span>
        <span class="comment"># but it's formatted the way it is for demonstration purposes</span>
        <span class="comment"># to emphasize the required variables and their values</span>
        <span class="comment">#</span>
        <span class="comment"># Required WSGI variables</span>
        env[<span class="string">'wsgi.version'</span>]      = (<span class="number">1</span>, <span class="number">0</span>)
        env[<span class="string">'wsgi.url_scheme'</span>]   = <span class="string">'http'</span>
        env[<span class="string">'wsgi.input'</span>]        = StringIO.StringIO(self.request_data)
        env[<span class="string">'wsgi.errors'</span>]       = sys.stderr
        env[<span class="string">'wsgi.multithread'</span>]  = <span class="keyword">False</span>
        env[<span class="string">'wsgi.multiprocess'</span>] = <span class="keyword">False</span>
        env[<span class="string">'wsgi.run_once'</span>]     = <span class="keyword">False</span>
        <span class="comment"># Required CGI variables</span>
        env[<span class="string">'REQUEST_METHOD'</span>]    = self.request_method    <span class="comment"># GET</span>
        env[<span class="string">'PATH_INFO'</span>]         = self.path              <span class="comment"># /hello</span>
        env[<span class="string">'SERVER_NAME'</span>]       = self.server_name       <span class="comment"># localhost</span>
        env[<span class="string">'SERVER_PORT'</span>]       = str(self.server_port)  <span class="comment"># 8888</span>
        <span class="keyword">return</span> env

    <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(self, status, response_headers, exc_info=None)</span>:</span>
        <span class="comment"># Add necessary server headers</span>
        server_headers = [
            (<span class="string">'Date'</span>, <span class="string">'Tue, 31 Mar 2015 12:54:48 GMT'</span>),
            (<span class="string">'Server'</span>, <span class="string">'WSGIServer 0.2'</span>),
        ]
        self.headers_set = [status, response_headers + server_headers]
        <span class="comment"># To adhere to WSGI specification the start_response must return</span>
        <span class="comment"># a 'write' callable. We simplicity's sake we'll ignore that detail</span>
        <span class="comment"># for now.</span>
        <span class="comment"># return self.finish_response</span>

    <span class="function"><span class="keyword">def</span> <span class="title">finish_response</span><span class="params">(self, result)</span>:</span>
        <span class="keyword">try</span>:
            status, response_headers = self.headers_set
            response = <span class="string">'HTTP/1.1 {status}\r\n'</span>.format(status=status)
            <span class="keyword">for</span> header <span class="keyword">in</span> response_headers:
                response += <span class="string">'{0}: {1}\r\n'</span>.format(*header)
            response += <span class="string">'\r\n'</span>
            <span class="keyword">for</span> data <span class="keyword">in</span> result:
                response += data
            <span class="comment"># Print formatted response data a la 'curl -v'</span>
            print(<span class="string">''</span>.join(
                <span class="string">'&gt; {line}\n'</span>.format(line=line)
                <span class="keyword">for</span> line <span class="keyword">in</span> response.splitlines()
            ))
            self.client_connection.sendall(response)
        <span class="keyword">finally</span>:
            self.client_connection.close()


SERVER_ADDRESS = (HOST, PORT) = <span class="string">''</span>, <span class="number">8888</span>


<span class="function"><span class="keyword">def</span> <span class="title">make_server</span><span class="params">(server_address, application)</span>:</span>
    server = WSGIServer(server_address)
    server.set_app(application)
    <span class="keyword">return</span> server


<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:
        sys.exit(<span class="string">'Provide a WSGI application object as module:callable'</span>)
    app_path = sys.argv[<span class="number">1</span>]
    module, application = app_path.split(<span class="string">':'</span>)
    module = __import__(module)
    application = getattr(module, application)
    httpd = make_server(SERVER_ADDRESS, application)
    print(<span class="string">'WSGIServer: Serving HTTP on port {port} ...\n'</span>.format(port=PORT))
    httpd.serve_forever()
</code></pre><p>　　上面的代码确实比第一部分服务器的代码长，但是为了让你能够理解而不至于陷入细节的泥潭中，它已经足够短了（不到150行）。上面的服务器也能做更多——它能运行用你喜欢的框架（Pyramid, flask, Django或者其他Python WSGI框架）编写的基本web应用程序。<br>　　不信？动手试一下吧。保存上面的代码到<code>webserver2.py</code>或者直接从<a href="https://github.com/rspivak/lsbaws/blob/master/part2/webserver2.py" target="_blank" rel="external">GitHub</a>上下载。如果你试图运行时不带任何参数，它会提示并退出。</p>
<pre><code>$ python webserver2<span class="class">.py</span>
Provide <span class="tag">a</span> WSGI application <span class="tag">object</span> as module:callable
</code></pre><p>　　它真的想服务你的web应用程序，这就是有趣的开始。运行这个服务器你唯一要做的就是安装Python。但是要运行用Pyramid, flask或Django开发的应用，你需要先安装这些框架。让我们来安装这三个框架吧，我更喜欢使用virtualenv，只需要按照下面的步骤去创建和激活一个虚拟环境，就可以安装这三个框架了。</p>
<pre><code><span class="char">$ </span>[sudo] pip install virtualenv
<span class="char">$ </span>mkdir ~/envs
<span class="char">$ </span>virtualenv ~/envs/lsbaws/
<span class="char">$ </span>cd ~/envs/lsbaws/
<span class="char">$ </span>ls
bin  include  lib
<span class="char">$ </span>source bin/activate
(lsbaws) <span class="char">$ </span>pip install pyramid
(lsbaws) <span class="char">$ </span>pip install flask
(lsbaws) <span class="char">$ </span>pip install django
</code></pre><h3 id="Pyramid框架">Pyramid框架</h3><p>　　这时，你需创建一个Web应用程序。我们首先从Pyramid开始吧，保存下面的代码到<code>pyramidapp.py</code>并放到与<code>webserver2.py</code>的相同路径下，或者直接从<a href="https://github.com/rspivak/lsbaws/blob/master/part2/pyramidapp.py" target="_blank" rel="external">GitHub</a>上下载。</p>
<pre><code>from pyramid<span class="class">.config</span> import Configurator
from pyramid<span class="class">.response</span> import Response


def <span class="function"><span class="title">hello_world</span><span class="params">(request)</span></span>:
    return Response(
        <span class="string">'Hello world from Pyramid!\n'</span>,
        content_type=<span class="string">'text/plain'</span>,
    )

config = <span class="function"><span class="title">Configurator</span><span class="params">()</span></span>
config.<span class="function"><span class="title">add_route</span><span class="params">(<span class="string">'hello'</span>, <span class="string">'/hello'</span>)</span></span>
config.<span class="function"><span class="title">add_view</span><span class="params">(hello_world, route_name=<span class="string">'hello'</span>)</span></span>
app = config.<span class="function"><span class="title">make_wsgi_app</span><span class="params">()</span></span>
</code></pre><p>　　现在，你可以准备用你自己的web server服务你的Pyramid应用了：</p>
<pre><code>(lsbaws) $ python webserver2.py pyramidapp:app
WSGIServer: Serving HTTP <span class="function_start"><span class="keyword">on</span></span> port <span class="number">8888</span> …
</code></pre><p>　　刚才你告诉你的服务器去从python模块<code>pyramidapp</code>中加载一个可调用的app对象。现在你的服务已经准备好接收请求，转发请求至你的Pyramid应用程序。当前应用程序只处理一个路由：<code>\hello路由</code>。在浏览器地址栏输入<code>http://localhost:8888/hello</code>，回车观察结果：<br><img src="/imgs/WS_part2_browser_pyramid.png" width="400" height="250"></p>
<p>　　你也可以在命令行用<code>curl</code> 指令来测试服务器：</p>
<pre><code><span class="variable">$ </span>curl -v <span class="symbol">http:</span>/<span class="regexp">/localhost:8888/hello</span>
…
</code></pre><p>　　检查服务器和<code>curl</code>打印出的标准输出。</p>
<h3 id="Flask框架">Flask框架</h3><p>　　现在轮到Flask了，让我们按照相同步骤来操作。</p>
<pre><code><span class="keyword">from</span> flask <span class="keyword">import</span> Flask
<span class="keyword">from</span> flask <span class="keyword">import</span> Response
flask_app = Flask(<span class="string">'flaskapp'</span>)


<span class="decorator">@flask_app.route('/hello')</span>
<span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span>
    <span class="keyword">return</span> Response(
        <span class="string">'Hello world from Flask!\n'</span>,
        mimetype=<span class="string">'text/plain'</span>
    )

app = flask_app.wsgi_app
</code></pre><p>　　保存上面的代码到<code>flaskapp.py</code>，或者直接从<a href="https://github.com/rspivak/lsbaws/blob/master/part2/flaskapp.py" target="_blank" rel="external">GitHub</a>上下载，运行服务器：</p>
<pre><code>(lsbaws) $ python webserver2.py flaskapp:app
WSGIServer: Serving HTTP <span class="function_start"><span class="keyword">on</span></span> port <span class="number">8888</span> …
</code></pre><p>　　在浏览器输入<code>http://localhost:8888/hello</code>，回车：<br><img src="/imgs/WS_part2_browser_flask.png" width="400" height="250"></p>
<p>　　再次用<code>curl</code>命令，看一下服务器返回Flask应用程序生成的信息：</p>
<pre><code><span class="variable">$ </span>curl -v <span class="symbol">http:</span>/<span class="regexp">/localhost:8888/hello</span>
…
</code></pre><h3 id="Django框架">Django框架</h3><p>　　服务器也能处理Django应用吗？试一试！这一次涉及的内容有点复杂，我建议你克隆这个仓库，然后使用GitHUb仓库中的<code>djangoapp.py</code>文件。下面的源码主要是添加Django<code>Helloworld</code>工程（预先使用Django的<code>diango-admin.py</code>startproject命令）到当前Python路径，然后倒入项目中的WSGI应用。</p>
<pre><code><span class="keyword">import</span> sys
sys.path.insert(<span class="number">0</span>, <span class="string">'./helloworld'</span>)
<span class="keyword">from</span> helloworld <span class="keyword">import</span> wsgi

app = wsgi.application
</code></pre><p>　　保存上面的代码到<code>djangoapp.py</code>，用你的web server运行Django应用程序：</p>
<pre><code>(lsbaws) $ python webserver2.py djangoapp:app
WSGIServer: Serving HTTP <span class="function_start"><span class="keyword">on</span></span> port <span class="number">8888</span> …
</code></pre><p>　　输入下面的地址，回车：<br><img src="/imgs/WS_part2_browser_django.png" width="400" height="250"></p>
<p>　　正如你之前做过的那几次一样，你也可以在命令行中进行测试，确认Django应用处理了你这次的请求：</p>
<pre><code><span class="variable">$ </span>curl -v <span class="symbol">http:</span>/<span class="regexp">/localhost:8888/hello</span>
…
</code></pre><p>　　你试过了吗？你确认了服务器可以和上面三个框架一起工作吗？如果没有的话，一定要试一下。阅读很重要，但是这个系列是关于重新构建，也就意味着你必须自己动手尝试。去尝试一下吧，不用担心，我会等你的。我是认真的，你必须尝试，最好能够自己重新敲下这些代码，来确保它能达到预期的效果。
　　</p>
<h3 id="构建自己微型的WSGI_Web框架">构建自己微型的WSGI Web框架</h3><p>　　好了，你已经体验了WSGI的威力了：它允许你混合搭配你的web server和web框架。WSGI提供了Python web server和Python web框架之间的最小接口。它非常简单，不管在服务器端还是在框架端实现它都是很容易的。下面的代码片段展示了服务器端和框架段的接口：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">run_application</span><span class="params">(application)</span>:</span>
    <span class="string">"""Server code."""</span>
    <span class="comment"># This is where an application/framework stores</span>
    <span class="comment"># an HTTP status and HTTP response headers for the server</span>
    <span class="comment"># to transmit to the client</span>
    headers_set = []
    <span class="comment"># Environment dictionary with WSGI/CGI variables</span>
    environ = {}

    <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span>
        headers_set[:] = [status, response_headers]

    <span class="comment"># Server invokes the ‘application' callable and gets back the</span>
    <span class="comment"># response body</span>
    result = application(environ, start_response)
    <span class="comment"># Server builds an HTTP response and transmits it to the client</span>
    …

<span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">(environ, start_response)</span>:</span>
    <span class="string">"""A barebones WSGI app."""</span>
    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>)])
    <span class="keyword">return</span> [<span class="string">'Hello world!'</span>]

run_application(app)
</code></pre><p>下面是它的工作原理：</p>
<ol>
<li>框架提供了<code>application</code>可调用对象（WSGI规范没有规定它的实现方式）。</li>
<li>每当收到来自HTTP客户端的请求的时候，服务器端调用<code>application</code>可调用对象。它把一个包含<code>WSGI/CGI</code>变量的字典<code>environ</code>和一个<code>start_response</code>可调用对象作为参数传递给<code>application</code>可调用对象。</li>
<li>框架/应用程序生成一个HTTP状态（status）和HTTP响应头（headers），并传递给<code>start_response</code>可调用对象，让服务器把它们存储起来。框架/应用程序也返回了一个响应正文(body)。</li>
<li>服务器把状态、响应头以及响应正文合并为一个HTTP响应，然后把它传输给客户端（这个步骤不是规范的一部分，但它是流程的下一个逻辑步骤，为了清晰可见我把它加到这里）<br>下面是这个接口的可视化表现：<img src="/imgs/WS_part2_wsgi_interface.png" width="400" height="250">
</li>
</ol>
<p>　　到现在为止，你已经见到了Pyramid, Flask和Django Web应用程序，你也见到了实现WSGI规范的服务器端代码。你见到了不用任何框架实现的精简代码片段。<br>　　当你用上述其中之一的框架开发web应用程序时候，你是在一个高层面工作，并没有直接与WSGI打交道，但是我知道你一定对WSGI接口的框架端非常好奇，因为你在阅读这篇文章。那么，让我们来创建一个不使用Pyramid, Flask或者Django的微型WSGI Web应用/Web框架，并用你的服务器运行它：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">(environ, start_response)</span>:</span>
    <span class="string">"""A barebones WSGI application.

    This is a starting point for your own Web framework :)
    """</span>
    status = <span class="string">'200 OK'</span>
    response_headers = [(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>)]
    start_response(status, response_headers)
    <span class="keyword">return</span> [<span class="string">'Hello world from a simple WSGI application!\n’]</span>
</code></pre><p>　　同样的，把上面的代码保存为<code>wsgiapp.py</code>或者直接从<a href="https://github.com/rspivak/lsbaws/blob/master/part2/wsgiapp.py" target="_blank" rel="external">GitHub</a>上下载，然后用你的web server运行：</p>
<pre><code>(lsbaws) $ python webserver2.py wsgiapp:app
WSGIServer: Serving HTTP <span class="function_start"><span class="keyword">on</span></span> port <span class="number">8888</span> …
</code></pre><p>　　输入下面的地址，回车，你会看到下面的结果：<br><img src="/imgs/WS_part2_browser_simple_wsgi_app.png" width="400" height="250"></p>
<h3 id="HTTP响应">HTTP响应</h3><p>　　在学习如何创建一个web server的同时，你刚刚写出了自己的微型WSGI Web框架。真是意外之喜。<br>　　现在让我们回到服务器给客户端传输什么。下面是当你用HTTP客户端调用你的Pyramid应用程序时，服务器生成的HTTP响应。<br><img src="/imgs/WS_part2_http_response.png" width="400" height="250"></p>
<p>　　上述响应和你在<a href="http://zhangyuyu.github.io/2016/03/05/WebServer1/" target="_blank" rel="external">第一部分</a>看到的有些类似，但是也有一些新的内容。比如，有四个之前没见过的HTTP headers: <code>Content-Type</code>，<code>Content-Length</code>，<code>Date</code>，<code>Server</code>。这些都是web server生成的响应头信息中应该含有的。虽然它们都不是被严格要求的，但是这些头信息的目的是传输有关HTTP请求/响应的附加信息。<br>　　现在你更多的了解了关于WSGI的接口，下面是同一个HTTP响应关于哪些部分生成它的详细信息：<br><img src="/imgs/WS_part2_http_response_explanation.png" width="400" height="250"></p>
<p>　　到现在我还没有说任何有关<code>environ</code>字典的信息，但是，它基本上就是一个Pyhon字典，这个字典必须包含某些有WSGI规定所规定的WSGI和CGI变量。解析完请求之后，服务器从HTTP请求中拿到了字典所需要的值。字典的内容如下：<br><img src="/imgs/WS_part2_environ.png" width="400" height="250"></p>
<p>　　Web 框架用这个字典的信息，来决定使用哪个view（基于指定路由和请求方法等）；决定从哪里读取请求的正文；以及把错误信息写在哪里，如果有的话。
　　</p>
<h3 id="总结">总结</h3><p>　　目前为止，现在你已经创建了你自己的WSGI Web server，并且你已经用不同的Web框架写了Web应用程序。这一路你也创建了精简的web应用/Web框架。这真是一件了不起的旅程。让我们重述为了服务一个针对WSGI应用的请求，你的WSGI Web server要做的事情：</p>
<ol>
<li>首先，服务器启动并且加载由Web框架/应用提供的<code>application</code>可调用对象。</li>
<li>其次，服务器读取一个请求</li>
<li>然后，服务器解析请求</li>
<li>紧接着，服务器用请求数据构建一个<code>environ</code>字典</li>
<li>然后，服务器把<code>environ</code>字典和一个<code>start_response</code>可调用对象作为参数传递给<code>application</code>可调用对象，并且获得相应正文。</li>
<li>之后，服务器用通过调用<code>application</code>可调用对象获得body数据，以及通过<code>start_response</code>可调用对象设置的状态和响应头信息一起构造一个HTTP响应。</li>
<li>最后，服务器把HTTP响应传输回客户端。<img src="/imgs/WS_part2_server_summary.png" width="400" height="250">
</li>
</ol>
<p>　　这就是全部了，你现在有了一个可以工作的WSGI服务器，它可以服务那些用WSGI兼容的Web框架（Django，Flask，Pyramid或者你自己写的WSGI框架）开发的Web应用程序。最好的是服务器能够在不改变服务器代码的情况下与多个Web框架使用。还不错！<br>在你离开之前，还有一个问题需要你思考，“如何让你的服务器一次处理多个请求？”<br>　　敬请关注，在第三部分我会展示给你一种实现方式。谢谢！
　　</p>
<blockquote>
<p>本文翻译自Ruslan’s Blog <a href="https://ruslanspivak.com/lsbaws-part2/" target="_blank" rel="external">Let’s Build A Web Server. Part 2.</a></p>
</blockquote>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/webServer/" rel="tag">#webServer</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/04/18/微服务-服务注册与发现/" rel="prev">微服务-服务注册与发现</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/05/WebServer1/" rel="next">创建你自己的Web Server - part 1</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
              <div class="ds-thread" data-thread-key="2016/03/06/WebServer2/"
                   data-title="创建你自己的Web Server - part 2" data-url="http://yoursite.com/2016/03/06/WebServer2/">
              </div>
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/imgs/figure.jpg" alt="Zhang Yu" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Zhang Yu</p>
        </div>
        <p class="site-description motion-element" itemprop="description">行是知之始，知是行之成</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pyramid框架"><span class="nav-number">1.</span> <span class="nav-text">Pyramid框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flask框架"><span class="nav-number">2.</span> <span class="nav-text">Flask框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Django框架"><span class="nav-number">3.</span> <span class="nav-text">Django框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建自己微型的WSGI_Web框架"><span class="nav-number">4.</span> <span class="nav-text">构建自己微型的WSGI Web框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP响应"><span class="nav-number">5.</span> <span class="nav-text">HTTP响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Yu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhangyuyu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
<a href="https://github.com/zhangyuyu"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-
</body>
</html>
