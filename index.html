<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="行是知之始，知是行之成" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="若见喻笺" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="行是知之始，知是行之成">
<meta property="og:type" content="website">
<meta property="og:title" content="若见喻笺">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="若见喻笺">
<meta property="og:description" content="行是知之始，知是行之成">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="若见喻笺">
<meta name="twitter:description" content="行是知之始，知是行之成">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> 若见喻笺 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-hk">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">若见喻笺</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            標籤
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            <i class="menu-item-icon icon-next-guestbook"></i> <br />
            留言
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/07/17/Docker-workshop-5-Docker网络/" itemprop="url">
                Docker Workshop（五）Docker网络
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2017-07-17T16:50:23+08:00" content="2017-07-17">
            2017-07-17
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Docker/" itemprop="url" rel="index">
                  <span itemprop="name">Docker</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2017/07/17/Docker-workshop-5-Docker网络/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/17/Docker-workshop-5-Docker网络/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>　　<a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">上一篇 Docker的数据存储</a>主要讲述Docker数据管理的两种方式：数据卷和数据卷容器。<br>本篇主要讲述网络的实现、网络模型、网络模式等相关知识。</p>
<h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">容器简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">Docker简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">Docker的基本操作</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">Docker数据存储</a></li>
<li><strong>Docker网络</strong></li>
<li>Docker安全</li>
<li>多主机部署</li>
<li>服务发现</li>
<li>日志、跟踪、监控</li>
</ul>
<h2 id="三、网络的实现"><a href="#三、网络的实现" class="headerlink" title="三、网络的实现"></a>三、网络的实现</h2><p>　　Docker现有的网络模型主要是通过使用Network namespace、Linux Bridge、Iptables、veth pair等技术实现的。</p>
<ul>
<li>Network namespace（网络命名空间）<br>　　Network namespace主要提供了关于网络资源的隔离，包括网络设备、IPv4和IPv6协议栈、IP路由表、防火墙、/proc/net目录、/sys/class/net目录、端口（socket）等。</li>
<li>Linux Bridge<br>　　功能相当于物理交换机，为连在其上的设备（容器）转发数据帧。如docker0网桥。</li>
<li>Iptables<br>　　主要为容器提供NAT以及容器网络安全。</li>
<li>veth pair（虚拟网络设备）<br>　　两个虚拟网卡组成的数据通道。在Docker中，用于连接Docker容器和Linux Bridge。一端在容器中作为eth0网卡，另一端在Linux Bridge中作为网桥的一个端口。</li>
</ul>
<h2 id="四、网络创建过程"><a href="#四、网络创建过程" class="headerlink" title="四、网络创建过程"></a>四、网络创建过程</h2><img src="/imgs/docker-network-implement.png" width="500" height="250">
<p>　　Docker创建一个容器的时候，会具体执行如下操作：</p>
<ul>
<li>创建一对虚拟接口，即veth pair，分别放到宿主机和容器中;</li>
<li>本地主机一端的虚拟接口，连接到默认的docker0网桥或指定网桥上，并具有一个以veth开头的唯一的名字，如veth0ac844e;</li>
<li>容器一端的虚拟接口，将放到新容器中，并修改名字为eth0，该接口只在容器的命名空间可见;</li>
<li>从网桥可用地址段中获取一个空闲地址分配给容器的eth0（例如172.17.0.2/16），并配置默认路由网关为dokcer0的IP地址。</li>
</ul>
<p>　　完成这些配置之后，该容器就可以使用eth0虚拟网卡来连接其它容器和访问外部网络了。<br>　　当该容器结束后，Docker会清空容器，容器内的网络接口eth0会随网络命名空间一起被清除，veth0ac844e接口也被自动从docker0卸载。</p>
<p>　　另外，可以在docker运行的时候通过–net参数指定容器的网络配置，有<a href="1-单节点网络模式">四个可选值</a>。</p>
<h3 id="【练习1】网络创建细节"><a href="#【练习1】网络创建细节" class="headerlink" title="【练习1】网络创建细节"></a>【练习1】网络创建细节</h3><p>1）启动一个 /bin/bash 容器，指定 –net=none 参数</p>
<pre><code>$ sudo docker run -i -t --rm --net=none busybox /bin/sh
</code></pre><p>2) 在<code>本地主机</code>查找容器的进程 id，并为它创建网络命名空间。</p>
<pre><code>$ sudo docker inspect -f &apos;{{.State.Pid}}&apos; 5259b04d2a50
2559
$ pid=2559
$ sudo mkdir -p /var/run/netns
$ sudo ln -s /proc/$pid/ns/net /var/run/netns/$pid
</code></pre><p>3）查看网桥docker0分配的子网段</p>
<pre><code>$ ip addr show docker0
6: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:89:d3:35:32 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:89ff:fed3:3532/64 scope link
       valid_lft forever preferred_lft forever
</code></pre><p>4) 创建一对 “veth pair” 接口 A 和 B，绑定 A 到网桥 docker0，并启用它</p>
<pre><code>$ sudo ip link add A type veth peer name B
$ sudo brctl addif docker0 A
$ sudo ip link set A up
</code></pre><p>5）将B放到容器的网络命名空间，命名为 eth0，启动它并配置一个可用 IP（桥接网段）和默认网关</p>
<pre><code>$ sudo ip link set B netns $pid
$ sudo ip netns exec $pid ip link set dev B name eth0
$ sudo ip netns exec $pid ip link set eth0 up
$ sudo ip netns exec $pid ip addr add 172.17.42.1/16 dev eth0
$ sudo ip netns exec $pid ip route add default via 172.17.0.1
</code></pre><p>6) 其他指令</p>
<pre><code># 查看网桥docker0上的虚拟接口
$ brctl show
bridge name bridge id       STP enabled interfaces
br-fe42067d4b8f     8000.0242987a3884   no
docker0     8000.024289d33532   no      veth76e4a32
lxcbr0      8000.000000000000   no

# 查看网桥docker0的生成树状态
$ brctl show docker0
bridge name bridge id       STP enabled interfaces
docker0     8000.024289d33532   no      veth76e4a32

# 查看网桥docker0的网卡驱动类型
$ ethtool -i docker0
driver: bridge
version: 2.3
firmware-version: N/A
bus-info: N/A
supports-statistics: no
supports-test: no
supports-eeprom-access: no
supports-register-dump: no
supports-priv-flags: no

# 查看该网络接口的唯一识别编号peer_ifindex
$ ethtool -S veth76e4a32
NIC statistics:
     peer_ifindex: 7

# 查看路由信息
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:domain
ACCEPT     udp  --  anywhere             anywhere             udp dpt:domain
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:bootps
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootps
Chain FORWARD (policy ACCEPT)
target     prot opt source               destination
DROP       all  --  172.18.0.0/16        172.17.0.0/16
DROP       all  --  172.17.0.0/16        172.18.0.0/16
DOCKER     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
DOCKER     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
Chain DOCKER (2 references)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             172.17.0.2           tcp dpt:5000
</code></pre><h2 id="五、网络模型"><a href="#五、网络模型" class="headerlink" title="五、网络模型"></a>五、网络模型</h2><h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><p>　　在容器网络模型中，通常会包括容器(Container)、沙箱(Sandbox)、端点(Endpoint)、网络(Network)等组件，其中，网络会涉及桥接网(Bridge Network)或重叠网(Overlay Network)。<br><img src="/imgs/docker-network-concept.png" width="500" height="250"></p>
<ul>
<li>容器(Container): 容器能够作为任意一个或多个网络的一部分，能够同时对接桥接网和重叠网网络。</li>
<li>沙箱(Sandbox): 包含容器网络堆栈配置信息，是一个隔离的环境，可能包含多网络的多个端点。</li>
<li>端点(Endpoint): 连接沙箱和网络的接口，绑定到特定的网络，比如之前提到的veth pair。</li>
<li>网络(Network): 使得一组端点之间能够相互直接交流的，实现可以是Linux网桥或重叠</li>
</ul>
<h3 id="与Docker-Links对比"><a href="#与Docker-Links对比" class="headerlink" title="与Docker Links对比"></a>与Docker Links对比</h3><p>与Docker Links进行简单对比，Docker Links允许容器之间互相发现，并使用容器名作为别名进行互相之间的通信，比DNS或服务发现更容易使用，且不用关心端口映射，但Docker Links有一些限制，比如:</p>
<ul>
<li>只能在同一宿主机内使用，不能跨主机</li>
<li>重新创建容器会移除之前的链接(Links)</li>
<li>被链接的容器必须是一个已经启动的容器<br>因此，在Docker 1.9版本之后，官方推荐使用Docker网络功能代替Docker Links。Docker容器网络模型的主要优势在于:</li>
<li>在某个特定网络下的所有容器能自由地相互通信</li>
<li>多个网络有助于分散容器之间的流量传输</li>
<li>多个端点允许一个容器加入到多个网络中</li>
<li>能够支持同主机和跨主机的容器间通信</li>
</ul>
<h2 id="四、Docker网络模式"><a href="#四、Docker网络模式" class="headerlink" title="四、Docker网络模式"></a>四、Docker网络模式</h2><p><a href="#1-单节点网络模式">1. 单节点网络模式</a></p>
<ul>
<li><a href="#1-1.bridge模式">bridge模式</a></li>
<li><a href="#1-2.host模式">host模式</a></li>
<li><a href="#1-3.container模式">container模式</a> </li>
<li><a href="#1-4.none模式">none模式</a></li>
</ul>
<p><a href="#2-多节点网络模式">2. 多节点网络模式</a></p>
<ul>
<li><a href="#2-1.原生支持">原生支持</a></li>
<li><a href="#2-2.插件">插件</a></li>
</ul>
<h3 id="1-单节点网络模式"><a href="#1-单节点网络模式" class="headerlink" title="1-单节点网络模式"></a>1-单节点网络模式</h3><h4 id="1-1-bridge模式"><a href="#1-1-bridge模式" class="headerlink" title="1-1.bridge模式"></a>1-1.bridge模式</h4><p>使用–net=host指定<br>该模式中，Docker守护进程创建一个虚拟以太网桥docker0，附加在其上的任何网卡之间都能自动转发数据包。默认情况下，守护进程会创建一对对等接口，将其中一个接口设置为容器的eth0接口，另一个接口放置在宿主机的命名空间中，从而将宿主机上的所有容器都连接到这个内部网络上。同时，守护进程还会从网桥的私有地址空间中分配一个IP地址和子网给该容器。</p>
<h4 id="1-2-host模式"><a href="#1-2-host模式" class="headerlink" title="1-2.host模式"></a>1-2.host模式</h4><p>使用–net=host指定<br>该模式将禁用Docker容器的网络隔离。因为容器共享了宿主机的网络命名空间，直接暴露在公共网络中。因此，你需要通过端口映射（port mapping）来进行协调。</p>
<p>当使用host模式网络时，容器实际上继承了宿主机的IP地址。该模式比bridge模式更快（因为没有路由开销），但是它将容器直接暴露在公共网络中，是有安全隐患的。</p>
<h4 id="1-3-container模式"><a href="#1-3-container模式" class="headerlink" title="1-3.container模式"></a>1-3.container模式</h4><p>使用–net=host指定<br>该模式会重用另一个容器的网络命名空间。通常来说，当你想要自定义网络栈时，该模式是很有用的。实际上，该模式也是Kubernetes使用的网络模式。</p>
<h4 id="1-4-none模式"><a href="#1-4-none模式" class="headerlink" title="1-4.none模式"></a>1-4.none模式</h4><p>使用–net=none指定<br>该模式将容器放置在它自己的网络栈中，但是并不进行任何配置。实际上，该模式关闭了容器的网络功能，在以下两种情况下是有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）；你希望自定义网络。</p>
<p>####【练习2】单主机创建网络<br>1) 创建<code>web</code>网络，并创建一个基于<code>web</code>网络的容器<code>web_container</code></p>
<pre><code>$ docker network create web
a3f32cf362412ca10cc375c0cbf304c15b1cfd2a0da6addb97ef3606bcb04350
$ docker network ls
NETWORK ID          NAME                DRIVER
134b9d559a29        host                host
20d10cc6ad42        bridge              bridge
a3f32cf36241        web                 bridge
e7f9d75e45b8        none                null
$ docker run -itd --net=web --name web_container busybox
fdec55f5db5da821825fe5b091e69e248f8f346273a9397ea66a931b4c26bb7f
$ docker network inspect web
[
    {
        &quot;Name&quot;: &quot;web&quot;,
        &quot;Id&quot;: &quot;a3f32cf362412ca10cc375c0cbf304c15b1cfd2a0da6addb97ef3606bcb04350&quot;,
        &quot;Scope&quot;: &quot;local&quot;,
        &quot;Driver&quot;: &quot;bridge&quot;,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;default&quot;,
            &quot;Config&quot;: [
                {}
            ]
        },
        &quot;Containers&quot;: {
            &quot;fdec55f5db5da821825fe5b091e69e248f8f346273a9397ea66a931b4c26bb7f&quot;: {
                &quot;EndpointID&quot;: &quot;67b284bcef2544ec153c90e041c7d51351d5f2cea63e31537352e37ac8fb1fe6&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,
                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        },
        &quot;Options&quot;: {}
    }
]
</code></pre><p>2） 重复操作<code>1）</code>，创建另外一个基于<code>app</code>网络的容器</p>
<pre><code>$ docker network create app
$ docker network ls
NETWORK ID          NAME                DRIVER
20d10cc6ad42        bridge              bridge
a3f32cf36241        web                 bridge
e7f9d75e45b8        none                null
134b9d559a29        host                host
73eda6fce093        app                 bridge
$ docker run -itd --name app_container --net=app busybox
$ docker network inspect app
</code></pre><p>3) 连接<code>web_container</code>到<code>app</code>网络</p>
<pre><code>$ docker network connect app web_container
</code></pre><p>这样<code>web_container</code>就可以通过<code>web_container.app</code>连接<code>app</code>网络了:</p>
<pre><code>$ docker exec app_container ping web_container.app
PING web_container.app (172.19.0.3): 56 data bytes
64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.118 ms
64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.080 ms
</code></pre><p>4) 连接<code>app_container</code>到<code>web</code>网络</p>
<pre><code># 连接之前：
$ docker exec web_container ping app_container.web
ping: bad address &apos;app_container.web&apos;

# 连接
$ docker network connect web app_container

# 连接之后
$ docker exec web_container ping app_container.web
PING app_container.web (172.18.0.3): 56 data bytes
64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.219 ms
64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.111 ms
</code></pre><p>5) 查看网络信息</p>
<ul>
<li><p>查看连接之后web网络的containers里面就有两个container了</p>
<p>  $ docker network inspect web<br>  [</p>
<pre><code>{
    &quot;Name&quot;: &quot;web&quot;,
    &quot;Id&quot;: &quot;a3f32cf362412ca10cc375c0cbf304c15b1cfd2a0da6addb97ef3606bcb04350&quot;,
    &quot;Scope&quot;: &quot;local&quot;,
    &quot;Driver&quot;: &quot;bridge&quot;,
    &quot;IPAM&quot;: {
        &quot;Driver&quot;: &quot;default&quot;,
        &quot;Config&quot;: [
            {}
        ]
    },
    &quot;Containers&quot;: {
        &quot;59b01ca0444b4c708b521725532762512bc57ec9fdfccb2e2a6addef8a072f05&quot;: {
            &quot;EndpointID&quot;: &quot;dd969e4ec9703cf87adfd97b22bb8e06ec8a12139c948aceb6aea70388d23d31&quot;,
            &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,
            &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,
            &quot;IPv6Address&quot;: &quot;&quot;
        },
        &quot;fdec55f5db5da821825fe5b091e69e248f8f346273a9397ea66a931b4c26bb7f&quot;: {
            &quot;EndpointID&quot;: &quot;67b284bcef2544ec153c90e041c7d51351d5f2cea63e31537352e37ac8fb1fe6&quot;,
            &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,
            &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,
            &quot;IPv6Address&quot;: &quot;&quot;
        }
    },
    &quot;Options&quot;: {}
}
</code></pre><p>  ]                                   </p>
</li>
<li><p>查看container的NetworkSettings，里面Networks有两个网络了：</p>
<p>  $ docker inspect web_container<br>  “Networks”: {</p>
<pre><code>    &quot;app&quot;: {
        &quot;EndpointID&quot;: &quot;b06bbe5ea7dbaa96fecb2165404185effa0d6ebf01b028633f2afe00664cf16d&quot;,
        &quot;Gateway&quot;: &quot;172.19.0.1&quot;,
        &quot;IPAddress&quot;: &quot;172.19.0.3&quot;,
        &quot;IPPrefixLen&quot;: 16,
        &quot;IPv6Gateway&quot;: &quot;&quot;,
        &quot;GlobalIPv6Address&quot;: &quot;&quot;,
        &quot;GlobalIPv6PrefixLen&quot;: 0,
        &quot;MacAddress&quot;: &quot;02:42:ac:13:00:03&quot;
    },
    &quot;web&quot;: {
        &quot;EndpointID&quot;: &quot;67b284bcef2544ec153c90e041c7d51351d5f2cea63e31537352e37ac8fb1fe6&quot;,
        &quot;Gateway&quot;: &quot;172.18.0.1&quot;,
        &quot;IPAddress&quot;: &quot;172.18.0.2&quot;,
        &quot;IPPrefixLen&quot;: 16,
        &quot;IPv6Gateway&quot;: &quot;&quot;,
        &quot;GlobalIPv6Address&quot;: &quot;&quot;,
        &quot;GlobalIPv6PrefixLen&quot;: 0,
        &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;
    }
}
</code></pre></li>
</ul>
<h3 id="2-多节点网络模式"><a href="#2-多节点网络模式" class="headerlink" title="2-多节点网络模式"></a>2-多节点网络模式</h3><h4 id="2-1-原生支持"><a href="#2-1-原生支持" class="headerlink" title="2-1.原生支持"></a>2-1.原生支持</h4><p>Docker 在 1.19 版本中引入的基于 VxLAN 的对跨节点网络的原生支持，即自带重叠网络(Overlay Network) 组件。<br>Docker 支持 Consul, Etcd, 和 ZooKeeper 三种分布式key-value 存储。其中，etcd 是一个高可用的分布式 k/v存储系统，使用etcd的场景默认处理的数据都是控制数据，对于应用数据，只推荐数据量很小，但是更新访问频繁的情况。</p>
<h4 id="【练习3】利用Docker-Swarm多主机创建网络"><a href="#【练习3】利用Docker-Swarm多主机创建网络" class="headerlink" title="【练习3】利用Docker Swarm多主机创建网络"></a>【练习3】利用Docker Swarm多主机创建网络</h4><p>1) 先准备两台虚拟机作为Docker Swarm的两个节点Node1，Node2。</p>
<pre><code>$ midir docker-cluster
$ cd docker-cluster
$ vim Vagrantfile
</code></pre><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Vagrant.configure(<span class="number">2</span>) <span class="built_in">do</span> |<span class="type">config</span>|</div><div class="line">  <span class="type">(1</span>.<span class="number">.2</span>).each <span class="built_in">do</span> |<span class="type">i</span>|</div><div class="line">    <span class="type">config</span>.vm.define <span class="string">"wanzi-node#&#123;i&#125;"</span> <span class="built_in">do</span> |<span class="type">node</span>|</div><div class="line">      <span class="type">node</span>.vm.box = <span class="string">"comiq/dockerbox"</span></div><div class="line">      node.vm.provider <span class="string">"virtualbox"</span> <span class="built_in">do</span> |<span class="type">vb</span>|</div><div class="line">        <span class="type">vb</span>.name = <span class="string">"wanzi-node#&#123;i&#125;"</span></div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<pre><code>$ vagrant up
Bringing machine &apos;wanzi-node1&apos; up with &apos;virtualbox&apos; provider...
Bringing machine &apos;wanzi-node2&apos; up with &apos;virtualbox&apos; provider...
==&gt; wanzi-node1: Checking if box &apos;comiq/dockerbox&apos; is up to date...
==&gt; wanzi-node1: VirtualBox VM is already running.
==&gt; wanzi-node2: Importing base box &apos;comiq/dockerbox&apos;...
==&gt; wanzi-node2: Matching MAC address for NAT networking...
==&gt; wanzi-node2: Checking if box &apos;comiq/dockerbox&apos; is up to date...
==&gt; wanzi-node2: Setting the name of the VM: wanzi-node2
==&gt; wanzi-node2: Fixed port collision for 22 =&gt; 2222. Now on port 2201.
==&gt; wanzi-node2: Clearing any previously set network interfaces...
==&gt; wanzi-node2: Preparing network interfaces based on configuration...
    wanzi-node2: Adapter 1: nat
==&gt; wanzi-node2: Forwarding ports...
    wanzi-node2: 22 =&gt; 2201 (adapter 1)
==&gt; wanzi-node2: Booting VM...
==&gt; wanzi-node2: Waiting for machine to boot. This may take a few minutes...
    wanzi-node2: SSH address: 127.0.0.1:2201
    wanzi-node2: SSH username: vagrant
    wanzi-node2: SSH auth method: private key
    wanzi-node2: Warning: Connection timeout. Retrying...
==&gt; wanzi-node2: Machine booted and ready!
==&gt; wanzi-node2: Checking for guest additions in VM...
==&gt; wanzi-node2: Mounting shared folders...
    wanzi-node2: /vagrant =&gt; /Users/yuzhang/Downloads/Devops/docker_cluster
</code></pre><p>2） <strong>Node1</strong>作为Manager<br>登陆到Node1:</p>
<pre><code>$ vagrant ssh wanzi-node1
Welcome to Ubuntu 16.04 LTS (GNU/Linux 4.4.0-21-generic x86_64)
 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage
</code></pre><p>在Node1上初始化并创建Docker Swarm，作为Manager:</p>
<pre><code>vagrant@vagrant:~$  docker swarm init --advertise-addr 192.168.59.1:2377
Swarm initialized: current node (85qhfwludbf603gcazjqippl2) is now a manager.
To add a worker to this swarm, run the following command:
docker swarm join \
--token SWMTKN-1-5rv6l22kow7fhpthihiy5oqi8ka4mospeele38ycsfuwsviv1y-bekemef3aafmbanavzkeekjch \
192.168.59.1:2377
</code></pre><p>To add a manager to this swarm, run ‘docker swarm join-token manager’ and follow the instructions.</p>
<p>3) <strong>Node2</strong>作为Worker<br>登陆到Node2:</p>
<pre><code>$ vagrant ssh wanzi-node1
</code></pre><p>在Node2上运行如下命令加入到Swarm中，作为Worker:</p>
<pre><code>vagrant@vagrant:~$ docker swarm join \
&gt;     --token SWMTKN-1-5rv6l22kow7fhpthihiy5oqi8ka4mospeele38ycsfuwsviv1y-bekemef3aafmbanavzkeekjch \
&gt;     192.168.59.1:2377
This node joined a swarm as a worker.
</code></pre><p>4) 在<strong>Node1</strong>上查看所有node信息</p>
<pre><code>vagrant@vagrant:~$ docker node ls
ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
85qhfwludbf603gcazjqippl2 *  vagrant   Ready   Active        Leader
9o4sy1vcd5nygr77jrjpl28sn    vagrant   Ready   Active
</code></pre><p>5) 在<strong>Node2</strong>上则<strong>不</strong>能查看所有node信息</p>
<pre><code>vagrant@vagrant:~$ docker node ls
Error response from daemon: This node is not a swarm manager. Worker nodes can&apos;t be used to view or modify cluster state. Please run this command on a manager node or promote the current node to a manager.
</code></pre><p>6) 在<strong>Node1</strong>上创建<code>overlay</code>网络</p>
<pre><code>vagrant@vagrant:~$ docker network create -d=overlay net_overlay
0aa8c2nu8vwwbep0spui8upva
vagrant@vagrant:~$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
9cbbdda300b9        bridge              bridge              local
eb0832fa48cc        docker_gwbridge     bridge              local
d9cbc7492332        host                host                local
6agtuhiw3e1r        ingress             overlay             swarm
0aa8c2nu8vww        net_overlay         overlay             swarm
e5bb8590c3b8        none                null                local
</code></pre><p>这样，所有在Swarm中的主机都可以访问该网络了，除了docker0默认网桥外，这里多出了一个docker_gwbridge的网桥，docker0在跨多主机容器网络中并没有被用到，而是docker_gwbridge替代了docker0用来实现Overlay网络中容器间的通信以及容器到外部的通信，其职能就和单机容器网络中docker0一样。</p>
<pre><code>vagrant@vagrant:~$ docker network inspect net_overlay
[
    {
        &quot;Name&quot;: &quot;net_overlay&quot;,
        &quot;Id&quot;: &quot;0aa8c2nu8vwwbep0spui8upva&quot;,
        &quot;Scope&quot;: &quot;swarm&quot;,
        &quot;Driver&quot;: &quot;overlay&quot;,
        &quot;EnableIPv6&quot;: false,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;default&quot;,
            &quot;Options&quot;: null,
            &quot;Config&quot;: []
        },
        &quot;Internal&quot;: false,
        &quot;Containers&quot;: null,
        &quot;Options&quot;: {
            &quot;com.docker.network.driver.overlay.vxlanid_list&quot;: &quot;257&quot;
        },
        &quot;Labels&quot;: null
    }
]
</code></pre><p>7) 创建服务<br>　　创建一个名为hello的服务，包含2个副本，使用sleep infinity的命令运行，该命令使得容器不会立即退出:</p>
<pre><code>vagrant@vagrant:~$ docker service ls
ID            NAME   REPLICAS  IMAGE   COMMAND
alq1vrojrwd6  hello  0/2       ubuntu  sleep infinity
vagrant@vagrant:~$ docker service ps hello
ID                         NAME     IMAGE   NODE     DESIRED STATE  CURRENT STATE          ERROR
66zkihz10oaoxv1i94niud0cy  hello.1  ubuntu  vagrant  Running        Running 4 seconds ago
08stnpfqhg3rhtb1nd3dxxade  hello.2  ubuntu  vagrant  Running        Running 5 seconds ago
</code></pre><p>可以分别在Node1和Node2上查看运行的容器：<br>Node1:</p>
<pre><code>vagrant@vagrant:~$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
63f768d6b911        ubuntu:latest       &quot;sleep infinity&quot;    28 seconds ago      Up 27 seconds                           hello.2.08stnpfqhg3rhtb1nd3dxxade
</code></pre><p>Node2:</p>
<pre><code>vagrant@vagrant:~$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
e506461b95f3        ubuntu:latest       &quot;sleep infinity&quot;    48 seconds ago      Up 47 seconds                           hello.1.66zkihz10oaoxv1i94niud0cy
</code></pre><p>8) 检查连通性<br>Node1:</p>
<pre><code>vagrant@vagrant:~$ docker inspect -f {{.NetworkSettings.Networks.net_overlay.IPAddress}}  63f768d6b911
10.0.0.4
</code></pre><p>Node2:</p>
<pre><code>vagrant@vagrant:~$ docker inspect -f {{.NetworkSettings.Networks.net_overlay.IPAddress}}  e506461b95f3
10.0.0.3

 vagrant@vagrant:~$ docker exec hello.1.66zkihz10oaoxv1i94niud0cy apt-get update; apt-get install iputils-ping -y; ping 10.0.0.4
</code></pre><h4 id="2-2-插件"><a href="#2-2-插件" class="headerlink" title="2-2.插件"></a>2-2.插件</h4><p>该方式是通过插件（plugin）方式引入的第三方实现方案，比如 Weave, Calico, Contiv Netplugin, Cisco, VMware, MidoNet, pipework, flannel等等。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本篇文章主要是讲述Docker网络相关的内容，包括Docker的网络实现、网络创建过程、网络模型组件与优势、网络模式（单节点、多节点）等。<br><a href="">下一篇</a>将讲述Docker的安全。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://dockone.io/article/1261" target="_blank" rel="external">Docker网络模式</a></li>
<li><a href="http://www.cnblogs.com/sammyliu/p/5894191.html" target="_blank" rel="external">理解Docker网络</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/advanced_network/&lt;ptp class=&quot;html&quot;&gt;&lt;/ptp" target="_blank" rel="external">Docker从入门到实践-高级网络配置</a></li>
<li><a href="http://dockone.io/article/1736" target="_blank" rel="external">使用Docker Swarm来运行服务</a></li>
<li><a href="http://kiwenlau.com/2016/07/03/vagrant-vm-cluster/" target="_blank" rel="external">使用Vagrant创建多节点虚拟机集群</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/07/13/Docker-workshop-4-Docker数据存储/" itemprop="url">
                Docker Workshop（四）Docker数据存储
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2017-07-13T08:18:24+08:00" content="2017-07-13">
            2017-07-13
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Docker/" itemprop="url" rel="index">
                  <span itemprop="name">Docker</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2017/07/13/Docker-workshop-4-Docker数据存储/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/13/Docker-workshop-4-Docker数据存储/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>　　<a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">上一篇 Docker的基本操作</a>按照构建流程练习了docker的一些常见基本指令。<br>本篇主要讲述Docker数据管理相关的内容。</p>
<h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">容器简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">Docker简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">Docker的基本操作</a></li>
<li><strong>Docker数据存储</strong></li>
<li><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">Docker网络</a></li>
<li>Docker安全</li>
<li>多主机部署</li>
<li>服务发现</li>
<li>日志、跟踪、监控</li>
</ul>
<p>本章主要通过练习<code>数据卷</code>和<code>数据卷容器</code>来理解Docker的数据管理。</p>
<h2 id="三、Docker的存储方式"><a href="#三、Docker的存储方式" class="headerlink" title="三、Docker的存储方式"></a>三、Docker的存储方式</h2><p>　　Docker存储驱动包含：AUFS、Device mapper、OverlayFS、Btrfs、ZF，它们提供了接口支持<strong>镜像分层</strong>与<strong>写时复制机制Cow</strong>，这两种技术满足了容器的核心价值，即极快的创建速度，极小的存储资源消耗以及容器迁移的便捷性。<br>容器的Root Image存储分为以下三类：</p>
<ul>
<li>AUFS，Overlay : 联合文件系统。</li>
<li>DeviceMapper：CoW块存储。</li>
<li>ZFS，btrfs: CoW文件系统。</li>
</ul>
<p>　　Docker并不推荐采用Root Image的存储方式来存储应用数据。因为应用数据对安全，可用性，共享，性能等方面的要求和Root Image的要求是完全不一样的。<br>　　Docker采用了Volume这样一个独立的数据访问接口，应用通过Volume去访问相关的数据，Volume的实现和CoW的分层文件系统完全独立。<br>　　Volume通过Rancher Convoy或者Flocker这样的存储驱动去管理和访问具体的存储设备。</p>
<h2 id="四、卷是什么"><a href="#四、卷是什么" class="headerlink" title="四、卷是什么"></a>四、卷是什么</h2><p>　　Docker的理念之一是将应用与其运行的环境进行打包，因此通常docker容器的生存周期与在容器中运行的程序的生存周期是一致的，当容器被销毁时，容器里的数据也会随之消失。</p>
<p>　　为了能够<strong>保存（持久化）数据</strong>以及<strong>共享容器间的数据</strong>，Docker提出了Volume的概念。<br>简单来说，Volume就是目录或者文件，它可以绕过默认的联合文件系统，而以正常的文件或者目录的形式存在于宿主机上。</p>
<h2 id="五、管理数据的两种方式"><a href="#五、管理数据的两种方式" class="headerlink" title="五、管理数据的两种方式"></a>五、管理数据的两种方式</h2><p>在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷（Data volumes）</li>
<li>数据卷容器（Data volume containers）</li>
</ul>
<h3 id="1-数据卷（Data-volumes）"><a href="#1-数据卷（Data-volumes）" class="headerlink" title="1. 数据卷（Data volumes）"></a>1. 数据卷（Data volumes）</h3><p>　　数据卷是容器内的一个特殊目录，该目录绕过UFS，不向顶层的可读写layer写入。数据卷用来保存、固化数据，独立于容器的生存周期，不会主动被回收。</p>
<p>数据卷特性：</p>
<ul>
<li>处于UFS(Union File System)之外</li>
<li>主机文件系统中的普通目录</li>
<li>在卷上的I/O性能应与主机上的完全相同</li>
<li>卷的内容不包含在Docker镜像中</li>
<li>任何对卷内容的修改不是镜像的一部分</li>
<li>可被多个容器共享和重用</li>
<li>持久化数据（即使容器已被删除</li>
</ul>
<blockquote>
<p><strong>注意</strong>：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。</p>
</blockquote>
<p>可以使用以下两种方式创建：</p>
<ul>
<li>在Dockerfile中指定VOLUME /some/dir</li>
<li>执行docker run -v /some/dir命令来指定<br>　　两种方式的区别在于<code>run的-v</code>可以指定挂载到宿主机的哪个目录，而<code>Dockerfile的VOLUME</code>不能，其挂载目录由docker随机生成。</li>
</ul>
<h4 id="【练习1】用-v添加一个数据卷"><a href="#【练习1】用-v添加一个数据卷" class="headerlink" title="【练习1】用-v添加一个数据卷"></a>【练习1】用-v添加一个数据卷</h4><p>1）启动一个基于busybox镜像的容器volume-example,并在其根目录下挂载一个data卷</p>
<pre><code>$ docker run -d -it --name volume-example -v /data busybox
</code></pre><p>2）查看data是否挂载成功</p>
<pre><code>$ docker exec volume-example ls | grep data
</code></pre><p>3) 查看data卷对应主机的目录；</p>
<pre><code>$ docker inspect -f {{.Mounts}} volume-example
[{093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f /var/lib/docker/volumes/093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f/_data /data local  true}]
</code></pre><blockquote>
<p>如果<code>步骤1）</code>，没有指定host的挂载目录，那么docker会自动创建一个挂载文件夹放在<br><code>/var/lib/docker/volumes/</code>下。上述例子中，在主机下的挂载目录是:</p>
<pre><code>/var/lib/docker/volumes/093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f/_data
</code></pre><p>如果<code>步骤1）</code>，指定了主机目录：</p>
<pre><code>$ docker run -d -it --name volume-example -v ~/volume/data:/data busybox
$ docker inspect -f {{.Mounts}} volume-example
[{ /home/vagrant/volume/data /data   true}]
</code></pre><p>那么在主机下挂载的目录则是自己指定的<code>~/volume/data</code>了。</p>
</blockquote>
<p>4) 在主机对应的目录创建一个文件</p>
<pre><code>$ sudo touch &lt;paste the copied host directory location&gt;/test-file
</code></pre><p>5) 在容器里面检查一下刚才创建的文件</p>
<pre><code>$ docker exec volume-example ls data/
</code></pre><p>6) 查看所有volumn</p>
<pre><code>$ docker volume ls
DRIVER              VOLUME NAME
local               bd0769d0b9a94e475b370d08ceafd9417499a8f3549a7b0f55f3be96f46b1b56
local               093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f
</code></pre><p>7） 查看volumn详细信息</p>
<pre><code>$ docker volume inspect 093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f
[
    {
        &quot;Name&quot;: &quot;093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f/_data&quot;
    }
]
</code></pre><h4 id="【练习2】用Dockerfile挂载数据卷"><a href="#【练习2】用Dockerfile挂载数据卷" class="headerlink" title="【练习2】用Dockerfile挂载数据卷"></a>【练习2】用Dockerfile挂载数据卷</h4><p>1） 创建一个<code>Dockerfile</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">FROM</span> <span class="string">busybox</span></div><div class="line"><span class="string">RUN</span> <span class="string">mkdir</span> <span class="string">/test-dir</span></div><div class="line"><span class="string">COPY</span> <span class="string">test.yml</span> <span class="string">/test-dir</span></div><div class="line"><span class="string">VOLUME</span> <span class="string">/test-dir</span></div></pre></td></tr></table></figure></p>
<p>2) 创建一个<code>test.yml</code>文件</p>
<pre><code>$ echo &quot;This is a test file for testing volume from Dockerfile.&quot; &gt; test.yml
</code></pre><p>3) 构建一个镜像</p>
<pre><code>$ docker build -t volume-example:test .
Sending build context to Docker daemon 8.192 kB
Step 1 : FROM busybox
 ---&gt; 103e96d345c0
Step 2 : RUN mkdir /test-dir
 ---&gt; Running in 10aa732b4099
 ---&gt; ef6b4c6bde95
Removing intermediate container 10aa732b4099
Step 3 : COPY test.yml /test-dir
 ---&gt; 7fe861cb8aef
Removing intermediate container 50b4cec740b7
Step 4 : VOLUME /test-dir
 ---&gt; Running in c20cfc350b8f
 ---&gt; 8ea4d7630233
Removing intermediate container c20cfc350b8f
Successfully built 8ea4d7630233
</code></pre><p>4） 查看该镜像所包含的卷信息</p>
<pre><code>$ docker inspect -f {{.Config.Volumes}} volume-example:test
map[/test-dir:{}]
</code></pre><p>5) Dockerfile中声明卷会占用镜像体积么？</p>
<pre><code>$ docker history volume-example:test
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
8ea4d7630233        39 seconds ago      /bin/sh -c #(nop) VOLUME [/test-dir]            0 B
7fe861cb8aef        39 seconds ago      /bin/sh -c #(nop) COPY file:6d145c083d0383b1b   56 B
ef6b4c6bde95        39 seconds ago      /bin/sh -c mkdir /test-dir                      0 B
103e96d345c0        4 weeks ago         /bin/sh -c #(nop)  CMD [&quot;sh&quot;]                   0 B
f16f9e1c2f42        4 weeks ago         /bin/sh -c #(nop) ADD file:aa56bc8f2fea9c0c81   1.106 MB
</code></pre><p>6) 运行容器</p>
<pre><code>$ docker run -d --name volume-example-container volume-example:test
c063baa2d2bd07373a563316a05a0c2793bca41883bc0964039dd96a8887cc3b

$ docker inspect -f {{.Mounts}} volume-example-container
[{054802484b2f99171b7d96be0b1e8028662d151b5491c80296d9b92e7d7d392b /var/lib/docker/volumes/054802484b2f99171b7d96be0b1e8028662d151b5491c80296d9b92e7d7d392b/_data /test-dir local  true}]

$ docker exec volume-example-container ls /test-dir
test.yml
</code></pre><p>7) 查看挂载的<code>test.yml</code>文件</p>
<pre><code>$ sudo ls /var/lib/docker/volumes/054802484b2f99171b7d96be0b1e8028662d151b5491c80296d9b92e7d7d392b/_data
test.yml
</code></pre><blockquote>
<p>Dockerfile中每一句指令，都会生成一个临时的容器，如:</p>
<pre><code>Step 4 : VOLUME /test-dir
---&gt; Running in c20cfc350b8f
---&gt; 8ea4d7630233
</code></pre><p>首先，<code>Step 4</code>里面生成了一个临时容器<code>c20cfc350b8f</code>;<br>然后，commit容器得到了镜像<code>8ea4d7630233</code>;<br>因此，<code>VOLUME /test-dir</code>是通过<code>是通过docker run -v  /test-dir</code>来实现的，随后由于容器的commit，该配置保存到了镜像<code>8ea4d7630233</code>里，可以通过如下质量查看</p>
<pre><code>$ docker inspect -f {{.Config.Volumes}} 8ea4d7630233
map[/test-dir:{}]
</code></pre><p>由于没有指定挂载到的宿主机目录，因此会默认挂载到宿主机的/var/lib/docker/volumes下的一个随机名称的目录下，因此Dockerfile里面的VOLUME不能指定主机挂载目录。</p>
</blockquote>
<h3 id="2-数据卷容器（Data-volume-containers）"><a href="#2-数据卷容器（Data-volume-containers）" class="headerlink" title="2. 数据卷容器（Data volume containers）"></a>2. 数据卷容器（Data volume containers）</h3><p>　　如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。<br>数据卷容器，其实就是一个正常的容器，是一个挂载了数据卷但是不执行任何命令的容器，其目的只是为其他容器提供数据卷，方便数据在多容器之间共享、复用。</p>
<p>使用数据容器的两个注意点：</p>
<ul>
<li>不要运行数据容器，这纯粹是在浪费资源。</li>
<li>不要为了数据容器而使用“最小的镜像”，如busybox或scratch，只使用数据库镜像本身就可以了。你已经拥有该镜像，所以并不需要占用额外的空间。</li>
</ul>
<h4 id="【练习3】创建数据卷容器"><a href="#【练习3】创建数据卷容器" class="headerlink" title="【练习3】创建数据卷容器"></a>【练习3】创建数据卷容器</h4><p>练习2里面已经创建了一个挂载数据卷的镜像了，这里我们只需要用该镜像创建(create，不用run)一个数据卷容器</p>
<pre><code>$ docker create --name volume-data-container volume-example:test
90cd6d51d364e6054c715f554c9a7921519ef4e4cddb2f5a54e1f86d8d202840
$ docker run -d --volumes-from volume-data-container --name volume-other volume-example:test
db57d89a10ee101df15e5fbbfa2b084526382a6ba5c15d133728011865f09a67
$ docker inspect -f {{.Mounts}} volume-data-container
[{2ce7145b0c5c286b13ef653349979a0f9f22048d6d80113b7edf98ceb61fc264 /var/lib/docker/volumes/2ce7145b0c5c286b13ef653349979a0f9f22048d6d80113b7edf98ceb61fc264/_data /test-dir local  true}]
$ docker inspect -f {{.Mounts}} volume-other
[{2ce7145b0c5c286b13ef653349979a0f9f22048d6d80113b7edf98ceb61fc264 /var/lib/docker/volumes/2ce7145b0c5c286b13ef653349979a0f9f22048d6d80113b7edf98ceb61fc264/_data /test-dir local  true}]
</code></pre><ul>
<li>可以使用超过一个的 –volumes-from 参数来指定从多个容器挂载不同的数据卷。 </li>
<li>使用 –volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。</li>
<li>也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。</li>
</ul>
<h4 id="【练习4】备份数据"><a href="#【练习4】备份数据" class="headerlink" title="【练习4】备份数据"></a>【练习4】备份数据</h4><pre><code>$  sudo docker run  --volumes-from volume-data-container -v ~/backup:/backup --name volume-backup volume-example:test tar cvf /backup/backup.tar /test-dir
test-dir/
test-dir/test.yml
</code></pre><ul>
<li>首先利用<code>volume-example:test</code>镜像创建了一个叫做<code>volume-backup</code>的容器。</li>
<li>使用<code>--volumes-from volume-data-container</code>来让<code>volume-backup</code>容器挂载<code>volume-data-container</code>的数据卷。</li>
<li>使用-v参数挂载本地的<code>~/backup</code>目录到容器的<code>/backup</code>目录下。</li>
<li><p>容器启动之后，使用了<code>tar cvf /backup/backup.tar /test-dir</code>来将数据容器<code>/test-dir</code>下的内容备份为<code>/backup/backup.tar</code>(对应到宿主机下~/bakup.tar)。</p>
<p>  $ ls ~/backup/<br>  backup.tar</p>
</li>
</ul>
<h4 id="【练习5】恢复数据"><a href="#【练习5】恢复数据" class="headerlink" title="【练习5】恢复数据"></a>【练习5】恢复数据</h4><p>1）创建一个带有数据卷的容器</p>
<pre><code>$ sudo docker run -v /test-dir --name volumn-data-container2 volume-example:test /bin/sh 
</code></pre><p>2）创建另外一个新的容器，挂载上面的数据卷容器，并使用untar解压备份文件到所挂载的容器卷</p>
<pre><code>$ sudo docker run --volumes-from volumn-data-container2 -v ~/backup:/backup busybox tar xvf /backup/backup.tar
</code></pre><h4 id="【练习6】删除数据卷"><a href="#【练习6】删除数据卷" class="headerlink" title="【练习6】删除数据卷"></a>【练习6】删除数据卷</h4><p>如果你已经使用docker rm来删除你的容器，那可能有很多的孤立的Volume仍在占用着空间。</p>
<p>Volume只有在下列情况下才能被删除：</p>
<ul>
<li>该容器是用docker rm －v命令来删除的（-v是必不可少的）。</li>
<li>docker run中使用了–rm参数</li>
<li>手动去<code>/var/lib/docker/volumes/</code>删除</li>
</ul>
<h3 id="3-数据卷和数据卷容器的比较"><a href="#3-数据卷和数据卷容器的比较" class="headerlink" title="3. 数据卷和数据卷容器的比较"></a>3. 数据卷和数据卷容器的比较</h3><img src="/imgs/docker-volumn-vs-container.png" width="500" height="250">
<h2 id="六、卷插件"><a href="#六、卷插件" class="headerlink" title="六、卷插件"></a>六、卷插件</h2><p>数据卷<br>优点：</p>
<ul>
<li>跟主机磁盘性能一样</li>
<li>容器删除后依然保留</li>
</ul>
<p>缺点：</p>
<ul>
<li>仅限本地磁盘</li>
<li>不能随容器迁移</li>
</ul>
<p>Docker推出了Volume plugin接口机制，让第三方的存储厂商来支持Docker Volume并且在此基础上进行功能拓展。</p>
<img src="/imgs/docker-volumn-plugin.png" width="500" height="250">
<ul>
<li><p>Rancher Convoy：Convoy是Rancher Labs用go开发的支持Device Mapper、NFS、EBS、GlusterFS多种后端存储的Docker Volume plugin driver. Convoy还提供了一个存储拓展功能（如快照、备份恢复等）的接口框架。</p>
</li>
<li><p>Flocker：Flocker volume plugin driver主要用于多主机环境Docker数据卷的迁移，从而支持数据库应用等stateful有状态应用的主机间迁移。</p>
</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>　　本篇文章主要是讲述了Docker的数据存储以及数据管理。<br><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">下一篇</a>将讲述Docker的网络。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://dockone.io/article/1257" target="_blank" rel="external">Docker容器对存储的定义</a></li>
<li><a href="http://dockone.io/article/1729" target="_blank" rel="external">Docker存储方式选型建议</a></li>
<li><a href="https://medium.com/@ramangupta/why-docker-data-containers-are-good-589b3c6c749e" target="_blank" rel="external">Why Docker Data Containers (Volumes!) are Good</a></li>
<li><a href="https://rominirani.com/docker-tutorial-series-part-7-data-volumes-93073a1b5b72" target="_blank" rel="external">Data Volumes</a></li>
<li><a href="http://container-solutions.com/understanding-volumes-docker/" target="_blank" rel="external">Understanding Volumes in Docker</a></li>
<li><a href="http://clusterhq.com/2015/12/09/difference-docker-volumes-flocker-volumes/" target="_blank" rel="external">Docker Volumes vs Docker Volumes with Flocker</a></li>
<li><a href="http://feisky.xyz/docker/data_management/volume.html" target="_blank" rel="external">Docker数据管理</a></li>
<li><a href="http://www.ywnds.com/?p=7015" target="_blank" rel="external">Docker：容器数据管理</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/07/11/Docker-workshop-3-Docker的基本操作/" itemprop="url">
                Docker Workshop（三）Docker的基本操作
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2017-07-11T22:08:27+08:00" content="2017-07-11">
            2017-07-11
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Docker/" itemprop="url" rel="index">
                  <span itemprop="name">Docker</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2017/07/11/Docker-workshop-3-Docker的基本操作/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/11/Docker-workshop-3-Docker的基本操作/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>　　<a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">上一篇 Docker简介</a>讲述了Docker相关的理论知识，了解了Docker的场景及优势，练习了内核的namespace以及cgroup。<br>　　本篇将开始实际动手操作，熟悉docker基本的指令。</p>
<h3 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h3><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">容器简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">Docker简介</a></li>
<li><strong>Docker的基本操作</strong></li>
<li><a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">Docker数据存储</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">Docker网络</a></li>
<li>Docker安全</li>
<li>多主机部署</li>
<li>服务发现</li>
<li>日志、跟踪、监控</li>
</ul>
<p>本章通过以下系列过程，来熟悉Docker的基本指令：</p>
<ul>
<li>构建镜像；</li>
<li>搭建私有registry；</li>
<li>上传镜像、获取镜像；</li>
<li>创建容器、运行容器；</li>
<li>连接容器</li>
<li>使用Docker-compose工具</li>
</ul>
<h3 id="三、Docker镜像"><a href="#三、Docker镜像" class="headerlink" title="三、Docker镜像"></a>三、Docker镜像</h3><h4 id="1-镜像是什么"><a href="#1-镜像是什么" class="headerlink" title="1. 镜像是什么"></a>1. 镜像是什么</h4><p>　　Docker镜像是一个特殊的<strong>文件系统</strong>，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>镜像通常包含：</p>
<ul>
<li>一个轻量级的操作系统发行版</li>
<li>相关依赖</li>
<li>单个应用或服务</li>
</ul>
<h4 id="2-镜像的分层存储"><a href="#2-镜像的分层存储" class="headerlink" title="2. 镜像的分层存储"></a>2. 镜像的分层存储</h4><p>　　传统的Linux加载bootfs时会先将rootfs设为read-only，然后在系统自检之后将rootfs从read-only改为read-write，然后我们就可以在rootfs上进行写和读的操作了。<br>　　但Docker的镜像却不是这样，它在bootfs自检完毕之后并不会把rootfs的read-only改为read-write。而是利用union mount（UnionFS的一种挂载机制）将一个或多个read-only的rootfs加载到之前的read-only的rootfs层之上。</p>
<img src="/imgs/docker-image-layer1.png" width="400" height="250">
<p>可以通过<code>docker info</code>查看宿主机上docker的文件系统方式：</p>
<pre><code>$ docker info
Containers: 3
Images: 267
Server Version: 1.9.1
Storage Driver: aufs
 Root Dir: /var/lib/docker/aufs
 Backing Filesystem: extfs
 Dirs: 273
 Dirperm1 Supported: true
Execution Driver: native-0.2
Logging Driver: json-file
Kernel Version: 3.19.0-32-generic
Operating System: Ubuntu 14.04.3 LTS
CPUs: 2
Total Memory: 3.431 GiB
Name: workshop
ID: 27OE:SE73:WCPT:366X:CCGS:G2NQ:RB2A:UVJ2:A3OC:CZUJ:RYCB:XDDE
WARNING: No swap limit support
</code></pre><h4 id="3-练习构建镜像"><a href="#3-练习构建镜像" class="headerlink" title="3. 练习构建镜像"></a>3. 练习构建镜像</h4><p>　　<a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">上一篇</a>讲到获取镜像有三种方式，其中自己从无到有地创建镜像，Docker有两种方式：</p>
<ul>
<li>创建一个容器，运行若干命令，再使用<code>docker commit</code>来生成一个新的镜像。以这种方式创建的镜像不具备再生产能力且无法实现版本控制性，因此绝对<strong>不值得提倡</strong>。</li>
<li>创建一个<code>Dockerfile</code>然后再使用<code>docker build</code>来创建一个镜像。大多人会使用<code>Dockerfile</code>来创建镜像。</li>
</ul>
<h4 id="【练习1】通过Dockerfile构建镜像"><a href="#【练习1】通过Dockerfile构建镜像" class="headerlink" title="【练习1】通过Dockerfile构建镜像"></a>【练习1】通过Dockerfile构建镜像</h4><p>1）创建一个Dockerfile<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">FROM</span> <span class="attr">debian:8</span></div><div class="line"><span class="string">MAINTAINER</span> <span class="string">John</span> <span class="string">Citizen</span></div><div class="line"><span class="string">RUN</span> <span class="string">apt-get</span> <span class="string">update</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></div><div class="line"><span class="string">apt-get</span> <span class="string">install</span> <span class="bullet">-y</span> <span class="string">nginx</span></div><div class="line"><span class="string">EXPOSE</span> <span class="number">80</span></div><div class="line"><span class="string">CMD</span> <span class="string">["nginx",</span> <span class="string">"-g"</span><span class="string">,</span> <span class="string">"daemon off;"</span><span class="string">]</span></div></pre></td></tr></table></figure></p>
<img src="/imgs/docker-image-layers-history.png" width="500" height="350">
<p>2）生成镜像<br><code>docker build -t nginx-demo .</code>其中<code>.</code>是当前目录，包含<code>Dockerfile</code>文件</p>
<pre><code>$ docker build -t nginx-demo .
Sending build context to Docker daemon 7.168 kB
Step 1 : FROM debian:8
8: Pulling from library/debian
aaec12cbddb4: Pull complete
a4231e14d761: Pull complete
Digest: sha256:64682f1a6d256b358b10dba3669b22f3594c69ec790548f5ba6362276ac9d4ca
Status: Downloaded newer image for debian:8
 ---&gt; a4231e14d761
Step 2 : MAINTAINER John Citizen
 ---&gt; Running in 35d7b813f3ec
 ---&gt; 3abd0b877321
Removing intermediate container 35d7b813f3ec
Step 3 : RUN apt-get update &amp;&amp; apt-get install -y nginx
 ---&gt; Running in f75d9c834ee9
 ---&gt; 352a72a3b8a8
Removing intermediate container f75d9c834ee9
Step 4 : EXPOSE 80
 ---&gt; Running in c9939361ce4d
 ---&gt; e55ea9a20dd4
Removing intermediate container c9939361ce4d
Step 5 : CMD nginx -g daemon off;
 ---&gt; Running in bdac893db4aa
 ---&gt; 7bd0c6e98644
Removing intermediate container bdac893db4aa
Successfully built 7bd0c6e98644
</code></pre><p>可以看到Docker会创建（create -&gt; commit -&gt; destroy）一些临时的容器，如<code>Step 2</code>的<code>35d7b813f3ec</code>，生成的新的镜像作为中间镜像会被保存在cache中。可以通过下面两种方式查看该临时容器：</p>
<pre><code>$ docker inspect 3abd0b877321
$ docker images -a |grep 3abd0b877321
</code></pre><p>3）查看所有镜像</p>
<pre><code>$ docker images
</code></pre><p>4）查看<code>nginx-demo</code>镜像信息</p>
<pre><code>$ docker inspect nginx-demo
$ docker inspect -f &apos;{{ .Config.ExposedPorts }}&apos; nginx-demo
</code></pre><p>5) 查看创建镜像的历史</p>
<pre><code>$ docker history nginx-demo:latest
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
7bd0c6e98644        5 minutes ago       /bin/sh -c #(nop) CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon o   0 B
e55ea9a20dd4        5 minutes ago       /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B
352a72a3b8a8        5 minutes ago       /bin/sh -c apt-get update &amp;&amp; apt-get install    71.8 MB
3abd0b877321        6 minutes ago       /bin/sh -c #(nop) MAINTAINER John Citizen       0 B
a4231e14d761        3 weeks ago         /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0 B
aaec12cbddb4        3 weeks ago         /bin/sh -c #(nop) ADD file:9c48682ff75c756544   123.5 MB
</code></pre><ul>
<li>容器镜像包括元数据和文件系统，其中文件系统是指对基础镜像的文件系统的修改，元数据不影响文件系统，只是会影响容器的配置;</li>
<li>每个步骤都会生成一个新的镜像，新的镜像与上一次的镜像相比，要么元数据有了变化，要么文件系统有了变化而多加了一层;</li>
<li>Docker在需要执行指令时通过创建临时镜像，运行指定的命令，再通过<code>docker commit</code>来生成新的镜像;</li>
<li>Docker会将中间镜像都保存在缓存中，这样将来如果能直接使用的话就不需要再从头创建了。</li>
<li>由于每一行指令，都会产生一个镜像，因此可以使用链式指令，有助于构建较小的镜像。(更多内容可以阅读《高性能Docker》)</li>
</ul>
<h3 id="四、Docker仓库"><a href="#四、Docker仓库" class="headerlink" title="四、Docker仓库"></a>四、Docker仓库</h3><h4 id="【练习2】使用Docker-public仓库"><a href="#【练习2】使用Docker-public仓库" class="headerlink" title="【练习2】使用Docker public仓库"></a>【练习2】使用Docker public仓库</h4><pre><code>$ docker search busybox
NAME                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
busybox                         Busybox base image.                             1052      [OK]
progrium/busybox                                                                65                   [OK]
radial/busyboxplus              Full-chain, Internet enabled, busybox made...   13                   [OK]
container4armhf/armhf-busybox   Automated build of Busybox for armhf devic...   8                    [OK]
ofayau/busybox-jvm              Prepare busybox to install a 32 bits JVM.       2                    [OK]
azukiapp/busybox                This image is meant to be used as the base...   2                    [OK]
multiarch/busybox               multiarch ports of ubuntu-debootstrap           2                    [OK]
ofayau/busybox-libc32           Busybox with 32 bits (and 64 bits) libs         1                    [OK]
skomma/busybox-data             Docker image suitable for data volume cont...   1                    [OK]
prom/busybox                    Prometheus Busybox Docker base images           1                    [OK]
elektritter/busybox-teamspeak   Leightweight teamspeak3 container based on...   1                    [OK]
clover/busybox                  BusyBox base image                              1                    [OK]
getblank/busybox                Docker container busybox for Blank              1                    [OK]
zanner/busybox                  https://github.com/sergej-kucharev/zanner-...   1                    [OK]
cucy/busybox                    aouto  build busybox                            0                    [OK]
adamant/busybox                 Busybox base image and debian package inst...   0                    [OK]
sdurrheimer/prom-busybox        Moved to https://hub.docker.com/r/prom/bus...   0                    [OK]
ggtools/busybox-ubuntu          Busybox ubuntu version with extra goodies       0                    [OK]
ddn0/busybox                    fork of official busybox                        0                    [OK]
hongtao12310/busybox            for busybox image based on the gcr.io/goog...   0                    [OK]
freenas/busybox                 Simple Busybox interactive Linux container      0                    [OK]
kakaximeng/busybox              busybox                                         0                    [OK]
jahroots/busybox                Busybox containers                              0                    [OK]
jiangshouzhuang/busybox         busybox                                         0                    [OK]
stubbornrock/busybox            busybox:latest                                  0                    [OK]

$ docker pull busybox
</code></pre><h4 id="【练习3】搭建Docker-private仓库"><a href="#【练习3】搭建Docker-private仓库" class="headerlink" title="【练习3】搭建Docker private仓库"></a>【练习3】搭建Docker private仓库</h4><p>1) 需要提前创建证书文件cert，并放到相应的地方。<br>通过<code>registry:2</code>镜像运行起了一个私有registry如下：</p>
<pre><code>docker run -d \
  -p 5000:5000 \
  --restart=always \
  --name registry \
  -v /home/vagrant/topics/tmp/registry-certs:/certs \
  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/registry_hostname.crt \
  -e REGISTRY_HTTP_TLS_KEY=/certs/registry_hostname.key \
  registry:2
</code></pre><p>2) 查看所有docker容器</p>
<pre><code>$ docker ps -a
</code></pre><p>3) 访问私有registry接口</p>
<pre><code>$ sudo curl -is --cacert /etc/docker/certs.d/registry:5000/registry.crt https://registry:5000/v2/
HTTP/1.1 200 OK
Content-Length: 2
Content-Type: application/json; charset=utf-8
Docker-Distribution-Api-Version: registry/2.0
Date: Wed, 12 Jul 2017 13:30:17 GMT
HTTP/1.1 200 OK
</code></pre><h3 id="五、发布镜像到仓库"><a href="#五、发布镜像到仓库" class="headerlink" title="五、发布镜像到仓库"></a>五、发布镜像到仓库</h3><h4 id="【练习4】上传镜像到registry"><a href="#【练习4】上传镜像到registry" class="headerlink" title="【练习4】上传镜像到registry"></a>【练习4】上传镜像到registry</h4><p>1）给镜像打标签</p>
<pre><code>$ docker tag nginx-demo registry:5000/nginx-demo
</code></pre><p>2) 查看所有镜像</p>
<pre><code>$ docker images
REPOSITORY                      TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
nginx-demo                      latest              8ef43fa97b67        About a minute ago   195.3 MB
registry:5000/nginx-demo        latest              8ef43fa97b67        About a minute ago   195.3 MB
</code></pre><p>3）上传镜像</p>
<pre><code>$ docker push registry:5000/nginx-demo
The push refers to a repository [registry:5000/nginx-demo] (len: 1)
8ef43fa97b67: Pushed
5982f0a481be: Pushed
c329ad2e9994: Pushed
cdea4d036852: Pushed
aaec12cbddb4: Pushed
latest: digest: sha256:399e271209f61771afc03896bea5cd107d2da64985b7bea6733b9380b181b31b size: 8470
</code></pre><p>4）访问registry接口查看镜像是否存在</p>
<pre><code>$ export CERT_PATH=/etc/docker/certs.d/registry:5000/registry.crt
$ sudo curl -s --cacert ${CERT_PATH} https://registry:5000/v2/_catalog
{&quot;repositories&quot;:[&quot;nginx-demo&quot;]}
</code></pre><p>5) 删除本地镜像</p>
<pre><code>$ docker rmi nginx-demo
Untagged: nginx-demo:latest
Deleted: 7bd0c6e986444a5855665a4b746130088904bc5b7626d5bb5c0dc3ab52fc1142
Deleted: e55ea9a20dd4b5d4ede4a4873e18e94f139df646085c79c83d12f71815559dda
Deleted: 352a72a3b8a8ad51f8a84a357fcb3af0a127c8cefc34b6d5839fdcd8c06ececd
Deleted: 3abd0b8773212881d3e73babe2304d5b760c0b156095bd9496ceb2fedf71fd62
</code></pre><p>6）从私有registry上拉取镜像</p>
<pre><code>$ docker pull registry:5000/nginx-demo
Using default tag: latest
latest: Pulling from nginx-demo
31f1e1f22679: Pull complete
51c8e8d08671: Pull complete
04ec693a6b9c: Pull complete
ae06ee9e3b16: Pull complete
59c395799b5f: Pull complete
26d4e0d847a6: Pull complete
Digest: sha256:399e271209f61771afc03896bea5cd107d2da64985b7bea6733b9380b181b31b
Status: Downloaded newer image for registry:5000/nginx-demo:latest
</code></pre><h3 id="六、启动Docker容器"><a href="#六、启动Docker容器" class="headerlink" title="六、启动Docker容器"></a>六、启动Docker容器</h3><h4 id="【练习5】启动Docker容器"><a href="#【练习5】启动Docker容器" class="headerlink" title="【练习5】启动Docker容器"></a>【练习5】启动Docker容器</h4><p>1) 启动一个容器</p>
<pre><code>$ docker run -d -p 80:80 --name nginx-app registry:5000/nginx-demo
a56d494e8af22247eccbd7e99f108501684b52395a50f479cca09caa8ec18b19
$ docker ps
CONTAINER ID        IMAGE                      COMMAND                  CREATED             STATUS              PORTS                    NAMES
a56d494e8af2        registry:5000/nginx-demo   &quot;nginx -g &apos;daemon off&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:80-&gt;80/tcp       nginx-app
7d01136fd367        registry:2                 &quot;/bin/registry /etc/d&quot;   22 minutes ago      Up 22 minutes       0.0.0.0:5000-&gt;5000/tcp   registry
</code></pre><p>此处用<code>docker run</code>是创建并启动，<code>docker create</code>是单纯创建容器。<br>2）查看容器log</p>
<pre><code>$ docker logs nginx-app
</code></pre><h3 id="七、连接Docker容器"><a href="#七、连接Docker容器" class="headerlink" title="七、连接Docker容器"></a>七、连接Docker容器</h3><h4 id="【练习6】连接多个Docker容器"><a href="#【练习6】连接多个Docker容器" class="headerlink" title="【练习6】连接多个Docker容器"></a>【练习6】连接多个Docker容器</h4><p>假设我们有如下三个应用，且都已经publish到了registry中：</p>
<ul>
<li>shop-app，需要连接review和catalogue</li>
<li>review，微服务</li>
<li>catalogue，微服务</li>
</ul>
<p>1）先启动<code>review</code>和<code>catalogue</code></p>
<pre><code>$ docker run -d -p 8082:8082 --name review registry:5000/review
$ docker run -d -p 8084:8084 --name catalogue registry:5000/catalogue
</code></pre><p>2）连接<code>shop-app</code>到<code>review</code>和<code>catalogue</code></p>
<pre><code>$ docker run -d -p 8080:8080 --name shop-app --link review:review --link catalogue:catalogue registry:5000/shop-app
</code></pre><p>3）查看<code>shop-app</code>容器</p>
<pre><code>$ docker exec shop-app cat /etc/hosts
</code></pre><p>4）确认<code>shop-app</code>可以连接到<code>review</code></p>
<pre><code>$ docker exec -t shop-app ping review
</code></pre><p>　　以下是Docker link的一些限制：</p>
<ul>
<li>Docker link 只在同一宿主机内可以使用</li>
<li>重新创建容器将会移除之前的链接</li>
<li>被连接的容器必须是一个已经启动的容器</li>
</ul>
<p>　　在Docker发布1.9版本的时候推荐使用<code>Docker Networks</code>代替<code>Docker link</code>，后面的<a href="">Docker Workshop（五）Docker网络</a>会讲到Docker Networks。</p>
<h3 id="八、使用Docker-Compose"><a href="#八、使用Docker-Compose" class="headerlink" title="八、使用Docker Compose"></a>八、使用Docker Compose</h3><p>　　Compose是用于定义和运行复杂Docker应用的工具。你可以在一个文件中定义一个多容器的应用，然后使用一条命令来启动你的应用，然后所有相关的操作都会被自动完成。</p>
<h4 id="【练习7】使用Docker-compose工具"><a href="#【练习7】使用Docker-compose工具" class="headerlink" title="【练习7】使用Docker compose工具"></a>【练习7】使用Docker compose工具</h4><p>1）创建一个<code>docker-compose.yml</code>文件<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="attr">shop-app:</span></div><div class="line"><span class="attr">  image:</span> <span class="attr">registry:5000/shop-app</span></div><div class="line"><span class="attr">  ports:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">"8080:8080"</span></div><div class="line"><span class="attr">  links:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">review</span></div><div class="line"><span class="bullet">    -</span> <span class="string">catalogue</span></div><div class="line"></div><div class="line"><span class="attr">review:</span></div><div class="line"><span class="attr">  image:</span> <span class="attr">registry:5000/review</span></div><div class="line"></div><div class="line"><span class="attr">catalogue:</span></div><div class="line"><span class="attr">  image:</span> <span class="attr">registry:5000/catalogue</span></div></pre></td></tr></table></figure></p>
<p>2) 启动三个容器</p>
<pre><code>$ docker-compose up
</code></pre><p>3） 查看运行的容器</p>
<pre><code>$ docker-compose ps
</code></pre><p>3）查看log</p>
<pre><code>$ docker-compose logs
</code></pre><p><code>docker-compose</code>可以查看所有在<code>docker-compose.yml</code>中声明的容器的日志，不用切换tab查看单独的docker容器日志。</p>
<h3 id="九、使用容器时要避免的做法"><a href="#九、使用容器时要避免的做法" class="headerlink" title="九、使用容器时要避免的做法"></a>九、使用容器时要避免的做法</h3><ul>
<li>不要在容器中保存数据（Don’t store data in containers）</li>
<li>将应用打包到镜像再部署而不是更新到已有容器（Don’t ship your application in two pieces）</li>
<li>不要产生过大的镜像 （Don’t create large images）</li>
<li>不要使用单层镜像 （Don’t use a single layer image）</li>
<li>不要从运行着的容器上产生镜像 （Don’t create images from running containers ）</li>
<li>不要只是使用 “latest”标签 （Don’t use only the “latest” tag）</li>
<li>不要在容器内运行超过一个的进程 （Don’t run more than one process in a single container ）</li>
<li>不要在容器内保存 credentials，而是要从外面通过环境变量传入 （ Don’t store credentials in the image. Use environment variables）</li>
<li>不要使用 root 用户跑容器进程（Don’t run processes as a root user ）</li>
<li>不要依赖于IP地址，而是要从外面通过环境变量传入 （Don’t rely on IP addresses ）</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>　　本篇文章主要是按照构建流程练习了docker的一些常见基本指令，指令并不全面，详细的指令可以参考<a href="https://docs.docker.com/engine/reference/commandline/docker/#parent-command" target="_blank" rel="external">官网</a>进行练习。<br>　　<a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">下一篇</a>将讲述Docker的数据存储。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="http://feisky.xyz/docker/index.html" target="_blank" rel="external">Docker笔记</a></li>
<li><a href="https://developers.redhat.com/blog/2016/02/24/10-things-to-avoid-in-docker-containers/" target="_blank" rel="external">10 things to avoid in docker containers</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/07/10/Docker-workshop-2-Docker简介/" itemprop="url">
                Docker Workshop（二）Docker简介
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2017-07-10T08:59:59+08:00" content="2017-07-10">
            2017-07-10
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Docker/" itemprop="url" rel="index">
                  <span itemprop="name">Docker</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2017/07/10/Docker-workshop-2-Docker简介/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/10/Docker-workshop-2-Docker简介/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>　　容器技术已经出现了相当一段时间了，例如LXC, BSD Jails, Solaris Zones… 那为什么出现了Docker，中间缺失了什么呢？<br>　　<a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">上一篇</a>讲述了容器相关的知识，练习了LXC容器的相关指令，本篇接着讲述Docker的出现以及Docker相关的理论基础。</p>
<h3 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h3><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">容器简介</a></li>
<li><strong>Docker简介</strong></li>
<li><a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">Docker的基本操作</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">Docker数据存储</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">Docker网络</a></li>
<li>Docker安全</li>
<li>多主机部署</li>
<li>服务发现</li>
<li>日志、跟踪、监控</li>
</ul>
<h3 id="三、从Linux容器到Docker"><a href="#三、从Linux容器到Docker" class="headerlink" title="三、从Linux容器到Docker"></a>三、从Linux容器到Docker</h3><blockquote>
<p>尽管有着光辉的历史，容器仍未得到广泛的认可。一个很重要的原因就是容器技术的复杂性：容器本身就比较复杂，不易安装 管理和自动化也很困难。而Docker就是为了改变这一切而生 ——《第一本Docker书》</p>
</blockquote>
<p>　　<a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8/" target="_blank" rel="external">上一篇</a>练习里，我们可以明显感受到，LXC存在的问题是难以移动——难以通过标准化的模板制作、重建、复制和移动container。</p>
<p>　　在LXC的基础上，Docker进一步优化了容器的使用体验。Docker提供了各种容器管理工具（如：<strong>分发、版本、移植</strong>等）让用户无需关注底层的操作，可以更简单的管理和使用容器。</p>
<p>　　早期的Docker代码实现是直接基于LXC的。自0.9版本开始，Docker开发了libcontainer项目，作为更广泛的容器驱动实现，从而替换掉了LXC的实现。</p>
<blockquote>
<p>Docker官网上对于<a href="https://docs.docker.com/engine/faq/#what-open-source-license-are-you-using" target="_blank" rel="external">Docker在单纯的LXC之上做了哪些事情</a>的解释：</p>
<ul>
<li>Portable deployment across machines(跨主机可移植性部署)</li>
<li>Application-centric(以应用为中心)</li>
<li>Automatic build(自动构建)</li>
<li>Versioning(版本)</li>
<li>Component re-use(组件重用)</li>
<li>Sharing(共享)</li>
<li>Tool ecosystem(工具生态系统)</li>
</ul>
</blockquote>
<h3 id="四、Docker是什么？"><a href="#四、Docker是什么？" class="headerlink" title="四、Docker是什么？"></a>四、Docker是什么？</h3><p>　　Docker是一个开源的引擎，可以轻松的为任何应用创建一个<strong>轻量级的、可移植的、自给自足的</strong>容器。</p>
<p>　　Docker可以让你将所有应用软件以及它的依赖打包成软件开发的标准化单元。</p>
<p>　　Docker容器将软件以及它运行安装所需的一切文件（代码、运行时、系统工具、系统库）打包到一起，这就保证了不管是在什么样的运行环境，总是能以相同的方式运行。就好像 Java 虚拟机一样，“一次编写，到处运行（Write once, run anywhere）”，而 Docker 是“一次构建，到处运行（Build once，run anywhere）”。</p>
<h3 id="五、Docker与Microservices的关系"><a href="#五、Docker与Microservices的关系" class="headerlink" title="五、Docker与Microservices的关系"></a>五、Docker与Microservices的关系</h3><p>　　Microservices（微服务）依赖于“基础设施自动化”，而Docker正是“基础设施自动化”的利器。可以说Docker的火爆，一定程度上也带动了微服务架构的兴起，而微服务的广泛应用也促进了Docker 繁荣，可以说两者相辅相成。</p>
<h3 id="六、为什么使用Docker？"><a href="#六、为什么使用Docker？" class="headerlink" title="六、为什么使用Docker？"></a>六、为什么使用Docker？</h3><h4 id="1-Why-Docker"><a href="#1-Why-Docker" class="headerlink" title="1. Why Docker?"></a>1. Why Docker?</h4><p>　　按照当前官网<a href="https://docs.docker.com/engine/#why-docker" target="_blank" rel="external">Why Docker?</a>的解释，主要有四个方面：</p>
<h5 id="1-1更快速的交付应用（Faster-delivery-of-your-applications）"><a href="#1-1更快速的交付应用（Faster-delivery-of-your-applications）" class="headerlink" title="1.1更快速的交付应用（Faster delivery of your applications）"></a>1.1更快速的交付应用（Faster delivery of your applications）</h5><ul>
<li>借助于Docker容器，程序开发员，系统管理员甚至QA和版本控制工程师都可以进行协同工作。Docker创建了一套标准的容器数据格式，在这套标准数据格式基础上，当系统管理员管理操作容器时，程序开发员不需要关心容器的变化，这样就可以更专心的关注自己的应用代码。而这种管理和开发的任务隔离，大大的简化了开发和部署的成本。</li>
<li>Docker容器的创建非常容易，这样应用程序就可以进行快速迭代开发，从而缩短产品的上市周期。</li>
<li>Docker的容器属于轻量级的容器，因此启动和停止都特别快。容器启动只需要毫秒级的时间，因此在进行开发、测试和部署各个环境之间切换时几乎感受不到时间的流失。</li>
</ul>
<h5 id="1-2-更轻松的部署和扩展（Deploy-and-scale-more-easily）"><a href="#1-2-更轻松的部署和扩展（Deploy-and-scale-more-easily）" class="headerlink" title="1.2 更轻松的部署和扩展（Deploy and scale more easily）"></a>1.2 更轻松的部署和扩展（Deploy and scale more easily）</h5><ul>
<li>Docker容器几乎可以在任何地方执行，至少在理论层面是可以再任意地方执行。Dokcer可以在桌面操作系统，物理服务器，虚拟机，数据中心或者共有/私有云上面执行。</li>
<li>因为Docker容器可以在各种环境下运行，因此容器之间的迁移也非常方便。你可以非常方便的将容器从测试环境迁移到云环境中。</li>
</ul>
<h5 id="1-3-更多的工作负载（Get-higher-density-and-run-more-workloads）"><a href="#1-3-更多的工作负载（Get-higher-density-and-run-more-workloads）" class="headerlink" title="1.3 更多的工作负载（Get higher density and run more workloads）"></a>1.3 更多的工作负载（Get higher density and run more workloads）</h5><ul>
<li>Docker的容器本身不需要额外创建虚拟机管理系统，因此你可以启动多套Docker容器，这样就可以充分发挥主机服务器的物理资源，也可以降低因为采购服务器licenses而带来的额外成本。</li>
</ul>
<h5 id="1-4-更简单的管理（Faster-deployment-makes-for-easier-management）"><a href="#1-4-更简单的管理（Faster-deployment-makes-for-easier-management）" class="headerlink" title="1.4 更简单的管理（Faster deployment makes for easier management）"></a>1.4 更简单的管理（Faster deployment makes for easier management）</h5><ul>
<li>Docker快速部署和轻量级的特性，可以使应用快速迭代。同时所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</li>
</ul>
<h4 id="2-Docker的使用场景"><a href="#2-Docker的使用场景" class="headerlink" title="2. Docker的使用场景"></a>2. Docker的使用场景</h4><ul>
<li>简化配置</li>
<li>代码流水线（Code Pipeline）管理</li>
<li>提高开发效率</li>
<li>隔离应用</li>
<li>整合服务器</li>
<li>调适能力</li>
<li>多租户环境</li>
<li>快速部署</li>
</ul>
<h3 id="七、Docker的组件"><a href="#七、Docker的组件" class="headerlink" title="七、Docker的组件"></a>七、Docker的组件</h3><p>Docker主要包括两个大组件：</p>
<ul>
<li><p>The Docker Engine<br>　　Docker Engine是基于虚拟化技术的一个轻量级的并且功能非常强大的开源容器管理工具。它可以将不同的work flow组合起来，然后构建或者管理你的容器。</p>
</li>
<li><p>Docker Hub<br>　　一个分享和管理你所创建的image的SAAS（Software-as-a-Service）平台。</p>
</li>
</ul>
<h3 id="八、Docker的架构"><a href="#八、Docker的架构" class="headerlink" title="八、Docker的架构"></a>八、Docker的架构</h3><p>　　Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。</p>
<img src="/imgs/docker-architecture.svg" width="500" height="400">
<p>　　Docker的核心组件：</p>
<ul>
<li>Docker 客户端 - Client</li>
<li>Docker 服务器 - Docker daemon</li>
<li>Docker 镜像 - Image</li>
<li>Docker 容器 - Container</li>
<li>Registry</li>
</ul>
<h4 id="1-Docker-客户端"><a href="#1-Docker-客户端" class="headerlink" title="1. Docker 客户端"></a>1. Docker 客户端</h4><p>　　最常用的 Docker 客户端是 docker 命令。通过 docker 我们可以方便地在 Host 上构建和运行容器。<br>　　除了 docker 命令行工具，用户也可以通过 REST API 与服务器通信。</p>
<h4 id="2-Docker-服务器"><a href="#2-Docker-服务器" class="headerlink" title="2. Docker 服务器"></a>2. Docker 服务器</h4><p>　　Docker daemon 是服务器组件，以 Linux 后台服务的方式运行，所谓“运行 docker”，指的就是运行 Docker daemon。<br>　　Docker daemon 运行在 Docker host 上，负责创建、运行、监控容器，构建、存储镜像。</p>
<h4 id="3-Docker镜像"><a href="#3-Docker镜像" class="headerlink" title="3.Docker镜像"></a>3.Docker镜像</h4><p>　　可将 Docker 镜像看着只读模板，通过它可以创建 Docker 容器。<br>镜像有多种生成方法：</p>
<ul>
<li>可以从无到有开始创建镜像</li>
<li>也可以下载并使用别人创建好的现成的镜像</li>
<li>还可以在现有镜像上创建新的镜像</li>
</ul>
<p>在<a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">下一篇 Docker的基本操作</a>里会有对镜像的详细介绍。</p>
<h4 id="4-Docker容器"><a href="#4-Docker容器" class="headerlink" title="4. Docker容器"></a>4. Docker容器</h4><p>　　Docker 容器就是 Docker 镜像的运行实例。用户可以通过 CLI（docker）或是 API 启动、停止、移动或删除容器。可以这么认为，对于应用软件，镜像是软件生命周期的构建和打包阶段，而容器则是启动和运行阶段。<br>　　总结起来，Docker容器就是：</p>
<ul>
<li>一个镜像格式</li>
<li>一系列标准的操作</li>
<li>一个执行环境</li>
</ul>
<h4 id="5-Registry"><a href="#5-Registry" class="headerlink" title="5.Registry"></a>5.Registry</h4><p>　　Docker用Registry保存用户构建的镜像。<br>Registry 分私有和公有两种：</p>
<ul>
<li><a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>是默认的 Registry，由 Docker公司维护，上面有数以万计的镜像，用户可以自由下载和使用。</li>
<li>出于对速度或安全的考虑，用户也可以创建自己的私有Registry</li>
</ul>
<h3 id="九、Docker核心技术"><a href="#九、Docker核心技术" class="headerlink" title="九、Docker核心技术"></a>九、Docker核心技术</h3><img src="/imgs/docker-core-tech.png" width="300" height="150">
<p>　　Docker核心是一个操作系统级虚拟化方法, 理解起来可能并不像VM那样直观。我们从虚拟化方法的四个方面：隔离性、可配额/可度量、便携性、安全性来详细介绍Docker的技术细节。</p>
<img src="/imgs/docker-core-engine.png" width="300" height="150">
<h4 id="1-隔离性-namespace资源隔离"><a href="#1-隔离性-namespace资源隔离" class="headerlink" title="1. 隔离性: namespace资源隔离"></a>1. 隔离性: namespace资源隔离</h4><ul>
<li>pid：每个容器都运行在自己的进程环境中；</li>
<li>user：在container内部用container内部的用户执行程序而非Host上的用户。</li>
<li>net：容器间的虚拟网络接口和IP地址都是分开的；</li>
<li>mnt：允许不同namespace的进程看到的文件结构不同；</li>
<li>uts：UNIX Time-sharing System,使其在网络上可以被视作一个独立的节点而非Host上的一个进程；</li>
<li>ipc：进程间交互；</li>
</ul>
<p>　　例如：在主机和docker容器里，都可以拥有自己的init进程（PID=1），init进程是所有其他进程的祖先进程，docker容器其实是主机里的一个进程。<br><img src="/imgs/docker-namespace-pid.png" width="300" height="150"></p>
<h4 id="2-可配额-可度量：cgroups资源限制"><a href="#2-可配额-可度量：cgroups资源限制" class="headerlink" title="2. 可配额/可度量：cgroups资源限制"></a>2. 可配额/可度量：cgroups资源限制</h4><p>　　cgroups是Linux内核提供的一种机制，用来限制、控制与分离一个进程组群的资源（如CPU、Memory、IO等）</p>
<p>主要提供了如下功能:</p>
<ul>
<li>资源限制：限制任务使用的资源总额，并在超过这个配额时发出提示</li>
<li>优先级分配：分配CPU时间片数量及磁盘IO带宽大小、控制任务运行的优先级</li>
<li>资源统计：统计系统资源使用量，如CPU使用时长、内存用量等</li>
<li>任务控制：对任务执行挂起、恢复等操作</li>
</ul>
<p>　　在实践中，系统管理员一般会利用cgroup做下面这些事（有点像为某个虚拟机分配资源似的）：</p>
<ul>
<li>隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。</li>
<li>为这组进程分配其足够使用的内存</li>
<li>为这组进程分配相应的网络带宽和磁盘存储限制</li>
<li>限制访问某些设备（通过设置设备的白名单)</li>
</ul>
<h4 id="3-便携性-文件系统"><a href="#3-便携性-文件系统" class="headerlink" title="3. 便携性: 文件系统"></a>3. 便携性: 文件系统</h4><p>　　最初docker仅能在支持Aufs文件系统的Linux发行版上运行，但是由于Aufs未能加入linux内核，为了寻求兼容性、扩展性，Docker在内部通过graphdriver机制这种可扩展的方式来实现对不同文件系统的支持。目前，Docker支持Aufs，Devicemapper，Btrfs和Vfs四种文件系统。</p>
<p>　　典型的Linux文件系统由bootfs和rootfs两部分组成，bootfs(boot file system)主要包含 bootloader和kernel，bootloader主要是引导加载kernel，当kernel被加载到内存中后 bootfs就被umount了。 rootfs (root file system) 包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件。<br><img src="/imgs/docker-aufs1.png" width="300" height="150"></p>
<p>　　对于不同的linux发行版，bootfs基本是一致的，但rootfs会有差别，因此不同的发行版可以公用bootfs:<br><img src="/imgs/docker-aufs2.png" width="300" height="150"></p>
<h4 id="4-安全性-AppArmor-SELinux-GRSEC"><a href="#4-安全性-AppArmor-SELinux-GRSEC" class="headerlink" title="4. 安全性: AppArmor, SELinux, GRSEC"></a>4. 安全性: AppArmor, SELinux, GRSEC</h4><p>　　安全永远是相对的，这里有三个方面可以考虑Docker的安全特性:</p>
<ul>
<li>由kernel namespaces和cgroups实现的Linux系统固有的安全标准;</li>
<li>Docker Deamon的安全接口;</li>
<li>Linux本身的安全加固解决方案,类如AppArmor, SELinux;</li>
</ul>
<h3 id="十、内核机制的练习"><a href="#十、内核机制的练习" class="headerlink" title="十、内核机制的练习"></a>十、内核机制的练习</h3><h4 id="【练习1】命名空间的练习"><a href="#【练习1】命名空间的练习" class="headerlink" title="【练习1】命名空间的练习"></a>【练习1】命名空间的练习</h4><pre><code># 创建一个Docker容器
$ docker run -it --rm busybox
# 列出所有的namespace
$ ls -l /proc/$$/ns
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 mnt -&gt; mnt:[4026531840]
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 net -&gt; net:[4026531957]
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 pid -&gt; pid:[4026531836]
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 user -&gt; user:[4026531837]
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 uts -&gt; uts:[4026531838]
# 查看 pid namespace:
$ ps aux
# 查看 mnt namespace:
$ cat /proc/mounts
# 查看 uts namespace
$ hostname
# 查看 ipc namespace
$ ipcs
</code></pre><p>退出容器，按<code>ctrl + d</code></p>
<h4 id="【练习2】cgroup的练习"><a href="#【练习2】cgroup的练习" class="headerlink" title="【练习2】cgroup的练习"></a>【练习2】cgroup的练习</h4><pre><code># 列出所有的subsystem
$ ls /sys/fs/cgroup/ -l
dr-xr-xr-x 4 root root  0 Jul 11 12:47 blkio
drwxr-xr-x 2 root root 60 Jul 11 12:47 cgmanager
dr-xr-xr-x 4 root root  0 Jul 11 12:47 cpu
dr-xr-xr-x 4 root root  0 Jul 11 12:47 cpuacct
dr-xr-xr-x 4 root root  0 Jul 11 12:47 cpuset
dr-xr-xr-x 4 root root  0 Jul 11 12:47 devices
dr-xr-xr-x 4 root root  0 Jul 11 12:47 freezer
dr-xr-xr-x 4 root root  0 Jul 11 12:47 hugetlb
dr-xr-xr-x 4 root root  0 Jul 11 12:47 memory
dr-xr-xr-x 4 root root  0 Jul 11 12:47 net_cls
dr-xr-xr-x 4 root root  0 Jul 11 12:47 net_prio
dr-xr-xr-x 4 root root  0 Jul 11 12:47 perf_event
dr-xr-xr-x 3 root root  0 Jul 11 12:47 systemd
</code></pre><p>　　默认情况下，Docker 启动一个容器后，会在<code>/sys/fs/cgroup</code>目录下的各个资源目录下生成以容器ID为名字的目录（group）:</p>
<pre><code>$ ls /sys/fs/cgroup/cpu/docker/654bd6413abb005ccb2e93e096151650e022132b7186171fd871cc8d5692e356
cgroup.clone_children  cpu.cfs_period_us  cpu.shares  notify_on_release
cgroup.procs           cpu.cfs_quota_us   cpu.stat    tasks
$ cat /sys/fs/cgroup/cpu/docker/654bd6413abb005ccb2e93e096151650e022132b7186171fd871cc8d5692e356/cpu.cfs_quota_us
-1
</code></pre><p>　　此时 cpu.cfs_quota_us 的内容为-1，表示默认情况下并没有限制容器的CPU使用。在容器被 stopped 后，该目录被删除。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>　　本篇文章主要是涉及docker的基础理论知识，讲述了docker的出现，docker与LXC以及Microservice的关系，同时从what, why上理解了docker，最后涉及了cgroup和namespaces两个Linux内核机制。</p>
<p>　　<a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">下一篇</a>将讲述Docker的基本操作。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="https://docs.docker.com/engine/faq/#what-does-docker-technology-add-to-just-plain-lxc" target="_blank" rel="external">what-does-docker-technology-add-to-just-plain-lxc</a></li>
<li><a href="https://waylau.com/ahout-docker/" target="_blank" rel="external">简述Docker</a></li>
<li><a href="https://www.qcloud.com/community/article/597293" target="_blank" rel="external">什么是Docker</a></li>
<li><a href="http://dockone.io/article/126" target="_blank" rel="external">八个Docker的真实应用场景</a></li>
<li><a href="https://www.toptal.com/linux/separation-anxiety-isolating-your-system-with-linux-namespaces" target="_blank" rel="external">Namespace isolation</a></li>
<li><a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="external">Docker背后的内核知识——cgroups资源限制</a></li>
<li><a href="http://blog.opskumu.com/docker.html#16-资源配额cgroups" target="_blank" rel="external">Docker资源配额</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/07/09/Docker-workshop-1-容器简介/" itemprop="url">
                Docker Workshop（一）容器简介
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2017-07-09T18:25:04+08:00" content="2017-07-09">
            2017-07-09
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Docker/" itemprop="url" rel="index">
                  <span itemprop="name">Docker</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2017/07/09/Docker-workshop-1-容器简介/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2017/07/09/Docker-workshop-1-容器简介/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>　　“不想在自己电脑上装一堆东西，恩，弄个docker容器，随便安装，随便破坏，随便试验的玩吧！”，这是笔者了解docker的初衷。<br>　　后来回到武汉弄起了《Docker in Production》的workshop，正好项目也用到了docker，这才有股动力push我系统的了解一下docker。</p>
<h3 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h3><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><strong>容器简介</strong></li>
<li><a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">Docker简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">Docker的基本操作</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">Docker数据存储</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">Docker网络</a></li>
<li>Docker安全</li>
<li>多主机部署</li>
<li>服务发现</li>
<li>日志、跟踪、监控</li>
</ul>
<p>　　本篇主要讲述容器相关的知识，比较容器和虚拟机，练习LXC容器的相关指令，最后引出Docker。</p>
<h3 id="三、容器的定义"><a href="#三、容器的定义" class="headerlink" title="三、容器的定义"></a>三、容器的定义</h3><p>　　容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。开发人员在自己笔记本上创建并测试好的容器，无需任何修改就能够在生产系统的虚拟机、物理服务器或公有云主机上运行。</p>
<img src="/imgs/container-structure.png" width="400" height="250">
<p>　　容器是轻量级的操作系统级虚拟化，可以让我们在一个资源隔离的进程中运行应用及其依赖项。运行应用程序所必需的组件都将打包成一个镜像并可以复用。执行镜像时，它运行在一个隔离环境中，并且不会共享宿主机的内存、CPU 以及磁盘，这就保证了容器内进程不能监控容器外的任何进程。</p>
<h3 id="四、容器解决的问题"><a href="#四、容器解决的问题" class="headerlink" title="四、容器解决的问题"></a>四、容器解决的问题</h3><p>　　为什么需要容器？容器到底解决的是什么问题？<br>　　一句话回答是：容器使软件具备了超强的可移植能力。</p>
<h4 id="1-从运输行业的集装箱说起"><a href="#1-从运输行业的集装箱说起" class="headerlink" title="1. 从运输行业的集装箱说起"></a>1. 从运输行业的集装箱说起</h4><p>　　20世纪60年代以前，运输行业几乎所有的货物都是以<em>散件</em>方式运输。</p>
<p>　　每一次运输，一方面货主与承运方会担心因货物类型的不同而导致损失，如几个铁桶压在了一堆香蕉上。另外一方面，运输过程中需要使用不同的交通工具严重浪费了大量的时间和精力，如货物先搬上车，到了码头由码头工人卸货，然后装上船，到岸之后卸下船，再装上火车，到达目的地，最后卸货……中间可能还有更多种类的交通工具，涉及到更多次的装、卸货、转移过程。</p>
<img src="/imgs/container-in-transportation1.png" width="400" height="250">
<p>　　幸运的是，集装箱的发现解决了这个难题。</p>
<img src="/imgs/container-in-transportation2.png" width="400" height="250">
<p>　　无论货物的体积、形状差异有多大，最终都被装载进集装箱里。由于要实现标准尺寸集装箱的运输，堆场、码头、起吊、船舶、汽车乃至公路桥梁、隧道等，都必须适应它在全球范围内的应用而逐渐加以标准化，形成影响国际贸易的全球物流系统。由此带来的是系统效率大幅度提升，运输费大幅度下降，地球上任何一个地方生产的产品都可以快速而低廉地运送到有需求的地方。</p>
<table>
<thead>
<tr>
<th>比较</th>
<th style="text-align:right">散货运输</th>
<th style="text-align:center">集装箱运输</th>
</tr>
</thead>
<tbody>
<tr>
<td>货物装卸时间</td>
<td style="text-align:right">几天到一个星期，分拣、合并、装卸过程繁琐</td>
<td style="text-align:center">几个小时</td>
</tr>
<tr>
<td>货物装卸时间占整个运输过程的比例</td>
<td style="text-align:right">&gt;50%</td>
<td style="text-align:center">&lt;10%</td>
</tr>
<tr>
<td>所需劳动力</td>
<td style="text-align:right">大量的码头工人</td>
<td style="text-align:center">少数的码头工人和起重机操作员</td>
</tr>
<tr>
<td>自动化程度</td>
<td style="text-align:right">低</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td>安全性</td>
<td style="text-align:right">低，装卸时常有物品损毁和盗窃</td>
<td style="text-align:center">高，货物被隔离在封闭的集装箱内</td>
</tr>
<tr>
<td>成本</td>
<td style="text-align:right">货物越多，成本越高，耗时越长</td>
<td style="text-align:center">前期固定成本投入较高，随着集装箱规模、运货量的增加，分摊到运送每个集装箱的成本极低，总成本几乎不变</td>
</tr>
</tbody>
</table>
<h4 id="2-应用程序中的容器"><a href="#2-应用程序中的容器" class="headerlink" title="2. 应用程序中的容器"></a>2. 应用程序中的容器</h4><p>　　同样，我们看看今天的软件开发面临的挑战。</p>
<p>　　以前几乎所有的应用都采用三层架构（Presentation/Appliation/Data），系统部署到有限的几台物理服务器上。如今，开发人员通常使用多种服务（如MQ、cache、DB）构建和组装应用，此外应用很可能部署到不同的环境（如虚拟服务器、私有云和公有云）。一方面应用包含多种服务，这些服务有自己所依赖的库和软件包；另一方面存在多种部署环境，服务在运行时可能需要动态迁移到不同的环境中。如何让每种服务能够在所有的部署环境中顺利运行？<br>　　“服务”和“应用环境”对应到前面运输行业的“货物类型”和“运输工具”，容器则对应“集装箱”。<br><img src="/imgs/container-in-application.png" width="400" height="250"></p>
<h3 id="五、为什么容器技术如此诱人？"><a href="#五、为什么容器技术如此诱人？" class="headerlink" title="五、为什么容器技术如此诱人？"></a>五、为什么容器技术如此诱人？</h3><h4 id="1-封装、隔离"><a href="#1-封装、隔离" class="headerlink" title="1. 封装、隔离"></a>1. 封装、隔离</h4><p>　　各个容器之间，资源独立、隔离，不同的应用以container为单位进行部署，环境互不影响。</p>
<h4 id="2-轻量、可移植"><a href="#2-轻量、可移植" class="headerlink" title="2. 轻量、可移植"></a>2. 轻量、可移植</h4><p>　　相比于传统的虚拟化技术，容器在cpu、memory、network IO上的性能损耗都有同样水平甚至更优，容器的创建、启动、销毁都很快。</p>
<h4 id="3-标准化、run-on-any-hardware"><a href="#3-标准化、run-on-any-hardware" class="headerlink" title="3. 标准化、run on any hardware"></a>3. 标准化、run on any hardware</h4><p>　　开发人员只需为按照一定的标准为应用创建一次运行环境，然后打包成容器便可在其他机器上运行。</p>
<h4 id="4-一致性、可重复性"><a href="#4-一致性、可重复性" class="headerlink" title="4. 一致性、可重复性"></a>4. 一致性、可重复性</h4><p>　　标准化的容器消除了开发、测试、生产环境的不一致性。</p>
<h3 id="六、容器与虚拟机"><a href="#六、容器与虚拟机" class="headerlink" title="六、容器与虚拟机"></a>六、容器与虚拟机</h3><p>　　谈到容器，就不得不将它与虚拟机进行对比，因为两者都是为应用提供封装和隔离。<br>　　一句话解释区别：容器能做的事少得多并且使用起来相当廉价。而虚拟机提供整个虚拟化硬件层，可以做更多的事情但是使用成本显著。</p>
<img src="/imgs/container-vs-vms.png" width="400" height="250">
<p>主要区别如下：</p>
<ol>
<li>容器实例与主机共享操作系统内核，通过内核提供的运行时隔离能力为服务提供独立的用户域、文件系统、网络以及进程运行空间。<br>虚拟机的每个实例自带操作系统，因而是一种硬件级的虚拟化隔离。</li>
<li>容器通常是专用于运行特定服务的，它的镜像通常只包含运行该服务所需的上下文内容，许多广泛使用的镜像都只有几十MB，甚至几MB大小。<br>虚拟机则需要提供包括内核在内的通用进程运行环境，它的镜像偏向于大而完整的全功能集合，即使一个最小的精简镜像的体积也有几百MB。</li>
<li>容器的使用方式倾向于开箱即用，镜像提供的是一个『不可变的基础设施环境』。<br>虚拟机则倾向于让用户根据所用的系统，自定义初始化操作，使用Ansible、Puppet这样的配置工具来进行基础设施的管理</li>
<li>容器在启动速度和运行性能上更有优势，虚拟机在安全性上更有优势。</li>
</ol>
<h3 id="七、容器的分类"><a href="#七、容器的分类" class="headerlink" title="七、容器的分类"></a>七、容器的分类</h3><h4 id="1-操作系统容器"><a href="#1-操作系统容器" class="headerlink" title="1. 操作系统容器"></a>1. 操作系统容器</h4><p>　　操作系统层虚拟化是一种计算机虚拟化技术，这种技术将操作系统内核虚拟化，可以允许多个独立用户空间的存在，而不是只有一个。这些实例有时会被称为容器、虚拟引擎、虚拟专用服务器或是 jails（FreeBSD jail 或者 chroot jail）。从运行在容器中的程序角度来看，这些实例就如同真正的计算机。</p>
<p>　　容器技术如 LXC，OpenVZ，Linux VServer，BSD Jails 和 Solaris 区域就是操作系统容器。</p>
<h4 id="2-应用容器"><a href="#2-应用容器" class="headerlink" title="2. 应用容器"></a>2. 应用容器</h4><p>　　应用程序虚拟化是从其所执行的底层操作系统封装计算机程序的软件技术。一个完全虚拟化的应用，尽管仍像原来一样执行，但是并不会进行传统意义上的安装。应用在运行时的行为就像它直接与原始操作系统以及操作系统所管理的所有资源进行交互一样，但可以实现不同程度的隔离或者沙盒化。</p>
<p>　　容器技术如 Docker 和 Rocket 就是应用程序容器的示例。</p>
<h3 id="八、LXC的练习"><a href="#八、LXC的练习" class="headerlink" title="八、LXC的练习"></a>八、LXC的练习</h3><p>　　LXC是Linux containers的简称，是一种基于容器的操作系统层级的虚拟化技术。</p>
<p>　　LXC 与虚拟机的不同之处在于，它是一个操作系统级别的虚拟化环境，而不是硬件虚拟化环境。他们都做同样的事情，但 LXC 是操作系统级别的虚拟化环境，虚拟环境有它自己的进程和网络空间，而不是创建一个完整成熟的虚拟机。因此，一个 LXC 虚拟操作系统具有最小的资源需求，并启动只需几秒钟。</p>
<h4 id="【练习1】创建LXC容器"><a href="#【练习1】创建LXC容器" class="headerlink" title="【练习1】创建LXC容器"></a>【练习1】创建LXC容器</h4><ol>
<li>Ubuntu系统上安装好lxc</li>
<li><p>宿主机上操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 列出所有的容器:</span></div><div class="line">sudo lxc-ls --fancy</div><div class="line"><span class="meta">#</span><span class="bash"> 启动一个后台运行的容器demo-container:</span></div><div class="line">sudo lxc-start --name demo-container --daemon</div><div class="line"><span class="meta">#</span><span class="bash"> 查看运行的容器的相关信息:</span></div><div class="line">sudo lxc-info --name demo-container</div><div class="line"><span class="meta">#</span><span class="bash"> 进入到容器:</span></div><div class="line">sudo lxc-console -n demo-container</div><div class="line"><span class="meta">#</span><span class="bash"> 登陆时候输入:</span></div><div class="line">Username: ubuntu</div><div class="line">Password: ubuntu</div></pre></td></tr></table></figure>
</li>
<li><p>LXC容器中操作</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># 查看容器的hostname</span></div><div class="line">hostname</div><div class="line"><span class="meta"># 在容器中创建一个文件</span></div><div class="line">echo <span class="string">"hello"</span> &gt; my_text.txt</div><div class="line">cat my_text.txt</div></pre></td></tr></table></figure>
</li>
<li><p>退出容器<br>先按下<code>ctrl+a</code>，然后再按<code>q</code>。</p>
</li>
</ol>
<h4 id="【练习2】克隆LXC容器"><a href="#【练习2】克隆LXC容器" class="headerlink" title="【练习2】克隆LXC容器"></a>【练习2】克隆LXC容器</h4><ol>
<li><p>宿主机上操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 冻结运行的容器</span></div><div class="line">sudo lxc-freeze -n demo-container</div><div class="line"><span class="meta">#</span><span class="bash"> 列出所有的容器:</span></div><div class="line">sudo lxc-ls --fancy</div><div class="line"><span class="meta">#</span><span class="bash"> 克隆容器之前，必须要先停止容器</span></div><div class="line">sudo lxc-stop --name demo-container</div><div class="line">sudo lxc-clone -o demo-container -n cloned-container</div><div class="line"><span class="meta">#</span><span class="bash"> 列出所有的容器:</span></div><div class="line">sudo lxc-ls --fancy</div><div class="line"><span class="meta">#</span><span class="bash"> 启动复制的容器</span></div><div class="line">sudo lxc-start --name cloned-container --daemon</div><div class="line"><span class="meta">#</span><span class="bash"> 进入到复制的容器:</span></div><div class="line">sudo lxc-console -n cloned-container</div><div class="line"><span class="meta">#</span><span class="bash"> 登陆时候输入:</span></div><div class="line">Username: ubuntu</div><div class="line">Password: ubuntu</div></pre></td></tr></table></figure>
</li>
<li><p>克隆的容器中操作</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看克隆的容器是否也一起克隆了之前创建的文件</span></div><div class="line"><span class="keyword">ls</span></div></pre></td></tr></table></figure>
</li>
<li><p>退出容器<br>先按下<code>ctrl+a</code>，然后再按<code>q</code>。</p>
</li>
<li><p>停止克隆的容器</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo lxc-<span class="keyword">stop</span> --<span class="keyword">name</span> cloned-container</div></pre></td></tr></table></figure>
</li>
<li><p>销毁克隆的容器</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo lxc-destroy <span class="comment">--name cloned-container</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>　　本篇文章主要是涉及容器，从what, why, how上讲述了容器的相关知识。<br>至于容器的历史，有兴趣的读者可以自己查看一下相关资料。<br><a href="http://www.dockone.io/article/1522" target="_blank" rel="external">容器简史：从20世纪70年代的chroot到2016的Docker</a>以及<a href="http://www.alauda.cn/2016/01/18/container-history/" target="_blank" rel="external">【容器那些事儿】容器技术的前世今生</a><br>　　下一篇将讲述Docker的出现以及相关的基本理论知识。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="http://dockone.io/article/803" target="_blank" rel="external">为什么容器技术将主宰世界？</a></li>
<li><a href="http://dockone.io/article/2442" target="_blank" rel="external">容器技术概览</a></li>
<li><a href="https://www.ibm.com/developerworks/community/blogs/132cfa78-44b0-4376-85d0-d3096cd30d3f/entry/%E5%AE%B9%E5%99%A8_What_Why_How_%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF_6?lang=zh" target="_blank" rel="external">容器What, Why, How - 每天5分钟玩转容器技术 - IBM</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-lxc-containers/" target="_blank" rel="external">LXC：Linux 容器工具</a></li>
<li><a href="http://17173ops.com/2013/11/14/linux-lxc-install-guide.shtml#toc2" target="_blank" rel="external">LXC基础学习教程</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/01/14/基于RabbitMQ topic的消息发送与接收/" itemprop="url">
                基于RabbitMQ topic的消息发送与接收
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2017-01-14T16:19:46+08:00" content="2017-01-14">
            2017-01-14
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Message/" itemprop="url" rel="index">
                  <span itemprop="name">Message</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2017/01/14/基于RabbitMQ topic的消息发送与接收/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/14/基于RabbitMQ topic的消息发送与接收/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><h4 id="1-项目结构："><a href="#1-项目结构：" class="headerlink" title="1.项目结构："></a>1.项目结构：</h4><img src="/imgs/rabbit-1.png" width="400" height="250">
<p>A是消息的生产者，B、C则是消息的consumer。A会通过queue（不关心其产品类型）发送消息给B、C。</p>
<h4 id="2-需求"><a href="#2-需求" class="headerlink" title="2.需求"></a>2.需求</h4><p>近期项目上，新增的D应用程序需要监听原有A应用程序的消息。按照以往的做法，我需要做如下两件事：</p>
<ul>
<li>向某个团队，给每该D应用的每个region（dev、intg、sys、prod等），申请新的queue A.D。（这中间可能需要两个星期时间）</li>
<li>改变应用A的代码，让其每次发消息时候还需要再给D发消息。</li>
<li>给应用A准备一次deploymen plan，并做相应的回归测试。</li>
<li>改变应用D的代码，让其从新建的queue里面接收处理消息。</li>
</ul>
<h4 id="3-痛点"><a href="#3-痛点" class="headerlink" title="3.痛点"></a>3.痛点</h4><p>这一做法，主要有两大痛点：</p>
<ul>
<li>每增加一个新应用，都需要申请queue</li>
<li>每增加一个新应用，都需要改动应用A的代码，还需要单独安排一次上线。生产者和消费者之间的耦合非常大。</li>
</ul>
<h4 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h4><p>因此，在兼容以前的基础上，我试图用下面的结构图解决上述痛点：<br><img src="/imgs/rabbit-2.png" width="400" height="250"><br>保持原有应用程序B和C的接收消息方式不变，新的应用程序开始改用topic的方法，这样可以兼容既有的应用程序，也可以将新应用程序的生产者和消费者解耦。但是还是存在一些问题：</p>
<ul>
<li>A的消息那么多，全部放在一个topic可能负载过大，那么应该采取分布式的方法？</li>
<li>如果消费者之一中途down了一段时间，该消息的等待时间又如何处理？是一直停留在topic中进行等待吗？</li>
</ul>
<p>最后，考虑到上述因素以及实际项目的其他因素，我将结构变成了如下：<br><img src="/imgs/rabbit-3.png" width="400" height="250"><br>虽然把最开始的痛点1又引入了，但是解耦的好处还是非常有意义的。</p>
<p>本文旨在spike上述想法，证明该想法的可能性。</p>
<h3 id="二、搭建外部环境"><a href="#二、搭建外部环境" class="headerlink" title="二、搭建外部环境"></a>二、搭建外部环境</h3><p>笔者采用vagrant + VirtualBox搭建一个含有rabbitmq server的虚拟机：<br>总体说来，所有的命令如下：</p>
<h4 id="1-创建虚拟机"><a href="#1-创建虚拟机" class="headerlink" title="1.创建虚拟机"></a>1.创建虚拟机</h4><pre><code>$ mkdir rabbit
$ cd rabbit
$ vagrant box list
$ vagrant init yungsang/coreos
</code></pre><p>然后注意取消注释<code>config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot;</code></p>
<h4 id="2-登陆到虚拟机"><a href="#2-登陆到虚拟机" class="headerlink" title="2.登陆到虚拟机"></a>2.登陆到虚拟机</h4><pre><code>vagrant ssh
</code></pre><h4 id="3-外部访问rabbitmq的管理页面"><a href="#3-外部访问rabbitmq的管理页面" class="headerlink" title="3.外部访问rabbitmq的管理页面"></a>3.外部访问rabbitmq的管理页面</h4><p>URL：<code>http://192.168.33.10:15672/#/</code><br>用户名：<code>guest</code><br>密码：<code>guest</code></p>
<h3 id="三、Spike"><a href="#三、Spike" class="headerlink" title="三、Spike"></a>三、Spike</h3><p>在编写本文时候，笔者顺便了解了一下Rabbit MQ的相关基础模式与用法，可以参见上一篇文章<a href="http://zhangyuyu.github.io/2017/01/14/RabbitMQ%E5%88%9D%E6%8E%A2/" target="_blank" rel="external">RabbitMQ初探</a></p>
<p>再回过头来看这个spike，发现其实本文要实现的就是<a href="http://zhangyuyu.github.io/2017/01/14/RabbitMQ%E5%88%9D%E6%8E%A2/" target="_blank" rel="external">RabbitMQ初探</a>中的Topic Exchange模式。</p>
<p>其实说起来，就是JMS和AMQP的一个较大的区别：</p>
<ul>
<li>JMS有队列(Queues)和主题(Topics)两种形式，发送到JMS队列的消息最多只能被一个Client消费，发送到JMS主题的消息可能会被多个Clients消费；</li>
<li>AMQP只有队列(Queues)，队列的消息只能被单个接受者消费，发送者并不直接把消息发送到队列中，而是发送到Exchange中，该Exchage会与一个或多个队列绑定，能够实现与JMS队列和主题同样的功能。</li>
</ul>
<h3 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h3><p>本文只是针对其中的一点，进行了可行性的spike，但是实际应用中往往还涉及到很多复杂因素，比如技术上消息的事务处理和消息负载，另外还有项目进度、人员安排以及后续维护等问题。笔者不再过多阐述，谨以此文的小demo探究一些不一样的架构。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/01/14/RabbitMQ初探/" itemprop="url">
                RabbitMQ初探
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2017-01-14T10:19:46+08:00" content="2017-01-14">
            2017-01-14
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Message/" itemprop="url" rel="index">
                  <span itemprop="name">Message</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2017/01/14/RabbitMQ初探/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/14/RabbitMQ初探/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>在准备<code>基于RabbitMQ topic的消息发送与接收</code>的时候，顺便开始了这篇RabbitMQ初探。<br>安装过程这里就不再赘述，本博客主要记录一些初探过程。</p>
<h3 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h3><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。<br>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。<br>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<h3 id="三、几种模式"><a href="#三、几种模式" class="headerlink" title="三、几种模式"></a>三、几种模式</h3><p>Rabbit MQ<a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="external">官网教程</a>上，从六个方面给出了讲解和demo。但是这些demo都是从最基础的层面进行编写，所以我自己尝试时候用了spring boot的相关支持，简化了很多代码。同时在尝试之后，我大概将其分为三类：</p>
<ul>
<li>Hello World(Queue)</li>
<li>Publish/Subscribe(Exchange)</li>
<li>RPC</li>
</ul>
<p>下面分别回顾一下上述三类情况：</p>
<h4 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1.Hello World"></a>1.Hello World</h4><p>我把官网上的<a href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html" target="_blank" rel="external">Hello World</a>和<a href="https://www.rabbitmq.com/tutorials/tutorial-two-java.html" target="_blank" rel="external">Work Queues</a>归到这一类。结构如下：</p>
<img src="/imgs/rabbitmq-hello-world.png" width="400" height="250">
<p align="center">Hello World</p>

<img src="/imgs/rabbitmq-work-queues.png" width="400" height="250">
<p align="center">Work Queues</p>

<p>它们都属于直接把消息发送给一个queue，然后consumers会与queue相连接。<br>相关代码可参考：<a href="https://github.com/zhangyuyu/learnrabbitmq/commits/master" target="_blank" rel="external">https://github.com/zhangyuyu/learnrabbitmq/commits/master</a> 的第一次、第二次提交。</p>
<h4 id="2-Publish-Subscribe-Exchange"><a href="#2-Publish-Subscribe-Exchange" class="headerlink" title="2.Publish/Subscribe(Exchange)"></a>2.Publish/Subscribe(Exchange)</h4><p>这种模式使用了Exchange，可以把它理解为消息交换机，它指定消息按什么规则，路由到哪个队列。<br>因此我把官网上的<a href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html" target="_blank" rel="external">Publish/Subscribe</a>、<a href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html" target="_blank" rel="external">Routing</a>、<a href="https://www.rabbitmq.com/tutorials/tutorial-five-java.html" target="_blank" rel="external">Topics</a>放到这一类中。</p>
<img src="/imgs/rabbitmq-exchanges.png" width="400" height="250">
<p>根据Exchange的类型，可以分为四类：</p>
<ul>
<li>Fanout</li>
<li>Direct</li>
<li>Topic</li>
<li>Headers</li>
</ul>
<h5 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h5><p>该类型路由规则非常简单，会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，相当于广播功能<br>相关代码可参考：<a href="https://github.com/zhangyuyu/learnrabbitmq/commits/master" target="_blank" rel="external">https://github.com/zhangyuyu/learnrabbitmq/commits/master</a> 的Rabbitmq Fanout Exchange。</p>
<h5 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h5><p>该类型路由规则，会把消息路由到那些binding key与routing key完全匹配的Queue中。<br>相关代码可参考：<a href="https://github.com/zhangyuyu/learnrabbitmq/commits/master" target="_blank" rel="external">https://github.com/zhangyuyu/learnrabbitmq/commits/master</a> 的Rabbitmq Direct Exchange。</p>
<h5 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h5><p>该类型路由规则与上述Direct Exchange规则类似，只是在binding key与routing key的匹配规则上进行了扩展，它约定：</p>
<ul>
<li>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“routing.key.for.fist.queue”</li>
<li>binding key与routing key一样也是句点号“. ”分隔的字符串</li>
<li>binding key中可以存在两种特殊字符“*”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）。</li>
</ul>
<p>相关代码可参考：<a href="https://github.com/zhangyuyu/learnrabbitmq/commits/master" target="_blank" rel="external">https://github.com/zhangyuyu/learnrabbitmq/commits/master</a> 的Rabbitmq Topic Exchange。</p>
<h5 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h5><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。<br>相关代码可参考：<a href="https://github.com/zhangyuyu/learnrabbitmq/commits/master" target="_blank" rel="external">https://github.com/zhangyuyu/learnrabbitmq/commits/master</a> 的Rabbitmq Headers Exchange。</p>
<h4 id="3-RPC"><a href="#3-RPC" class="headerlink" title="3.RPC"></a>3.RPC</h4><p>MQ本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到RabbitMQ后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。<br>但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用），可直接参考<a href="https://www.rabbitmq.com/tutorials/tutorial-six-java.html" target="_blank" rel="external">官方教程</a>。</p>
<p>RabbitMQ中实现RPC的机制是：</p>
<ul>
<li>客户端发送请求（消息）时，在消息的属性（MessageProperties，在AMQP协议中定义了14中properties，这些属性会随着消息一起发送）中设置两个值replyTo（一个Queue名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue中）和correlationId（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败）</li>
<li>服务器端收到消息并处理</li>
<li>服务器端处理完消息之后，将生成一条应答消息到replyTo指定的Queue，同时带上correlationId属性。</li>
<li>客户端之前已订阅replyTo指定的Queue，从中收到服务器的应答消息后，根据其中的correlationId属性分析哪条请求被执行了，根据执行结果进行后续业务处理</li>
</ul>
<h3 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h3><h4 id="Dashboard："><a href="#Dashboard：" class="headerlink" title="Dashboard："></a>Dashboard：</h4><img src="/imgs/rabbitmq-terms.png" width="600" height="250">
<p>其中：</p>
<ul>
<li>Connection： 就是一个TCP的连接。Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。</li>
<li>Channels： 虚拟连接。它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</li>
</ul>
<h4 id="术语："><a href="#术语：" class="headerlink" title="术语："></a>术语：</h4><ul>
<li>Broker：简单来说就是消息队列服务器实体。</li>
<li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</li>
<li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li>
<li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li>
<li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。</li>
<li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li>
<li>producer：消息生产者，就是投递消息的程序。</li>
<li>consumer：消息消费者，就是接受消息的程序。</li>
<li>channel：消息通道，在客户端的每个连接里，可以建立多个channel，每个channel代表一个会话任务。</li>
</ul>
<h4 id="消息队列的使用过程大概如下："><a href="#消息队列的使用过程大概如下：" class="headerlink" title="消息队列的使用过程大概如下："></a>消息队列的使用过程大概如下：</h4><ul>
<li>客户端连接到消息队列服务器，打开一个channel。</li>
<li>客户端声明一个exchange，并设置相关属性。</li>
<li>客户端声明一个queue，并设置相关属性。</li>
<li>客户端使用routing key，在exchange和queue之间建立好绑定关系。</li>
<li>客户端投递消息到exchange。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/11/12/函数式编程初探2/" itemprop="url">
                函数式编程初探（二）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-11-12T19:35:10+08:00" content="2016-11-12">
            2016-11-12
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/函数式编程/" itemprop="url" rel="index">
                  <span itemprop="name">函数式编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/11/12/函数式编程初探2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/12/函数式编程初探2/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><a href="http://zhangyuyu.github.io/2016/11/12/函数式编程初探1" target="_blank" rel="external">上一篇</a>文章中介绍函数式编程的概念以及三个具有普遍意义的基本构造单元，本篇文章会接着讲述一些柯里化与部分施用、缓存、缓求值、函数式的数据结构。</p>
<h3 id="一、柯里化与部分施用"><a href="#一、柯里化与部分施用" class="headerlink" title="一、柯里化与部分施用"></a>一、柯里化与部分施用</h3><p>柯里化（currying）和函数的部分施用（partial application）都是从数学里借用过来的编程语言技法（基于20世纪haskell Curry等数学家的研究成果）。它们两者都有能力操纵函数的参数条目，一般是通过向一部分参数带入一个或多个默认值的办法来实现的。</p>
<p>柯里化指的是从一个多参数函数变成一连串单参数函数的变化。调用者可以决定对多少个参数实施变换，余下的部分将衍生为一个参数数目较少的新函数。如函数process(x,y,z)完全柯里化之后变成process(x)(y)(z)。<br>部分施用是指提前带入一部分参数值，使一个多参数函数得以省略部分参数，从而转化为一个参数数目较少的函数。如在函数process(x,y,z)上部分施用一个参数，那么我们将得到process(y,z)。</p>
<p>Groovy语言中部分施用与柯里化的对比：<br><figure class="highlight flix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">volume</span> </span>= &#123;h, w, l -&gt; h * w * l&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span> </span>= volume.curry(<span class="number">1</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthPA</span> </span>= volume.curry(<span class="number">1</span>, <span class="number">1</span>)         <span class="comment">// &lt;1&gt;</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthC</span> </span>= volume.curry(<span class="number">1</span>).curry(<span class="number">1</span>)    <span class="comment">// &lt;2&gt;</span></div><div class="line"></div><div class="line">println <span class="string">"The volume of the 2x3x4 rectangular solid is $&#123;volume(2, 3, 4)&#125;"</span></div><div class="line">println <span class="string">"The area of the 3x4 rectangle is $&#123;area(3, 4)&#125;"</span></div><div class="line">println <span class="string">"The length of the 6 line is $&#123;lengthPA(6)&#125;"</span></div></pre></td></tr></table></figure></p>
<p>代码可参见《函数式编程思想》的<a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/groovy/currying.groovy" target="_blank" rel="external">github</a><br>柯里化常见的应用场景：函数工厂、模板方法模式、隐藏参数。</p>
<h3 id="二、缓存"><a href="#二、缓存" class="headerlink" title="二、缓存"></a>二、缓存</h3><p>缓存是很常见的一种需求（同时也是制造隐晦错误的源头）。缓存有两种实现方式：一种是手工进行状态管理，另一种是采用记忆机制。</p>
<h4 id="手工进行状态管理"><a href="#手工进行状态管理" class="headerlink" title="手工进行状态管理"></a>手工进行状态管理</h4><p>在代码里面增加一个filed，每次计算之前之前先去检查是否存在于缓存中。但是当我们将缓存的取值范围增大时，可能报出OutOfMemoryError的错误。</p>
<p>缓存可以提高性能，但是缓存有代价：它提高了代码的非本质复杂性和维护负担。同时，编写缓存的代码还要兼顾执行的环境（比如缓存范围）。<br>代码示例参考下文<a href="#完美数的手工缓存实现">完美数的手工缓存实现</a></p>
<h4 id="记忆机制"><a href="#记忆机制" class="headerlink" title="记忆机制"></a>记忆机制</h4><p>Groovy语言记忆函数的办法是，先将要记忆的函数定义成闭包，然后对该闭包执行memoize()方法来获得一个新函数，以后我们调用这个新函数的时候，其结果就会被缓存起来。<br>请保证所有被记忆的函数：</p>
<ul>
<li>没有副作用</li>
<li>不依赖任何外部信息<br>代码示例参考下文<a href="#完美数的记忆实现">完美数的记忆实现</a></li>
</ul>
<h3 id="三、缓求值"><a href="#三、缓求值" class="headerlink" title="三、缓求值"></a>三、缓求值</h3><p>缓求值指尽可能地推迟求解表达式。缓求值的集合不会预先算好所有的元素，而是在用到的时才落实下来。这样做有几个好处：</p>
<ul>
<li>昂贵的运算只有到了绝对必要的时候才执行</li>
<li>我们可以建立无限大的集合，只要一直接到请求，就一直送出元素</li>
<li>按缓求值的方式来使用映射、筛选等函数式概念，可以产生更高效的代码。</li>
</ul>
<p>例如：<code>print length([2+1, 3*2, 1/0, 5-4])</code><br>对于严格求值的编程语言，执行（甚至编译）时，会发生<code>被零除</code>的异常；<br>对于非严格（也叫缓求值）的里，则会得出<code>4</code>的结果。</p>
<p>缓求值在Groovy中的应用：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def prepend(val, closure) &#123; new LazyList(val, closure) &#125;</div><div class="line">def integers(n) &#123; prepend(n, &#123; integers(n + <span class="number">1</span>) &#125;) &#125;</div><div class="line"></div><div class="line">@Test</div><div class="line">public void lazy_list_acts_like_a_list() &#123;</div><div class="line">    def naturalNumbers = integers(<span class="number">1</span>)</div><div class="line">    assertEquals('<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>', naturalNumbers.getHead(<span class="number">10</span>).join(' '))</div><div class="line">    def evenNumbers = naturalNumbers.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</div><div class="line">    assertEquals('<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span> <span class="number">20</span>', evenNumbers.getHead(<span class="number">10</span>).join(' '))</div></pre></td></tr></table></figure></p>
<h3 id="四、函数式的数据结构"><a href="#四、函数式的数据结构" class="headerlink" title="四、函数式的数据结构"></a>四、函数式的数据结构</h3><p>函数式语言里经常遇到返回两种截然不同的值的需求，它们用来建模这种行为的常用数据结构是Either。<br>使用Either表示两种结果的返回值，使用Option来表示有为空返回值的类型。Option类可近似看作为Either的子类。</p>
<p>用Java的泛型来自己实现Either类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Either</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> A left = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> B right = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Either</span><span class="params">(A a,B b)</span> </span>&#123;</div><div class="line">        left = a;</div><div class="line">        right = b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A,B&gt; <span class="function">Either&lt;A,B&gt; <span class="title">left</span><span class="params">(A a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;A,B&gt;(a,<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">left</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeft</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> right != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">right</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A,B&gt; <span class="function">Either&lt;A,B&gt; <span class="title">right</span><span class="params">(B b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;A,B&gt;(<span class="keyword">null</span>,b);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fold</span><span class="params">(F&lt;A&gt; leftOption, F&lt;B&gt; rightOption)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)</div><div class="line">            leftOption.f(left);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            rightOption.f(right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码可参见《函数式编程思想》的<a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/errorhandling/Either.java" target="_blank" rel="external">github</a><br>使用：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Either&lt;Exception, Integer&gt; parseNumberDefaults(final <span class="keyword">String</span> s) &#123;</div><div class="line">    <span class="keyword">if</span> (不满足)</div><div class="line">        <span class="keyword">return</span> Either.left(<span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">"Invalid Number"</span>));</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        int number = <span class="keyword">new</span> <span class="type">RomanNumeral</span>(s).toInt();</div><div class="line">        <span class="keyword">return</span> Either.right(<span class="keyword">new</span> <span class="type">RomanNumeral</span>(number &gt;= MAX ? MAX : <span class="type">number</span>).toInt());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="五、完美数的示例"><a href="#五、完美数的示例" class="headerlink" title="五、完美数的示例"></a>五、完美数的示例</h3><p>案例：</p>
<blockquote>
<p>自然数分类规则：<br>完美数： 真约数之和 = 数本身<br>过剩数： 真约数之和 &gt; 数本身<br>不足数： 真约数之和 &lt; 数本身<br>真约数和：除了数本身之外，其余正约数的和。</p>
</blockquote>
<p>代码比较长，可以直接查看《函数式编程思想》的<a href="https://github.com/oreillymedia/functional_thinking/" target="_blank" rel="external">github</a>总结如下：<br>1.完美数的命令式解法<br><a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier/ImpNumberClassifierSimple.java" target="_blank" rel="external">https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier/ImpNumberClassifierSimple.java</a><br>2.稍向函数式靠拢的完美数分类实现<br><a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier/NumberClassifier.java" target="_blank" rel="external">https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier/NumberClassifier.java</a><br>3.完美数分类的Java8实现<br><a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier8/NumberClassifier.java" target="_blank" rel="external">https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier8/NumberClassifier.java</a><br><span id="完美数的手工缓存实现">4.完美数的手工缓存实现</span><br><a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/groovy/memoization/ClassifierCached.groovy" target="_blank" rel="external">https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/groovy/memoization/ClassifierCached.groovy</a><br><span id="完美数的记忆实现">5.完美数的记忆实现</span><br><a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/groovy/memoization/ClassifierMemoized.groovy" target="_blank" rel="external">https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/groovy/memoization/ClassifierMemoized.groovy</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/11/12/函数式编程初探1/" itemprop="url">
                函数式编程初探（一）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-11-12T17:35:13+08:00" content="2016-11-12">
            2016-11-12
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/函数式编程/" itemprop="url" rel="index">
                  <span itemprop="name">函数式编程</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/11/12/函数式编程初探1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/12/函数式编程初探1/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>作为一名从业以来一直在编写Java的程序媛，虽然项目里经常用java8的lambda，可是在引入<a href="http://zhangyuyu.github.io/2016/11/01/RxJava/" target="_blank" rel="external">RxJava</a>之后，函数作为参数传递更加普遍，故阅读《函数式编程思维》一书，以求了解函数式编程。</p>
<h3 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h3><p><code>函数式编程</code>(Functional Programming)是一种<code>编程范式</code>（programming paradigm），也就是如何编写程序的方法论。<br>主要思想是把运算过程尽量写成一系列嵌套的函数调用。</p>
<h3 id="三、背景"><a href="#三、背景" class="headerlink" title="三、背景"></a>三、背景</h3><p>函数式编程（Functional Programming）其实相对于计算机的历史而言是一个非常古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于 λ 演算，而 λ 演算并非设计于在计算机上执行，它是由 Alonzo Church 和 Stephen Cole Kleene 在 20 世纪三十年代引入的一套用于研究函数定义、函数应用和递归的形式系统。</p>
<h3 id="四、为什么？"><a href="#四、为什么？" class="headerlink" title="四、为什么？"></a>四、为什么？</h3><p>在《函数式编程思维》这本书中，多处指出<code>函数式编程思维</code>的好处之一,是能够将低层次细节的控制权移交给运行时,从而消弭了一大批注定会发生的程序错误。这使得程序员得以在更高的抽象层次上工作，同时运行时也有了执行复杂优化的自由空间。</p>
<p>在阮一峰的<a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="external">《函数式编程初探》</a>一文中，<br>函数式编程的五大特点如下：</p>
<ol>
<li>函数是”第一等公民”</li>
<li>只用”表达式”，不用”语句”</li>
<li>没有”副作用”</li>
<li>不修改状态</li>
<li>引用透明<br>函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</li>
</ol>
<p>函数式编程的好处如下：</p>
<ol>
<li>代码简洁，开发快速</li>
<li>接近自然语言，易于理解</li>
<li>更方便的代码管理(每一个函数都可以被看做独立单元，很有利于进行单元测试以及模块化组合)</li>
<li>易于”并发编程”</li>
<li>代码的热升级（函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的）</li>
</ol>
<h3 id="五、转变思维"><a href="#五、转变思维" class="headerlink" title="五、转变思维"></a>五、转变思维</h3><p>先大致说明一下函数式编程与命令式编程的区别吧！</p>
<p>命令式编程：按照“程序是一系列改变状态的命令”来建模的一种编程风格。<br>函数式编程将程序描述为表达式和变换，以数学方程的形式建立模型，并且尽量避免可变的状态。</p>
<p>《Working with Lagacy Code》的作者Michael Feathers的用以下一句话说明了函数式抽象和面向对象抽象的关键区别：</p>
<blockquote>
<p>面向对象编程通过封装不确定因素来使代码能被人理解；函数式编程通过尽量减少不确定因素来使代码能被人理解。——Michael Feathers</p>
</blockquote>
<p>在面向对象的命令式编程语言里面，重用的单元是类和类之间沟通用的消息。所以OOP的世界提倡开发人员针对具体问题<strong>建立专门的数据结构</strong>，相关的专门操作以“方法”的形式附加在数据结构上。<br>函数式编程语言重用的思路很不一样，它提倡在<strong>有限的几种关键数据结构</strong>（如list、set、map）上运用针对这些数据结构高度优化过的操作，以此构成基本运转结构。</p>
<h3 id="六、基本概念及使用介绍"><a href="#六、基本概念及使用介绍" class="headerlink" title="六、基本概念及使用介绍"></a>六、基本概念及使用介绍</h3><h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>程序员往往都是讨厌看文档而偏爱看代码的，上述那么多文字，你不一定看的下去，还是首先来一个hello world吧。<br>对于计算表达式（1+2）* 3，</p>
<p>传统的编程方式是：<br>int a = 1 + 2<br>int b = a * 3</p>
<p>而对于函数式编程方式是：<br>int result = multiply(add(1,2), 3)<br>这里函数作为参数进行传递。</p>
<h4 id="函数式编程的常见函数"><a href="#函数式编程的常见函数" class="headerlink" title="函数式编程的常见函数"></a>函数式编程的常见函数</h4><p>从一个例子说起，假设我们有一个名字列表，其中一些条目由单个字符构成。现在的任务是：</p>
<ul>
<li>除去单字符条目</li>
<li>放在一个逗号分隔的字符串中进行返回</li>
<li>每个名字的首字母都是大写<br>代码可参考《函数式编程思维》的<a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/trans/TheCompanyProcess.java" target="_blank" rel="external">github</a><br>传统的java实现<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">String</span> cleanNames(List&lt;<span class="keyword">String</span>&gt; listOfNames) &#123;</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; listOfNames.<span class="built_in">size</span>(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (listOfNames.<span class="built_in">get</span>(i).length() &gt; <span class="number">1</span>) &#123;</div><div class="line">            result.<span class="built_in">append</span>(capitalizeString(listOfNames.<span class="built_in">get</span>(i))).<span class="built_in">append</span>(<span class="string">","</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result.substring(<span class="number">0</span>, result.length() - <span class="number">1</span>).toString();</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">String</span> capitalizeString(<span class="keyword">String</span> s) &#123;</div><div class="line">    <span class="keyword">return</span> s.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + s.substring(<span class="number">1</span>, s.length());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>命令式编程鼓励程序员将操作安排在循环内部执行，本例中的三个操作filter、transform、convert都必须依赖于相同的低层次机制。</p>
<p>Java8的实现：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="built_in">String</span> cleanNames(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; names) &#123;</div><div class="line">    <span class="keyword">if</span> (names == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    <span class="keyword">return</span> names</div><div class="line">            .stream()</div><div class="line">            .filter(name -&gt; name.length() &gt; <span class="number">1</span>)</div><div class="line">            .<span class="built_in">map</span>(name -&gt; capitalize(name))</div><div class="line">            .collect(Collectors.joining(<span class="string">","</span>));</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="built_in">String</span> capitalize(<span class="built_in">String</span> e) &#123;</div><div class="line">    <span class="keyword">return</span> e.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + e.substring(<span class="number">1</span>, e.length());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>两者的对比，可以发现后者这种更高层次的抽象思考有一些好处：</p>
<ul>
<li>促使我们换一种角度去归类问题，看到问题的共性。</li>
<li>让运行时有更大的余地去做只能的优化（有时候调整作业的先后顺序会更有效率）。</li>
<li>让埋头实现细节的开发者看到原本视野之外的解决方案（比如，如果改用多线程，传统的方式可能需要自己手动穿插一些线程相关的代码）</li>
</ul>
<p>可以从上述例子中，看到三个函数filter、map、fold/reduce的影子。</p>
<ol>
<li><p>filter——筛选<br>根据用户定义的条件来筛选列表中的条目，并由此产生一个较小的新列表。</p>
</li>
<li><p>map——映射<br>对原集合的每一个元素执行给定的函数，从而变换成一个新的集合。</p>
</li>
<li><p>fold/reduce——折叠/化约<br>用一个累积量来“收集”集合元素。</p>
</li>
</ol>
<p>总而言之，函数式编程以参数传递和函数的复合作为主要的表现手段，我们不需要掌握太多作为“不确定因素”存在的其他语言构造之间的交互规则。</p>
<p>本篇只讲述了函数式编程的概念、背景和三个具有普遍意义的基本构造单元，<a href="http://zhangyuyu.github.io/2016/11/12/函数式编程初探2" target="_blank" rel="external">下一篇</a>我会讲述一些柯里化与部分施用、缓存、缓求值、 函数式的数据结构。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/11/01/RxJava/" itemprop="url">
                RxJava
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-11-01T22:19:46+08:00" content="2016-11-01">
            2016-11-01
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/RxJava/" itemprop="url" rel="index">
                  <span itemprop="name">RxJava</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/11/01/RxJava/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/01/RxJava/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>最近，项目（Java编写的Spring boot API）引入了RXJava，使用了它的异步性操作以及它的一些流式写法。<br>使用过程中，有过疑惑，有过释然，有过吐槽，有过赞赏。学习应该是一个追根溯源的过程，而不是随便了解一下大致的用法就不了了之，故以此记之。</p>
<h3 id="二、响应式编程"><a href="#二、响应式编程" class="headerlink" title="二、响应式编程"></a>二、响应式编程</h3><p>响应式编程是一种面向数据流和变化传播的编程范式，数据更新是相关联的。<br>在交互式编程中，A = B + C这样的表达式意味着将B与C之和赋给A，而此后B与C的改变都与A无关。<br>而在响应式编程中，A会去“响应”B或C的变化，即一旦B或C改变之后，A的值也会随之变化。</p>
<h3 id="三、定义"><a href="#三、定义" class="headerlink" title="三、定义"></a>三、定义</h3><p>我的理解是，RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。（其实初学者把握两点就好了：观察者模式和异步）</p>
<h3 id="四、背景"><a href="#四、背景" class="headerlink" title="四、背景"></a>四、背景</h3><p>Rx的全称是Reactive Extensions。直译过来就是响应式扩展。<br>Rx基于观察者模式，是一种编程模型。其目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。<br>Rx最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源。<br>Rx的大部分语言库由ReactiveX这个组织负责维护，比较流行的有RxJava/RxJS/Rx.NET，社区网站是 reactivex.io。<br>RxJava是 ReactiveX 在JVM上的一个实现。</p>
<h3 id="五、为什么"><a href="#五、为什么" class="headerlink" title="五、为什么?"></a>五、为什么?</h3><ul>
<li>函数式风格</li>
<li>简化代码</li>
<li>异步错误处理</li>
<li>轻松使用并发</li>
</ul>
<h3 id="六、基本概念及使用介绍"><a href="#六、基本概念及使用介绍" class="headerlink" title="六、基本概念及使用介绍"></a>六、基本概念及使用介绍</h3><h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>说了很多，其实对RxJava是什么，其实还不是很明确，我们先来一个Hello world。</p>
<pre><code>Observable
    .create(new OnSubscribe&lt;String&gt;() {
        @Override
        public void call(Subscriber&lt;? super String&gt; subscriber) {
            subscriber.onNext(&quot;Hello World&quot;);
        }
    })
    .subscribe(new Subscriber&lt;String&gt;() {
        @Override
        public void onNext(String s) {
            System.out.println(s);
        }
    });
</code></pre><p>简化下来就是：</p>
<pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(&quot;Hello World!&quot;);
}).subscribe(System.out::println);
</code></pre><p>执行的过程就是创建、监听、订阅。</p>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul>
<li>Observable：被观察者</li>
<li>Observer: 观察者</li>
<li>Subscriber：观察者，implements Observer。 </li>
<li>OnSubscribe：一个接口类，是连接被观察者和观察者的桥梁，另外要说明的是onSubscribe是Observable的一个局部变量。</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="第1步：创建观察者Observer"><a href="#第1步：创建观察者Observer" class="headerlink" title="第1步：创建观察者Observer"></a>第1步：创建观察者Observer</h5><pre><code>Observer&lt;Object&gt; observer = new Observer&lt;Object&gt;() {

    @Override
    public void onCompleted() {

    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onNext(Object s) {

    }
};
</code></pre><h5 id="第2步：创建被观察者Observable"><a href="#第2步：创建被观察者Observable" class="headerlink" title="第2步：创建被观察者Observable"></a>第2步：创建被观察者Observable</h5><p>Observable.create()方法可以创建一个Observable，<br>使用create()创建Observable需要一个OnSubscribe对象，这个对象继承Action1。<br>当观察者订阅我们的Observable时，它作为一个参数传入并执行call()函数。</p>
<pre><code>Observable&lt;Object&gt; observable = Observable.create(new Observable.OnSubscribe&lt;Object&gt;() {         
    @Override
    public void call(Subscriber&lt;? super Object&gt; subscriber) {

    }
});
</code></pre><p>除了create()，just()和from()同样可以创建Observable。看看下面两个例子：</p>
<p>just(T…)将传入的参数依次发送</p>
<pre><code>Observable observable = Observable.just(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;);
//上面这行代码会依次调用
//onNext(&quot;One&quot;);
//onNext(&quot;Two&quot;);
//onNext(&quot;Three&quot;);
//onCompleted();
</code></pre><p>from(T[])/from(Iterable&lt;? extends T&gt;)将传入的数组或者Iterable拆分成Java对象依次发送</p>
<pre><code>String[] parameters = {&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;};
Observable observable = Observable.from(parameters);
//上面这行代码会依次调用
//onNext(&quot;One&quot;);
//onNext(&quot;Two&quot;);
//onNext(&quot;Three&quot;);
//onCompleted();
</code></pre><h5 id="第3步：被观察者Observable订阅观察者Observer"><a href="#第3步：被观察者Observable订阅观察者Observer" class="headerlink" title="第3步：被观察者Observable订阅观察者Observer"></a>第3步：被观察者Observable订阅观察者Observer</h5><p>你没看错，不同于普通的观察者模式，这里是被观察者订阅观察者：</p>
<pre><code>observable.subscribe(observer);
</code></pre><p>连起来就是：</p>
<pre><code>Observable.create(new OnSubscribe&lt;String&gt;() {
        @Override
        public void call(Subscriber&lt;? super String&gt; subscriber) {
            subscriber.onNext(&quot;Hello World!&quot;);
            subscriber.onCompleted();
        }

    }).subscribe(new Subscriber&lt;String&gt;() {

        @Override
        public void onCompleted() {
            System.out.println(&quot;Done&quot;);
        }

        @Override
        public void onError(Throwable e) {
            e.printStackTrace();
        }

        @Override
        public void onNext(String t) {
            System.out.println(t);
        }

    });
</code></pre><p>这里表面是被观察者订阅观察者，是为了更好的链式结构。<br>实际上，过程如下：</p>
<ul>
<li>创建一个被观察者，并传入一个OnSubcribe。</li>
<li>创建一个观察者Subscriber。</li>
<li>一旦发生subscribe时，会自动触发上述的OnSubcribe的call方法。</li>
<li>而OnSubcribe的call方法中的参数subscriber就是第二步中的被观察者Subscriber。</li>
<li>然后就调用上述代码中的<code>subscriber.onNext(&quot;Hello World!&quot;);</code></li>
<li>也就是真实上述代码中<code>Override</code>的<code>onNext()</code>方法了。<br>所以本质上来讲，还是被观察者执行订阅操作的。</li>
</ul>
<h3 id="七、操作符"><a href="#七、操作符" class="headerlink" title="七、操作符"></a>七、操作符</h3><p>有了对上一步调用的理解，再去看源代码中操作符的实质，就很简单了。</p>
<p>RxJava的操作符分为如下几类：</p>
<ul>
<li>转换类操作符<br>map、flatMap、concatMap等等</li>
<li>过滤类操作符<br>filter、find等等</li>
<li>组合类操作符<br>concat、merge、zip等等</li>
<li>数学类操作符<br>count、max等等</li>
<li>布尔类操作符<br>includes、some等等</li>
</ul>
<p>对于这些操作符的调用分析，读者可以自己查看源代码。<br>对于操作符的用法，可以参考<a href="https://github.com/zhangyuyu/learnrxjava" target="_blank" rel="external">Github TDD 练习</a>。<br>对于操作符形象化的理解，可以参考一个交互式的动画网站<a href="http://rxmarbles.com/" target="_blank" rel="external">http://rxmarbles.com/</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/imgs/figure.jpg" alt="Zhang Yu" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Zhang Yu</p>
        </div>
        <p class="site-description motion-element" itemprop="description">行是知之始，知是行之成</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Yu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhangyuyu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
<a href="https://github.com/zhangyuyu"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-
</body>
</html>
