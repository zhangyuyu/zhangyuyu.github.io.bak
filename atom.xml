<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>若见喻笺</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-27T07:12:09.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhang Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mongo-记一次安装启动异常</title>
    <link href="http://yoursite.com/2017/12/27/Mongo-%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2017/12/27/Mongo-记一次安装启动错误/</id>
    <published>2017-12-27T03:35:21.000Z</published>
    <updated>2017-12-27T07:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>　　笔者最近换了电脑，从MacBook Pro 13”换成了MacBook Pro 15”，相关的工具软件全部得重新装。<br>再重新装Mongo的时候遇到了一些问题，特此记录。</p>
<h2 id="二、安装异常"><a href="#二、安装异常" class="headerlink" title="二、安装异常"></a>二、安装异常</h2><h3 id="1-错误描述"><a href="#1-错误描述" class="headerlink" title="1. 错误描述"></a>1. 错误描述</h3><a id="more"></a>
<p>　　用<code>brew install mongodb</code>安装了最新的mongodb(3.6)之后，启动本地的java spring boot应用，报错如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">com.mongodb.MongoCommandException</span>: Command failed with error 9: 'The 'cursor' option is required, except for aggregate with the explain argument' on server localhost:27017. The full response is &#123; "ok" : 0.0, "errmsg" : "The 'cursor' option is required, except for aggregate with the explain argument", "code" : 9, "codeName" : "FailedToParse" &#125;</div><div class="line"></div><div class="line"><span class="stylus">        at com<span class="selector-class">.mongodb</span><span class="selector-class">.CommandResult</span><span class="selector-class">.getException</span>(CommandResult<span class="selector-class">.java</span>:<span class="number">80</span>)</span></div><div class="line"></div><div class="line">        at com<span class="selector-class">.mongodb</span><span class="selector-class">.CommandResult</span><span class="selector-class">.throwOnError</span>(CommandResult<span class="selector-class">.java</span>:<span class="number">94</span>)</div><div class="line"></div><div class="line">        at org<span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.mongodb</span><span class="selector-class">.core</span><span class="selector-class">.MongoTemplate</span><span class="selector-class">.handleCommandError</span>(MongoTemplate<span class="selector-class">.java</span>:<span class="number">2097</span>)</div><div class="line"></div><div class="line">        ... <span class="number">119</span> common frames omitted</div></pre></td></tr></table></figure>
<h3 id="2-错误原因"><a href="#2-错误原因" class="headerlink" title="2. 错误原因"></a>2. 错误原因</h3><p>　　MongoDB 3.6的Document，对于aggregation cursor的描述如下:</p>
<blockquote>
<pre><code>Specify a document that contains options that control the creation of the cursor object.

Changed in version 3.6: MongoDB 3.6 removes the use of aggregate command without the cursor
option unless the command includes the explain option. Unless you include the explain option,
you must specify the cursor option.

To indicate a cursor with the default batch size, specify cursor: {}.

To indicate a cursor with a non-default batch size, use cursor: { batchSize: &lt;num&gt; }.
</code></pre></blockquote>
<p>　　MongoDB在3.6里面改变了aggregation指令的工作方式，现在aggregation需要cursor了。</p>
<h3 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3. 解决办法"></a>3. 解决办法</h3><p>　　对本地的mongodb降级。</p>
<h4 id="1）先用brew-search查看支持的mongo版本"><a href="#1）先用brew-search查看支持的mongo版本" class="headerlink" title="1）先用brew search查看支持的mongo版本"></a>1）先用brew search查看支持的mongo版本</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ brew search mongo</div><div class="line">=<span class="ruby">=&gt; Searching local taps...</span></div><div class="line">mongodb@3.4 ✔                          mongo-cxx-driver                       mongodb                                mongodb@3.2                            percona-server-mongodb</div><div class="line">mongo-c-driver                         mongo-orchestration                    mongodb@3.0                            mongoose</div><div class="line">=<span class="ruby">=&gt; Searching taps on GitHub...</span></div><div class="line">caskroom/cask/mongo-management-studio  homebrew/php/php53-mongo               homebrew/php/php54-mongo               homebrew/php/php55-mongo               homebrew/php/php56-mongo</div><div class="line">=<span class="ruby">=&gt; Searching blacklisted, migrated and deleted formulae...</span></div></pre></td></tr></table></figure>
<h4 id="2）再brew安装mongodb-3-4"><a href="#2）再brew安装mongodb-3-4" class="headerlink" title="2）再brew安装mongodb 3.4"></a>2）再brew安装mongodb 3.4</h4><p><code>brew install mongodb@3.4</code></p>
<h2 id="三、启动异常"><a href="#三、启动异常" class="headerlink" title="三、启动异常"></a>三、启动异常</h2><h3 id="1-错误描述-1"><a href="#1-错误描述-1" class="headerlink" title="1. 错误描述"></a>1. 错误描述</h3><p>　　安装完成mongodb3.4之后，mongo服务启动异常。</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ mongo</div><div class="line">MongoDB shell version v3.<span class="number">4.10</span></div><div class="line">connecting <span class="keyword">to</span>: mongodb://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">27017</span></div><div class="line"><span class="number">2017</span>-<span class="number">12</span>-<span class="number">27</span>T11:<span class="number">13</span>:<span class="number">37.713</span>+<span class="number">0800</span> W NETWORK  [thread1] Failed <span class="keyword">to</span> connect <span class="keyword">to</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">27017</span>, <span class="keyword">in</span>(checking socket <span class="keyword">for</span> <span class="literal">error</span> <span class="keyword">after</span> poll), reason: Connection refused</div><div class="line"><span class="number">2017</span>-<span class="number">12</span>-<span class="number">27</span>T11:<span class="number">13</span>:<span class="number">37.715</span>+<span class="number">0800</span> E QUERY    [thread1] <span class="literal">Error</span>: couldn<span class="symbol">'t</span> connect <span class="keyword">to</span> server <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">27017</span>, connection attempt failed :</div><div class="line">connect@src/mongo/shell/mongo.js:<span class="number">237</span>:<span class="number">13</span></div><div class="line">@(connect):<span class="number">1</span>:<span class="number">6</span></div><div class="line">exception: connect failed</div></pre></td></tr></table></figure>
<h3 id="2-错误原因-1"><a href="#2-错误原因-1" class="headerlink" title="2. 错误原因"></a>2. 错误原因</h3><p>　　mongodb的服务没有启动。</p>
<h3 id="3-解决办法-1"><a href="#3-解决办法-1" class="headerlink" title="3. 解决办法"></a>3. 解决办法</h3><h4 id="探索过程："><a href="#探索过程：" class="headerlink" title="探索过程："></a>探索过程：</h4><h5 id="1）用brew-services启动mongo不work"><a href="#1）用brew-services启动mongo不work" class="headerlink" title="1）用brew services启动mongo不work"></a>1）用brew services启动mongo不work</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ brew services start mongodb@3.4</div><div class="line">==&gt; Successfully started `mongodb@3.4` (label: homebrew.mxcl.mongodb@3.4)</div><div class="line">$ brew services list</div><div class="line">Name        Status <span class="built_in"> User </span>   Plist</div><div class="line">mongodb@3.4 started yuzhang /Users/yuzhang/Library/LaunchAgents/homebrew.mxcl.mongodb@3.4.plist</div></pre></td></tr></table></figure>
<p>　　上述操作之后，似乎mongo已经启动了，但是问题依旧复现，可能是brew services不再有人维护的原因（<a href="https://github.com/Homebrew/legacy-homebrew/issues/32006" target="_blank" rel="external">brew services is unsupported and will be removed soon</a>）。</p>
<h5 id="2）用mongod启动mongo报错"><a href="#2）用mongod启动mongo报错" class="headerlink" title="2）用mongod启动mongo报错"></a>2）用mongod启动mongo报错</h5><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ mongod</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.980<span class="string">+0800</span> I CONTROL  [initandlisten] MongoDB starting : pid=8655 port=27017 dbpath=/data/db 64-bit host=CNyuzhang<span class="string">-2</span>.local</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I CONTROL  [initandlisten] db version v3.4.10</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I CONTROL  [initandlisten] git version: 078f28920cb24de0dd479b5ea6c66c644f6326e9</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I CONTROL  [initandlisten] OpenSSL version: OpenSSL 1.0.2n  7 Dec 2017</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I CONTROL  [initandlisten] allocator: system</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I CONTROL  [initandlisten] modules: none</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I CONTROL  [initandlisten] build environment:</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I CONTROL  [initandlisten]     distarch: x86_64</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I CONTROL  [initandlisten]     target_arch: x86_64</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I CONTROL  [initandlisten] options: &#123;&#125;</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I STORAGE  [initandlisten] exception in initAndListen: 29 Data directory /data/db not found., terminating</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I NETWORK  [initandlisten] shutdown: going to close listening sockets...</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I NETWORK  [initandlisten] shutdown: going to flush diaglog...</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I CONTROL  [initandlisten] now exiting</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:11:28.981<span class="string">+0800</span> I CONTROL  [initandlisten] shutting down with code:100</div></pre></td></tr></table></figure>
<p>　　上述错误信息里，明确指出<code>/data/db not found</code>，因此是在启动的时候没有找到db的地址。为了确认是这个问题，尝试使用如下指令：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">mongo -nodb</span></div></pre></td></tr></table></figure>
<p>　　然后，发现可以直接进入mongo了。</p>
<h5 id="3）创建-data-db"><a href="#3）创建-data-db" class="headerlink" title="3）创建/data/db"></a>3）创建/data/db</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$mkdir</span> -<span class="selector-tag">p</span> /data/db</div></pre></td></tr></table></figure>
<p>　　再次启动mongodb:</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.679<span class="string">+0800</span> I CONTROL  [initandlisten] MongoDB starting : pid=8510 port=27017 dbpath=/data/db 64-bit host=CNyuzhang<span class="string">-2</span>.local</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.680<span class="string">+0800</span> I CONTROL  [initandlisten] db version v3.4.10</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.680<span class="string">+0800</span> I CONTROL  [initandlisten] git version: 078f28920cb24de0dd479b5ea6c66c644f6326e9</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.680<span class="string">+0800</span> I CONTROL  [initandlisten] OpenSSL version: OpenSSL 1.0.2n  7 Dec 2017</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.680<span class="string">+0800</span> I CONTROL  [initandlisten] allocator: system</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.680<span class="string">+0800</span> I CONTROL  [initandlisten] modules: none</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.680<span class="string">+0800</span> I CONTROL  [initandlisten] build environment:</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.680<span class="string">+0800</span> I CONTROL  [initandlisten]     distarch: x86_64</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.680<span class="string">+0800</span> I CONTROL  [initandlisten]     target_arch: x86_64</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.680<span class="string">+0800</span> I CONTROL  [initandlisten] options: &#123;&#125;</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.681<span class="string">+0800</span> I STORAGE  [initandlisten] exception in initAndListen: 20 Attempted to create a lock file on a read-only directory: /data/db, terminating</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.681<span class="string">+0800</span> I NETWORK  [initandlisten] shutdown: going to close listening sockets...</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.681<span class="string">+0800</span> I NETWORK  [initandlisten] shutdown: going to flush diaglog...</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.681<span class="string">+0800</span> I CONTROL  [initandlisten] now exiting</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:02.681<span class="string">+0800</span> I CONTROL  [initandlisten] shutting down with code:100</div></pre></td></tr></table></figure>
<p>　　可以看出是对<code>/data/db</code>没有权限。</p>
<h5 id="4）用sudo执行mongod"><a href="#4）用sudo执行mongod" class="headerlink" title="4）用sudo执行mongod"></a>4）用sudo执行mongod</h5><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ sudo mongod</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.167<span class="string">+0800</span> I CONTROL  [initandlisten] MongoDB starting : pid=8521 port=27017 dbpath=/data/db 64-bit host=CNyuzhang<span class="string">-2</span>.local</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.167<span class="string">+0800</span> I CONTROL  [initandlisten] db version v3.4.10</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.167<span class="string">+0800</span> I CONTROL  [initandlisten] git version: 078f28920cb24de0dd479b5ea6c66c644f6326e9</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.167<span class="string">+0800</span> I CONTROL  [initandlisten] OpenSSL version: OpenSSL 1.0.2n  7 Dec 2017</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.167<span class="string">+0800</span> I CONTROL  [initandlisten] allocator: system</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.167<span class="string">+0800</span> I CONTROL  [initandlisten] modules: none</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.167<span class="string">+0800</span> I CONTROL  [initandlisten] build environment:</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.167<span class="string">+0800</span> I CONTROL  [initandlisten]     distarch: x86_64</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.167<span class="string">+0800</span> I CONTROL  [initandlisten]     target_arch: x86_64</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.167<span class="string">+0800</span> I CONTROL  [initandlisten] options: &#123;&#125;</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.170<span class="string">+0800</span> I -        [initandlisten] Detected data files in /data/db created by the 'wiredTiger' storage engine, so setting the active storage engine to 'wiredTiger'.</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.170<span class="string">+0800</span> I STORAGE  [initandlisten] wiredtiger_open config: create,cache_size=7680M,session_max=20000,eviction=(threads_min=4,threads_max=4),config_base=false,statistics=(fast),log=(enabled=true,archive=true,path=journal,compressor=snappy),file_manager=(close_idle_time=100000),checkpoint=(wait=60,log_size=2GB),statistics_log=(wait=0),</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.781<span class="string">+0800</span> I CONTROL  [initandlisten]</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.781<span class="string">+0800</span> I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.781<span class="string">+0800</span> I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.781<span class="string">+0800</span> I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.781<span class="string">+0800</span> I CONTROL  [initandlisten]</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.822<span class="string">+0800</span> I FTDC     [initandlisten] Initializing full-time diagnostic data capture with directory '/data/db/diagnostic.data'</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:08.823<span class="string">+0800</span> I NETWORK  [thread1] waiting for connections on port 27017</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:11.182<span class="string">+0800</span> I NETWORK  [thread1] connection accepted from 127.0.0.1:52959 #1 (1 connection now open)</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:11.182<span class="string">+0800</span> I NETWORK  [thread1] connection accepted from 127.0.0.1:52960 #2 (2 connections now open)</div><div class="line">2017<span class="string">-12</span><span class="string">-27</span>T11:10:11.182<span class="string">+0800</span> I NETWORK  [thread1] connection accepted from 127.0.0.1:52961 #3 (3 connections now open)</div></pre></td></tr></table></figure>
<h4 id="解决方法小结"><a href="#解决方法小结" class="headerlink" title="解决方法小结"></a>解决方法小结</h4><ol>
<li>创建<code>/data/db</code>，因为mongodb默认的db地址是<code>/data/db</code></li>
<li>用sudo执行mongod</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">mkdir</span> -p /<span class="class"><span class="keyword">data</span>/db</span></div><div class="line"><span class="title">sudo</span> mongod</div></pre></td></tr></table></figure>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ol>
<li>问题1是新版本3.6的mongodb做了一些改动造成的不兼容</li>
<li>问题2是brew services不再维护造成的启动异常</li>
</ol>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://stackoverflow.com/questions/29630399/mongo-connection-refused-osx" target="_blank" rel="external">Stackoverflow - Mongo connection refused osx</a></li>
<li><a href="https://stackoverflow.com/questions/23439343/cannot-connect-to-mongodb-errno61" target="_blank" rel="external">Stackoverflow - Cannot connect to MongoDB errno:61</a></li>
<li><a href="http://hcysun.me/2015/11/21/Mac下使用brew安装mongodb/" target="_blank" rel="external">Mac下使用brew安装mongodb</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;　　笔者最近换了电脑，从MacBook Pro 13”换成了MacBook Pro 15”，相关的工具软件全部得重新装。&lt;br&gt;再重新装Mongo的时候遇到了一些问题，特此记录。&lt;/p&gt;
&lt;h2 id=&quot;二、安装异常&quot;&gt;&lt;a href=&quot;#二、安装异常&quot; class=&quot;headerlink&quot; title=&quot;二、安装异常&quot;&gt;&lt;/a&gt;二、安装异常&lt;/h2&gt;&lt;h3 id=&quot;1-错误描述&quot;&gt;&lt;a href=&quot;#1-错误描述&quot; class=&quot;headerlink&quot; title=&quot;1. 错误描述&quot;&gt;&lt;/a&gt;1. 错误描述&lt;/h3&gt;
    
    </summary>
    
      <category term="Mongo" scheme="http://yoursite.com/categories/Mongo/"/>
    
    
      <category term="Mongo" scheme="http://yoursite.com/tags/Mongo/"/>
    
  </entry>
  
  <entry>
    <title>Docker Workshop（九）Docker日志、监控、Dashboard</title>
    <link href="http://yoursite.com/2017/12/04/Docker-Workshop-9-Docker%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7Dashboard/"/>
    <id>http://yoursite.com/2017/12/04/Docker-Workshop-9-Docker日志监控Dashboard/</id>
    <published>2017-12-04T06:12:36.000Z</published>
    <updated>2017-12-27T07:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>　　<a href="https://www.bagevent.com/event/828605" target="_blank" rel="external">《Docker in Production》 workshop</a>于2017年9月23在ThoughtWorks武汉举办，之后，有懒癌的笔者就“忘记“去接着更新这一系列了。<br>直到上次上线（OTR Diaochan Release）出现了一些问题，在寻找问题过程中，docker的日志、监控、Dashboard这一主题发挥了很重要的作用，才想起来该好好整理下这一篇文章。</p>
<h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">容器简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">Docker简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">Docker的基本操作</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">Docker数据存储</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">Docker网络</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/" target="_blank" rel="external">Docker安全</a></li>
<li>多主机部署</li>
<li>服务发现</li>
<li><strong>日志、监控、Dashboard</strong></li>
</ul>
<h2 id="三、日志"><a href="#三、日志" class="headerlink" title="三、日志"></a>三、日志</h2><a id="more"></a>
<h3 id="1-传统日志处理"><a href="#1-传统日志处理" class="headerlink" title="1. 传统日志处理"></a>1. 传统日志处理</h3><p>说到日志，我们以前处理日志的方式如下：</p>
<p>日志写到本机磁盘上<br>通常仅用于排查线上问题，很少用于数据分析<br>需要时登录到机器上，用grep、awk等工具分析<br>那么，这种方式有什么缺点呢？</p>
<p>第一，它的效率非常低，因为每一次要排查问题的时候都要登到机器上去，当有几十台或者是上百台机器的时候，每一台机器去登陆这是一个没办法接受的事情，可能一台机器浪费两分钟，整个几小时就过去了。</p>
<p>第二，如果要进行一些比较复杂的分析，像grep、awk两个简单的命令不能够满足需求时，就需要运行一些比较复杂的程序进行分析。</p>
<p>第三，日志本身它的价值不光在于排查一些系统问题上面，可能在一些数据的分析上，可能利用日志来做一些用户的决策，这也是它的价值，如果不能把它利用起来，价值就不能充分的发挥出来。</p>
<h3 id="2-docker日志处理"><a href="#2-docker日志处理" class="headerlink" title="2. docker日志处理"></a>2. docker日志处理</h3><p>与Docker相关的日志主要有两部分：</p>
<ul>
<li>Docker Daemon日志，即Docker自身运行产生的日志。</li>
<li>Docker Container日志，即Docker容器应用产生的日志。</li>
</ul>
<p>容器日志的两种输出形式:</p>
<ul>
<li>stdout、stderr 标准输出</li>
<li>日志文件记录</li>
</ul>
<p>标准输出日志的原理在于，当在启动进程的时候，进程之间有一个父子关系，父进程可以拿到子进程的标准输出。拿到子进程标准输出的后，父进程可以对标准输出做所有希望的处理。</p>
<p>LogDriver就是Docker用来处理容器标准输出的一个模块。 Docker支持很多种不同的处理方式，比如你的标准输出之后，在某一种情况下会把它写到一个日志里面，Docker默认的JSON File日志，除此之外，Docker还可以把它发送到syslog里面，或者是发送到journald里面去，或者是gelf的一个系统。</p>
<p>logger drive</p>
<table>
<thead>
<tr>
<th style="text-align:center">Driver</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">none</td>
<td style="text-align:center">丢弃容器输出，docker logs命令也看不到任何内容</td>
</tr>
<tr>
<td style="text-align:center">json-file</td>
<td style="text-align:center">默认驱动，使用json文件保存日志</td>
</tr>
<tr>
<td style="text-align:center">syslog</td>
<td style="text-align:center">将日志写入syslog里，syslog必须在机器上启动</td>
</tr>
<tr>
<td style="text-align:center">journald</td>
<td style="text-align:center">将日志发送到journald（systemd）,journald必须在机器上启动</td>
</tr>
<tr>
<td style="text-align:center">gelf</td>
<td style="text-align:center">将日志发送到GELF端点，如Graylog或Logstash</td>
</tr>
<tr>
<td style="text-align:center">fluentd</td>
<td style="text-align:center">将日志发送给fluentd，fluentd必须在机器上启动</td>
</tr>
<tr>
<td style="text-align:center">awslogs</td>
<td style="text-align:center">将日志发送给Amazon Cloudwatch</td>
</tr>
<tr>
<td style="text-align:center">splunk</td>
<td style="text-align:center">将日志发送到splunk</td>
</tr>
<tr>
<td style="text-align:center">etwlogs</td>
<td style="text-align:center">将日志发送给Event Tracing for Windows。仅在windows平台可用</td>
</tr>
<tr>
<td style="text-align:center">gcplogs</td>
<td style="text-align:center">将日志发送给Google日志系统</td>
</tr>
<tr>
<td style="text-align:center">nats</td>
<td style="text-align:center">将日志发送给NATS服务</td>
</tr>
</tbody>
</table>
<p>json-file<br>The default logging we’ve just looked at.<br>syslog<br>The syslog driver, which we’ll look at shortly.<br>journald<br>The driver for the systemd journal.<br>gelf<br>The Graylog Extended Log Format (GELF) driver.<br>fluentd<br>Forwards log messages to fluentd.<br>none<br>Turns off logging.</p>
<p>docker日志内容类型</p>
<ul>
<li>docker自身运行时Daemon的日志内容</li>
<li>docker容器的日志内容</li>
</ul>
<h3 id="3-集中式日志聚合"><a href="#3-集中式日志聚合" class="headerlink" title="3. 集中式日志聚合"></a>3. 集中式日志聚合</h3><ul>
<li>在所有的容器里运行一个辅助进程，该进程充当agent并将日志发到我们的聚合service里。</li>
<li>在主机上或者是在一个单独的容器里，收集日志并转发到聚合service里。</li>
</ul>
<p>第一种方式经常用到，但是它可能会让镜像变大，并且必要地增加了运行的进程数量。</p>
<ul>
<li>使用Docker API动态的获取日志</li>
<li>使用syslog driver</li>
<li>直接访问Docker目录下的日志文件</li>
</ul>
<p>这个方案非常简单，但是其实会有很多的缺点：</p>
<p>第一，因为每个容器都有一个日志的进程，意味着你的机器上面有100个容器，就需要启动一百个日志设备的程序，资源的浪费非常厉害。</p>
<p>第二，在做镜像的时候，需要把容器里面日志采集程序做到镜像里面去，对你的镜像其实是有入侵的，为了日志采集，不得不把自己的日志程序再做个新镜像，然后把东西放进去，所以对你的镜像过程是有入侵性的。</p>
<p>第三，当一个容器里面好多个进程的时候，对于容器的资源管理，会干扰你对容器的资源使用的判断，包括对于在做资源分配和监控的时候，都会有一些这样的干扰。</p>
<h3 id="4-out-of-scope"><a href="#4-out-of-scope" class="headerlink" title="4. out of scope"></a>4. out of scope</h3><p>那么，我们怎么样去收集日志、存储日志，用什么样的系统，日志的源头和写日志我们又该怎么来做，有这样几个建议：</p>
<ol>
<li><p>选择合适的日志框架，不要直接print；</p>
</li>
<li><p>为每一条日志选择正确的level，该debug的不要用info；</p>
</li>
<li><p>附加更多的上下文信息；</p>
</li>
<li><p>使用json、csv等日志格式，方便工具解析；</p>
</li>
<li><p>尽量不要使用多行日志(Java Exception Stack)。</p>
</li>
</ol>
<h2 id="四、监控"><a href="#四、监控" class="headerlink" title="四、监控"></a>四、监控</h2><h3 id="1-why？"><a href="#1-why？" class="headerlink" title="1. why？"></a>1. why？</h3><h3 id="2-监控什么？"><a href="#2-监控什么？" class="headerlink" title="2. 监控什么？"></a>2. 监控什么？</h3><h2 id="五、Dashboard"><a href="#五、Dashboard" class="headerlink" title="五、Dashboard"></a>五、Dashboard</h2><h3 id="1-why-可视化？"><a href="#1-why-可视化？" class="headerlink" title="1. why 可视化？"></a>1. why 可视化？</h3><h3 id="2-可视化哪些信息？"><a href="#2-可视化哪些信息？" class="headerlink" title="2. 可视化哪些信息？"></a>2. 可视化哪些信息？</h3><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://yq.aliyun.com/articles/72700" target="_blank" rel="external">Docker日志收集最佳实践</a></li>
<li><a href="http://dockone.io/article/2644" target="_blank" rel="external">Docker 日志的5个最佳实践</a></li>
<li><a href="http://dockone.io/article/2252" target="_blank" rel="external">使用ELK处理Docker日志(一)</a></li>
<li><a href="http://blog.cloud66.com/9-crtitical-decisions-needed-to-run-docker-in-production/" target="_blank" rel="external">9 Critical Decisions for Running Docker in Production</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;　　&lt;a href=&quot;https://www.bagevent.com/event/828605&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Docker in Production》 workshop&lt;/a&gt;于2017年9月23在ThoughtWorks武汉举办，之后，有懒癌的笔者就“忘记“去接着更新这一系列了。&lt;br&gt;直到上次上线（OTR Diaochan Release）出现了一些问题，在寻找问题过程中，docker的日志、监控、Dashboard这一主题发挥了很重要的作用，才想起来该好好整理下这一篇文章。&lt;/p&gt;
&lt;h2 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h2&gt;&lt;p&gt;　　该系列《Docker in Prodcution》内容包含如下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;容器简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker的基本操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker数据存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;多主机部署&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志、监控、Dashboard&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;三、日志&quot;&gt;&lt;a href=&quot;#三、日志&quot; class=&quot;headerlink&quot; title=&quot;三、日志&quot;&gt;&lt;/a&gt;三、日志&lt;/h2&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>餐巾纸的背面（三）拓展创意</title>
    <link href="http://yoursite.com/2017/12/02/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2%EF%BC%88%E4%B8%89%EF%BC%89%E6%8B%93%E5%B1%95%E5%88%9B%E6%84%8F/"/>
    <id>http://yoursite.com/2017/12/02/餐巾纸的背面（三）拓展创意/</id>
    <published>2017-12-02T07:26:07.000Z</published>
    <updated>2017-12-27T07:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>　　前面一<a href="http://zhangyuyu.github.io/2017/12/02/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%91%E7%8E%B0%E5%88%9B%E6%84%8F/" target="_blank" rel="external">餐巾纸的背面（二）发现创意</a>对视觉化思考的四个步骤进行了详解，介绍了SQVID和六六法则。<br>　　原书《餐巾纸的背面》第三部分【拓展创意】是结合MBA的案例，对视觉化思考的六种方式进行实操演练，本文就不再赘述，有兴趣的读者可以自己参考。<br>　　在本文中，主要是看书过后的一些思考与对手绘视觉化的拓展，可能与《餐巾纸的背面》一书没太多强关联了，偏重点在于手绘导图的方式方法。</p>
<h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>　　当我们将脑海中想象出来的内容进行视觉化时候，有两种选择：软件绘制和手绘导图，机视觉笔记的两种载体。<br>　　软件绘制，可以借助很多工具进行精确、精美的绘制，如Microsoft办公软件系列，Google办公软件系列、WPS、Xmind等等；手绘导图，凭借自己的一双手、随时随地就可以开始作画。<br>　　虽然《餐巾纸的背面》一书中多次提到，我们有三个天生的视觉性工具————肉眼、内心的眼睛、手眼合作，拿起笔开始画图并不难。但是笔者还是会各种纠结到底如何画才好，有没有一些常见版式参考，或者小的tips。<br>　　带着这个问题，发现【视觉笔记】、【涂鸦笔记】这样的字眼频繁出现，而且与【视觉化思考】的实践联系颇多，故而，以此整理总结。</p>
<h2 id="三、视觉笔记的要素"><a href="#三、视觉笔记的要素" class="headerlink" title="三、视觉笔记的要素"></a>三、视觉笔记的要素</h2><a id="more"></a>
<p>　　我们常见的前端网页，主要由html + css + javascript组成，用一扇门比喻三者间的关系，html是门的门板，css是门上的油漆或花纹，javascript是门的开关。换言之，其中几个要素则是结构与内容、样式、效果。<br>　　那么，同理可得：<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">一幅视觉笔记 </span>=<span class="string"> 结构 + 内容 + 样式 + 效果 。</span></div></pre></td></tr></table></figure></p>
<ul>
<li>在结构上，涉及的是版式。</li>
<li>在内容上，主要是由图和文字构成，那么涉及到的就是图形元素、文字等。</li>
<li>在样式上，涉及的是配色。</li>
<li>在效果上，涉及的是组合之后表达的信息。</li>
</ul>
<p>因此，视觉笔记的几大要素：结构版式、图形元素、文字、配色。</p>
<h2 id="四、结构版式"><a href="#四、结构版式" class="headerlink" title="四、结构版式"></a>四、结构版式</h2><p>视觉笔记的结构版式有如下7种：</p>
<ul>
<li>线型</li>
<li>放射型</li>
<li>垂直型</li>
<li>路径型</li>
<li>模块型</li>
<li>摩天大楼型</li>
<li>爆米花型</li>
</ul>
<img src="/imgs/餐巾纸的背面-扩展创意-视觉笔记排版.jpg" width="800" height="450">
<p align="center"> （图片来自<a href="http://www.jianshu.com/p/668c90a7e5a7" target="_blank" rel="external">视觉笔记与手帐</a>）</p>

<h3 id="1-线型"><a href="#1-线型" class="headerlink" title="1. 线型"></a>1. 线型</h3><p>从上到下，从左到右<br>优点：人们比较习惯的模式、可以记录多页、便于阅读<br>缺点：信息流向上死板，布局有制约。</p>
<p>【示例：线型】<br><img src="/imgs/餐巾纸的背面-扩展创意-线型.jpg" width="500" height="200"></p>
<h3 id="2-放射型"><a href="#2-放射型" class="headerlink" title="2. 放射型"></a>2. 放射型</h3><p>由一个主题发散出去，分为对称型和不对称型<br>优点：添加内容灵活<br>缺点：对于某些读者，由于排列非线形，阅读会比较困难。</p>
<p>【示例：放射型】<br><img src="/imgs/餐巾纸的背面-扩展创意-放射型.jpg" width="800" height="450"></p>
<h3 id="3-垂直型"><a href="#3-垂直型" class="headerlink" title="3. 垂直型"></a>3. 垂直型</h3><p>从顶部至底部（只有一页）<br>优点：便于阅读<br>缺点：制约布局，长度受纸的制约</p>
<p>【示例：垂直型】<br><img src="/imgs/餐巾纸的背面-扩展创意-垂直型.jpg" width="500" height="600"></p>
<h3 id="4-路径型"><a href="#4-路径型" class="headerlink" title="4. 路径型"></a>4. 路径型</h3><p>路径可以是Z、C、W等任何想到的形状。<br>适用于：时间上的先后、故事的发展、逻辑上的因果<br>缺点：需要规划，如果需要记录的内容超出预期，会空间不够。</p>
<p>【示例：路径型】<br><img src="/imgs/餐巾纸的背面-扩展创意-路径型.jpg" width="800" height="450"></p>
<h3 id="5-模块型"><a href="#5-模块型" class="headerlink" title="5. 模块型"></a>5. 模块型</h3><p>将页面分为不同区域，分别放置不同信息。<br>优点：可以在有限空间内记录很多展示信息。<br>缺点：限制了信息数量，需要预先规划。</p>
<p>【示例：模块型】<br><img src="/imgs/餐巾纸的背面-扩展创意-模块型.jpg" width="800" height="450"></p>
<h3 id="6-摩天大楼型"><a href="#6-摩天大楼型" class="headerlink" title="6. 摩天大楼型"></a>6. 摩天大楼型</h3><p>特殊的模块型。<br>适用于：圆桌讨论，多人在不同时间发言。<br>缺点：同模块型。</p>
<p>【示例：摩天大楼型】<br><img src="/imgs/餐巾纸的背面-扩展创意-摩天大楼型.jpg" width="800" height="450"></p>
<h3 id="7-爆米花型"><a href="#7-爆米花型" class="headerlink" title="7. 爆米花型"></a>7. 爆米花型</h3><p>将标题和信息放在页面任意位置的版式。<br>优点：极其灵活。使人专注于获取信息，而不在意位置<br>缺点：信息摆放无序，难于理解。</p>
<p>【示例：爆米花型】<br><img src="/imgs/餐巾纸的背面-扩展创意-爆米花型.jpg" width="800" height="450"></p>
<h3 id="五、图形元素"><a href="#五、图形元素" class="headerlink" title="五、图形元素"></a>五、图形元素</h3><p>常用的5种视觉元素：人物、小图标、箭头、对话框、图框。</p>
<h4 id="1-人物"><a href="#1-人物" class="headerlink" title="1. 人物"></a>1. 人物</h4><p>人物的画法大致可以分为如下几种：</p>
<ul>
<li>火柴人</li>
<li>进阶火柴人</li>
<li>星形人</li>
<li>格雷法</li>
<li>others(自定义形式)</li>
</ul>
<img src="/imgs/餐巾纸的背面-扩展创意-人物的画法.jpg" width="800" height="450">
<h5 id="火柴人"><a href="#火柴人" class="headerlink" title="火柴人"></a>火柴人</h5><img src="/imgs/餐巾纸的背面-扩展创意-火柴人.jpg" width="600" height="150">
<h5 id="进阶火柴人"><a href="#进阶火柴人" class="headerlink" title="进阶火柴人"></a>进阶火柴人</h5><img src="/imgs/餐巾纸的背面-扩展创意-进阶火柴人.jpg" width="600" height="150">
<p>【示例】<br><img src="/imgs/餐巾纸的背面-扩展创意-进阶火柴人示例.jpg" width="600" height="150"></p>
<h5 id="星形人"><a href="#星形人" class="headerlink" title="星形人"></a>星形人</h5><img src="/imgs/餐巾纸的背面-扩展创意-星形人.jpg" width="600" height="150">
<h5 id="格雷法"><a href="#格雷法" class="headerlink" title="格雷法"></a>格雷法</h5><img src="/imgs/餐巾纸的背面-扩展创意-格雷法.jpg" width="600" height="150">
<p>【示例】<br><img src="/imgs/餐巾纸的背面-扩展创意-格雷法示例.jpg" width="400" height="150"></p>
<h5 id="others"><a href="#others" class="headerlink" title="others"></a>others</h5><img src="/imgs/餐巾纸的背面-扩展创意-others.jpg" width="600" height="150">
<h4 id="2-箭头"><a href="#2-箭头" class="headerlink" title="2. 箭头"></a>2. 箭头</h4><img src="/imgs/餐巾纸的背面-扩展创意-箭头.jpg" width="600" height="150">
<h4 id="3-对话框"><a href="#3-对话框" class="headerlink" title="3. 对话框"></a>3. 对话框</h4><img src="/imgs/餐巾纸的背面-扩展创意-对话框.jpg" width="600" height="150">
<h4 id="4-图框"><a href="#4-图框" class="headerlink" title="4. 图框"></a>4. 图框</h4><img src="/imgs/餐巾纸的背面-扩展创意-图框.jpg" width="600" height="150">
<h4 id="5-小图标"><a href="#5-小图标" class="headerlink" title="5. 小图标"></a>5. 小图标</h4><p>小图标有很多种，这个很容易在网上就可以搜索到，文章末尾reference里面提供了几个icon的链接。<br>限于篇幅，下面只列举一些比较好画的。</p>
<p>【示例：项目符号】<br><img src="/imgs/餐巾纸的背面-扩展创意-项目符号.jpg" width="600" height="150"></p>
<p>【示例：建筑】<br><img src="/imgs/餐巾纸的背面-扩展创意-建筑.jpg" width="600" height="150"></p>
<p>【示例：树木】<br><img src="/imgs/餐巾纸的背面-扩展创意-树木.jpg" width="600" height="150"></p>
<h3 id="六、字体"><a href="#六、字体" class="headerlink" title="六、字体"></a>六、字体</h3><p>主要是风格、大小、间距、粗细、大小写、组合对比，要点在于让人一眼望去，层次分明。</p>
<p>【示例：字体的风格】<br>字体有很多种风格，不同的在线资源分类方法也都不一样，下面只是随便截图了一段：<br><img src="/imgs/餐巾纸的背面-扩展创意-字体风格.jpg" width="600" height="150"></p>
<h3 id="七、配色"><a href="#七、配色" class="headerlink" title="七、配色"></a>七、配色</h3><ol>
<li><p>正文字体最好不要超过三种颜色，颜色太多显得杂乱，不要选择饱和度太高的颜色，就是鲜艳的颜色，太亮眼了，尽量用温和一些的深色系，如深灰或者黑色。</p>
</li>
<li><p>用一种颜色作为主色调，可以用在标题、重点内容、二维码、头像、顶部和底部的引导等。</p>
</li>
<li><p>金句或者突出的地方用黑色加粗，或者深色系的颜色即可。</p>
</li>
</ol>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://goo.gl/r3UQr" target="_blank" rel="external">The Sketchnote Handbook</a></li>
<li><a href="http://sunnibrown.com/doodlerevolution/" target="_blank" rel="external">Doodle Revolution</a></li>
<li><a href="http://sketchnotearmy.com/sketchnoters/" target="_blank" rel="external">视觉笔记博客集锦</a></li>
<li><a href="https://thenounproject.com/" target="_blank" rel="external">Icons for everything</a></li>
<li><a href="http://iconfont.cn/" target="_blank" rel="external">Iconfont</a></li>
<li><a href="https://www.autodraw.com/" target="_blank" rel="external">Autodraw</a></li>
<li><a href="https://www.flaticon.com/" target="_blank" rel="external">Flaticon</a></li>
<li><a href="https://mp.weixin.qq.com/s/XqjA5Wwn7ql6rKOlyuLn-w" target="_blank" rel="external">从绘画小白到手绘达人</a></li>
<li><a href="http://www.jianshu.com/p/bf2d287b4a4a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="external">干货｜任何人都能做出好看的视觉笔记</a></li>
<li><a href="http://www.jianshu.com/p/2dc6fea6a20f?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="external">视觉笔记让你的学习更高效</a></li>
<li><a href="http://www.jianshu.com/p/4596e168ec06" target="_blank" rel="external">视觉化你的行动力</a></li>
<li><a href="http://www.jianshu.com/p/f70f8518bb03" target="_blank" rel="external">视觉笔记 | 几个国外视觉笔记博客介绍</a></li>
<li><a href="http://www.jianshu.com/p/5b3658235333" target="_blank" rel="external">路乔手绘笔记系列</a></li>
<li><a href="http://www.jianshu.com/u/1d467fec18db" target="_blank" rel="external">铃铛子简书</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;　　前面一&lt;a href=&quot;http://zhangyuyu.github.io/2017/12/02/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%91%E7%8E%B0%E5%88%9B%E6%84%8F/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;餐巾纸的背面（二）发现创意&lt;/a&gt;对视觉化思考的四个步骤进行了详解，介绍了SQVID和六六法则。&lt;br&gt;　　原书《餐巾纸的背面》第三部分【拓展创意】是结合MBA的案例，对视觉化思考的六种方式进行实操演练，本文就不再赘述，有兴趣的读者可以自己参考。&lt;br&gt;　　在本文中，主要是看书过后的一些思考与对手绘视觉化的拓展，可能与《餐巾纸的背面》一书没太多强关联了，偏重点在于手绘导图的方式方法。&lt;/p&gt;
&lt;h2 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h2&gt;&lt;p&gt;　　当我们将脑海中想象出来的内容进行视觉化时候，有两种选择：软件绘制和手绘导图，机视觉笔记的两种载体。&lt;br&gt;　　软件绘制，可以借助很多工具进行精确、精美的绘制，如Microsoft办公软件系列，Google办公软件系列、WPS、Xmind等等；手绘导图，凭借自己的一双手、随时随地就可以开始作画。&lt;br&gt;　　虽然《餐巾纸的背面》一书中多次提到，我们有三个天生的视觉性工具————肉眼、内心的眼睛、手眼合作，拿起笔开始画图并不难。但是笔者还是会各种纠结到底如何画才好，有没有一些常见版式参考，或者小的tips。&lt;br&gt;　　带着这个问题，发现【视觉笔记】、【涂鸦笔记】这样的字眼频繁出现，而且与【视觉化思考】的实践联系颇多，故而，以此整理总结。&lt;/p&gt;
&lt;h2 id=&quot;三、视觉笔记的要素&quot;&gt;&lt;a href=&quot;#三、视觉笔记的要素&quot; class=&quot;headerlink&quot; title=&quot;三、视觉笔记的要素&quot;&gt;&lt;/a&gt;三、视觉笔记的要素&lt;/h2&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="餐巾纸的背面" scheme="http://yoursite.com/tags/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>餐巾纸的背面（二）发现创意</title>
    <link href="http://yoursite.com/2017/12/02/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%91%E7%8E%B0%E5%88%9B%E6%84%8F/"/>
    <id>http://yoursite.com/2017/12/02/餐巾纸的背面（二）发现创意/</id>
    <published>2017-12-02T06:52:04.000Z</published>
    <updated>2017-12-27T07:15:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>　　看的更真切、目光更敏锐、想象更丰富————这才是视觉化思考的最佳工具和准则。<br>　　前面一篇 <a href="http://zhangyuyu.github.io/2017/11/30/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2%EF%BC%88%E4%B8%80%EF%BC%89%E8%A7%86%E8%A7%89%E5%8C%96%E6%80%9D%E8%80%83/" target="_blank" rel="external">餐巾纸的背面（一）视觉化思考</a> 从整体上介绍了视觉化思考的几个重要部分：四个步骤、三个工具、六种方法。本篇将借助这三个工具、6种方法进行四个步骤的详解。<br><img src="/imgs/餐巾纸的背面-发现创意-大纲.jpg" width="600" height="400"></p>
<h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>　　互联网时代，信息泛滥，知识变得无处不在。鼠标轻轻一点，我们就坐拥一座巨型图书馆。然后我们并没有因此离真相更近，离真正的掌握更近。我们花费了大量的时间去获取信息，去浏览不同的网页，了解不同的案例。<br>　　看书、练习、总结，在这个信息爆炸、碎片化的时代，也许是一种不错的学习方式。只有不停的练习、验证，才能逐步掌握“真正的知识”，而不是仅仅获取这些“网络上的信息”。</p>
<h2 id="三、看"><a href="#三、看" class="headerlink" title="三、看"></a>三、看</h2><a id="more"></a>
<p>　　我们睁开眼的每一秒，都有大量的视觉信号像光量子一样经视网膜转换成电子脉冲，然后通过视觉神经进入大脑的不同区域，这一过程中信号被分析、过滤、比较、分门别类、重组————这样才能成为我们大脑中形成的图像。<br>　　上述过程是无意识的，而我们谈起视觉化思考的时候，指的是有意识地使用上述内在观看系统。谈视觉化思考，首先得说说“主动地看”。</p>
<h3 id="1-我们如何看"><a href="#1-我们如何看" class="headerlink" title="1. 我们如何看"></a>1. 我们如何看</h3><p>　　四项关键任务：定向、定位、识别、聚焦。我们的视觉系统在无意识情况下，就是通过完成这四项关键任务来为我们服务的。<br><img src="/imgs/餐巾纸的背面-发现创意-四项关键任务.jpg" width="600" height="150"></p>
<h3 id="2-如何看得更真切"><a href="#2-如何看得更真切" class="headerlink" title="2. 如何看得更真切"></a>2. 如何看得更真切</h3><p>　　为了培养好的观看技巧，并且为视觉化打下好的基础，当我们看到新鲜事物时，需要遵从四个基本规则：</p>
<p>1). 收集我们能够看到的东西————越多越好（至少在开始是这样）</p>
<p>　　<img src="/imgs/餐巾纸的背面-发现创意-看1.jpg" width="400" height="150"></p>
<ul>
<li>如果信息过量，则可以结合上述的四项关键任务进行<code>“主动地看”</code>；</li>
<li>如果信息不足，则可以使用<strong>“六要素”</strong>来划定问题框架。</li>
</ul>
<p>2). 需要有一个地方逐个摆放我们的东西，这样我们可以将它们整个纳入视野</p>
<p>　　<img src="/imgs/餐巾纸的背面-发现创意-看2.jpg" width="400" height="150"></p>
<p>　　收集到所有需要的东西之后，我们可以把它们放在显眼的地方，这是有效阅读大量信息的最好方式，我们可以迅速浏览它们。<br>　　不一定必须是真实的物理空间，还可以通过电子表单，使能够一次性看到所有的数据，并进行比较。</p>
<p>3). 确定一个基本的坐标系以提供清晰的定向和位置</p>
<p>　　<img src="/imgs/餐巾纸的背面-发现创意-看3.jpg" width="400" height="150"></p>
<p>　　<strong>“六要素”</strong>就是很好的坐标系基本元素，几乎我们所有可能看到的描述性图画都会用六要素来绘制坐标。</p>
<p>【示例：股票走势&amp;比赛时间】<br><img src="/imgs/餐巾纸的背面-发现创意-示例图.jpg" width="400" height="100"></p>
<p>4). 学会减少我们眼睛看到的东西————我们需要练习视觉分类</p>
<img src="/imgs/餐巾纸的背面-发现创意-看4.jpg" width="400" height="150">
<p>　　总有太多视觉信息我们处理不过来，所有需要我们d额视觉系统对那些信息进行筛选。<br>常见的前认知视觉属性：“临近度”、“颜色”、“尺寸”、“方位”、“方向”、“形状”及“明暗”， 我们可以借助于它们对视觉信号进行分类。</p>
<h2 id="四、观察"><a href="#四、观察" class="headerlink" title="四、观察"></a>四、观察</h2><h3 id="1-看-VS-观察"><a href="#1-看-VS-观察" class="headerlink" title="1. 看 VS 观察"></a>1. 看 VS 观察</h3><ul>
<li>如果说“看”着眼于收集呈现在我们面前的原始视觉信息，那么观察就是要选出那些重要的视觉信息。</li>
<li>“看”是一个相对开放的过程，“观察”则是一个逐渐聚焦的过程。</li>
<li>“看”是在收集信息，“观察”则是在选择信息并最终确定要研究的部分到底在哪里。</li>
</ul>
<h3 id="2-六要素观察"><a href="#2-六要素观察" class="headerlink" title="2. 六要素观察"></a>2. 六要素观察</h3><ul>
<li>目标————注意了是谁，是什么</li>
<li>数量————有多少</li>
<li>在空间中的位置————在哪里</li>
<li>在时间推移中的位置————什么时候</li>
<li>种种影响、原因与结果————怎么样</li>
<li>所有因素汇集到一起，明白“曲折原因”————为什么</li>
</ul>
<p>【示例：巧克力公司培训】<br><img src="/imgs/餐巾纸的背面-发现创意-观察.jpg" width="1000" height="800"></p>
<h2 id="五、想象"><a href="#五、想象" class="headerlink" title="五、想象"></a>五、想象</h2><h3 id="1-看、观察-→-想象"><a href="#1-看、观察-→-想象" class="headerlink" title="1. 看、观察 → 想象"></a>1. 看、观察 → 想象</h3><ul>
<li>通过“主动地看”，我们的双眼可以收集与所面临问题有关的一系列视觉信息；</li>
<li>通过“仔细观察”，我们会把这些信息进行分类，分为六种不同的视觉类型；</li>
<li>那么通过“想象”，我们会产生许多奇妙的创意，也会提出许多奇妙的解决办法。</li>
</ul>
<h3 id="2-SQVID"><a href="#2-SQVID" class="headerlink" title="2. SQVID"></a>2. SQVID</h3><h4 id="1）什么是SQVID"><a href="#1）什么是SQVID" class="headerlink" title="1）什么是SQVID"></a>1）什么是SQVID</h4><p>　　SQVID 基本上就是由名字中的五个元素所组成：简单（Simple）、定性（Quality）、愿景（Vision）、个别（Individual）和变化 （Delta）。<br><img src="/imgs/餐巾纸的背面-发现创意-SQVID.jpg" width="600" height="300"></p>
<p>上图中涉及到的五个问题：</p>
<ul>
<li>问题一： “简单”还是“精细”</li>
<li>问题二： “定性”还是“定量”</li>
<li>问题三： 突出“愿景”，还是突出“执行”</li>
<li>问题四： 突出“个别“，还是突出”比较“</li>
<li>问题五： 注重”现状“，还是将来的”变化“</li>
</ul>
<h4 id="2）SQVID的好处"><a href="#2）SQVID的好处" class="headerlink" title="2）SQVID的好处"></a>2）SQVID的好处</h4><p>SQVID能帮助我们同时完成两项和“想象”有关的关键任务：</p>
<ul>
<li>可以让我们“内心的眼睛”的每个角落都活跃起来，以便完整的捕捉脑海中出现的形象。</li>
<li>帮助我们从潜在听众的角度好好审视那些图和形象。</li>
</ul>
<h4 id="3）深入SQVID"><a href="#3）深入SQVID" class="headerlink" title="3）深入SQVID"></a>3）深入SQVID</h4><h5 id="SQVID两种方式："><a href="#SQVID两种方式：" class="headerlink" title="SQVID两种方式："></a>SQVID两种方式：</h5><p>【方式一】：以创意为中心<br>　　在脑海中，把SQVID的五个问题轮番问一遍，酝酿好每个问题的答案，准备好把这些答案形象化表达出来的额方式。通过这种方法，我们至少可以帮助自己提出10个不同的观点。</p>
<p>【方式二】：以听众为中心<br>　　根据观众的关心程度，调整自己准备“展示”的重点，就像调节音频均衡器一样，要把滑钮拧向自己希望调整的那一端。通过这种方法，我们就可以确定，到底哪一种类型的图最适合展示给听众。</p>
<h4 id="冷暖波段"><a href="#冷暖波段" class="headerlink" title="冷暖波段"></a>冷暖波段</h4><p>　　通过上图，我们可以看到SQVID图中：</p>
<ul>
<li>上半部分的词汇：“简单”、“定性”、“愿景”、“个别”、“变化”，这些词汇一针见血、具有概括性、与众不同并且抽象，带有很强的感情色彩，因此上半部分是“偏暖波段”；</li>
<li>下半部分的词汇：“精细”、“定量”、“执行”、“比较”、“现状”，这些词汇在商务活动中强调得更多，也更传统，因为它们以数据为基础，强调分析、细节、实事求是以及可测量性，强调理性，摆脱了情绪的干扰，因此下半部分称为“偏冷波段”。</li>
</ul>
<blockquote>
<p>注意：视觉化思考的目的是把复杂问题清楚地呈现出来，而不是把它简单化。</p>
</blockquote>
<h2 id="六、展示"><a href="#六、展示" class="headerlink" title="六、展示"></a>六、展示</h2><h3 id="1-展示"><a href="#1-展示" class="headerlink" title="1. 展示"></a>1. 展示</h3><p>　　展示就是我们与他人分享图画的过程，一方面是想把其中的信息传达给他们，另一方面则是想说服他们。与此同时，我们还会非常留心，看看他们观察的东西是否与自己设想的分毫不差。</p>
<h3 id="2-三个步骤"><a href="#2-三个步骤" class="headerlink" title="2. 三个步骤"></a>2. 三个步骤</h3><p>　　为了很好的向”别人“展示自己的想法，我们需要完成三步：</p>
<ul>
<li>选择合适的框架</li>
<li>依照选定的框架画图</li>
<li>介绍和解释所化的图</li>
</ul>
<h3 id="3-六六法则"><a href="#3-六六法则" class="headerlink" title="3. 六六法则"></a>3. 六六法则</h3><p>　　上述第一个步骤选择合适的框架中，我们需要两种工具来帮我们选出好的框架：<strong>SQVID</strong>和<strong>六六法则</strong>。 </p>
<h4 id="1-六六法则"><a href="#1-六六法则" class="headerlink" title="1). 六六法则"></a>1). 六六法则</h4><p>　　<img src="/imgs/餐巾纸的背面-发现创意-六六法则.jpg" width="600" height="450"></p>
<p>　　上图是我们观察世界的六种方式，以及”展示“它们的方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">观察</th>
<th style="text-align:center">问题</th>
<th style="text-align:center">展示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">谁/什么</td>
<td style="text-align:center">定性的刻画</td>
<td style="text-align:center">画像</td>
</tr>
<tr>
<td style="text-align:center">有多少</td>
<td style="text-align:center">定量的表述</td>
<td style="text-align:center">图表</td>
</tr>
<tr>
<td style="text-align:center">在哪里</td>
<td style="text-align:center">空间中的位置</td>
<td style="text-align:center">布局图</td>
</tr>
<tr>
<td style="text-align:center">在什么时候</td>
<td style="text-align:center">时间中的位置</td>
<td style="text-align:center">时间轴</td>
</tr>
<tr>
<td style="text-align:center">怎么样</td>
<td style="text-align:center">原因 + 效果</td>
<td style="text-align:center">流程图</td>
</tr>
<tr>
<td style="text-align:center">为什么</td>
<td style="text-align:center">演绎 + 推测</td>
<td style="text-align:center">多重变量图</td>
</tr>
</tbody>
</table>
<h4 id="2-选择框架的四个标准"><a href="#2-选择框架的四个标准" class="headerlink" title="2). 选择框架的四个标准"></a>2). 选择框架的四个标准</h4><ul>
<li>用框架来展示什么？</li>
<li>每一种展示的框架都有它潜在的坐标系；</li>
<li>这些展示的框架中，那些对象之间的关系到底是什么？</li>
<li>展示框架的起点是什么？例如问题的中心、问题的由来或者我们的最终目标等。</li>
</ul>
<h4 id="3-六六法则结合SQVID"><a href="#3-六六法则结合SQVID" class="headerlink" title="3). 六六法则结合SQVID"></a>3). 六六法则结合SQVID</h4><p>　　<img src="/imgs/餐巾纸的背面-发现创意-六六法则&SQVID.jpg" width="600" height="300"><br>　　上图将SQVID和六六法则画在了同一个表格中，根据SQVID选择展示方式，根据六六法则选择框架。这样的表格能把解决问题的各种类型的主要图示都列的非常清楚，也就是我们所说的<code>视觉化思考宝典</code>。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>　　本篇对四个步骤进行了详细拆解，介绍了视觉化的基础，了解了SQVID工具和六六法则，学会了如何才能看的更准、理解更深、想得更远。<br>　　在下一篇<a href="http://zhangyuyu.github.io/2017/12/02/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2%EF%BC%88%E4%B8%89%EF%BC%89%E6%8B%93%E5%B1%95%E5%88%9B%E6%84%8F/" target="_blank" rel="external">餐巾纸的背面（三）拓展创意</a>中，将介绍自己认为常见的，几个可视化图形框架。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://www.ylib.com/hotsale/napkin2/" target="_blank" rel="external">展开餐巾纸</a></li>
<li><a href="http://blog.163.com/wobutianl@126/blog/static/1335848201421511629602/" target="_blank" rel="external">好奇看世界博客</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;　　看的更真切、目光更敏锐、想象更丰富————这才是视觉化思考的最佳工具和准则。&lt;br&gt;　　前面一篇 &lt;a href=&quot;http://zhangyuyu.github.io/2017/11/30/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2%EF%BC%88%E4%B8%80%EF%BC%89%E8%A7%86%E8%A7%89%E5%8C%96%E6%80%9D%E8%80%83/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;餐巾纸的背面（一）视觉化思考&lt;/a&gt; 从整体上介绍了视觉化思考的几个重要部分：四个步骤、三个工具、六种方法。本篇将借助这三个工具、6种方法进行四个步骤的详解。&lt;br&gt;&lt;img src=&quot;/imgs/餐巾纸的背面-发现创意-大纲.jpg&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h2&gt;&lt;p&gt;　　互联网时代，信息泛滥，知识变得无处不在。鼠标轻轻一点，我们就坐拥一座巨型图书馆。然后我们并没有因此离真相更近，离真正的掌握更近。我们花费了大量的时间去获取信息，去浏览不同的网页，了解不同的案例。&lt;br&gt;　　看书、练习、总结，在这个信息爆炸、碎片化的时代，也许是一种不错的学习方式。只有不停的练习、验证，才能逐步掌握“真正的知识”，而不是仅仅获取这些“网络上的信息”。&lt;/p&gt;
&lt;h2 id=&quot;三、看&quot;&gt;&lt;a href=&quot;#三、看&quot; class=&quot;headerlink&quot; title=&quot;三、看&quot;&gt;&lt;/a&gt;三、看&lt;/h2&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="餐巾纸的背面" scheme="http://yoursite.com/tags/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>餐巾纸的背面（一）视觉化思考</title>
    <link href="http://yoursite.com/2017/11/30/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2%EF%BC%88%E4%B8%80%EF%BC%89%E8%A7%86%E8%A7%89%E5%8C%96%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2017/11/30/餐巾纸的背面（一）视觉化思考/</id>
    <published>2017-11-30T13:34:55.000Z</published>
    <updated>2017-12-27T07:14:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>　　《餐巾纸的背面》不是告诉你如何成为一个画家，而是告诉你如何进行思考。将视觉化思考的观点，移植到你的工作、生活、交往、个人品牌规划以及你的一切中。学会用眼睛看待世界，用心思考世界，从而用笔与世界沟通。</p>
<img src="/imgs/餐巾纸的背面-视觉化思考-大纲.jpg" width="500" height="800">
<h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>　　转眼已经2017年的年底了，回顾这一年虽然看了不少书，但是却是边看边忘，边焦虑边放松，似乎每次都能给自己找到足够的借口来“堕落”，继而冠冕堂皇的继续“优雅地享受生活”。<br>　　上次的《Buddy Workshop》，顿似醍醐灌顶，让人不容小觑<code>输出</code>的重要性；<br>　　邮件里面看到的《21天写工作坊》，蓦地振聋发聩，让人歆羡<code>坚持</code>的点滴沉淀；<br>　　考虑年底的training budget的书籍，忽地豁然开朗，让人开始沉静下来总结些许。</p>
<h2 id="三、什么是视觉化思考"><a href="#三、什么是视觉化思考" class="headerlink" title="三、什么是视觉化思考"></a>三、什么是视觉化思考</h2><a id="more"></a>
<p>　　视觉化思考是运用我们天生的观察力————包括肉眼与“内心的眼睛”————来发现那些平时意想不到的创意和想法，并且以一种简单易懂的方式将其表达出来。</p>
<p>　　无论是职场新兵，还是驰骋多年的老将，学会图形化思考将会让你在信息碎片化的时代更好的把握战场的敌情、地形、优劣势分析、制高点把握以及任务完成的关键。</p>
<h2 id="四、为什么视觉化如此神奇？"><a href="#四、为什么视觉化如此神奇？" class="headerlink" title="四、为什么视觉化如此神奇？"></a>四、为什么视觉化如此神奇？</h2><img src="/imgs/餐巾纸的背面-视觉化思考-为什么.jpg" width="400" height="250">
<p>1.更直观，视觉记忆更深刻。<br>　　文字比图更容易传承，图比文字更容易比解析。</p>
<p>2.提升传播效果<br>　　我们很容易发现图片可以传达更多的内容，在我们做讲演ppt的时候，我们都会用图片之类的来代替文字。尤其是直观的图片会给我们提供更多的信息。</p>
<p>3.提升思维<br>　　好的视觉框架能够更好地让复杂的事情变得更加的简单，而且可以相互支撑，写出让人意想不到的内容。</p>
<h2 id="五、基本图形"><a href="#五、基本图形" class="headerlink" title="五、基本图形"></a>五、基本图形</h2><h3 id="1-什么问题可以通过图来解决？"><a href="#1-什么问题可以通过图来解决？" class="headerlink" title="1. 什么问题可以通过图来解决？"></a>1. 什么问题可以通过图来解决？</h3><p>　　几乎所有的问题都可以通过画图来解决，因为图画能以便于理解的方式来表达复杂的概念，总结大量的信息，在澄清和解决各类问题时非常有用，比如商业问题、政治僵局、复杂的技术、组织的两难境地、日称冲突，甚至是个人需要应对的琐事和挑战。</p>
<p>　　下面这幅图，把大多数的问题进行归类：<br><img src="/imgs/餐巾纸的背面-视觉化思考-6要素.jpg" width="600" height="400"></p>
<p>　　上述图中的6个方面，即视觉化思考的6要素，该6要素会在后面的四个步骤中频繁出现，贯穿整个思考过程。</p>
<h3 id="2-什么样的图才能解决问题？"><a href="#2-什么样的图才能解决问题？" class="headerlink" title="2. 什么样的图才能解决问题？"></a>2. 什么样的图才能解决问题？</h3><img src="/imgs/餐巾纸的背面-视觉化思考-基本图形.jpg" width="600" height="200">
<p>　　我们平常所画的示意图、概要图、流程图、表格、坐标系、概念模型、网络模型以及其他种类的图都是由上面这些基本的元素构成的。你会发现，这些元素其实就是那些展示软件（PowerPoint、Keynote、Office）的绘图共举办的一部分。不管你会不会画画，只要你能画出这些基本图形，那么你就能画出可视化的图形。</p>
<h2 id="六、你是什么类型的人？"><a href="#六、你是什么类型的人？" class="headerlink" title="六、你是什么类型的人？"></a>六、你是什么类型的人？</h2><p>　　当我告诉人们，我可以通过画图来帮助他们解决商业问题时，他们有以下三种反应：“太棒了！让我看看怎么解决？”或者，“听起来很有意思……不过，真的管用吗？”或者，“算了吧。我不习惯视觉化思考。”</p>
<ul>
<li>黑笔类<br>　　作出第一种反应的人属于“把笔给我”型的人，他们会毫不犹豫地开始在纸上画图。我对曾经参加的商业会议进行过粗略的调查，调查中这类人的数量占到了与会者的1/4。</li>
<li>黄色荧光笔类<br>　　作出第二种反应的人属于“我不会画画，不过……”型的人，他们很善于发现别人画中最重要和最有趣的方面。这种人通常占到会议人数的1/2。</li>
<li>红笔类<br>　　最后一种反应的人，对于在商业语境中使用图画感到很不自在……至少最初是这样。他们占了会议人数余下的1/4。</li>
</ul>
<blockquote>
<p>　　视觉化思考并不是一种只有天才才具有的天分，也不属于那些多年研究这个问题的人。不论你属于哪个类型的人，重要的是要知道，视觉化思考能力使我们天生的能力。<br>　　我们有三个天生的视觉性工具————肉眼、内心的眼睛、手眼合作。</p>
</blockquote>
<img src="/imgs/餐巾纸的背面-视觉化思考-天生的工具.jpg" width="300" height="150">
<h2 id="七、四个步骤"><a href="#七、四个步骤" class="headerlink" title="七、四个步骤"></a>七、四个步骤</h2><img src="/imgs/餐巾纸的背面-视觉化思考-四个步骤.jpg" width="600" height="250">
<p>　　上图所示的是视觉化思考的过程：看、观察、想象、展示。</p>
<blockquote>
<p>当我们为商务演示准备某个图表的时候，我们会：</p>
<ul>
<li>看这个图表有哪些内容（比如说明性的词表索引、坐标轴、资料来源等）</li>
<li>然后观察这些数据有哪些特点（也许X轴增长的速度比Y轴快）</li>
<li>接着好好想想这些特点说明了什么问题（比如成本增长的速度远远高于利润的增长）</li>
<li>最后，信息满满地向听众展示自己的看法</li>
</ul>
</blockquote>
<h3 id="1-看"><a href="#1-看" class="headerlink" title="1. 看"></a>1. 看</h3><figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">看 </span>=<span class="string"> 收集 + 初选</span></div></pre></td></tr></table></figure>
<h3 id="2-观察"><a href="#2-观察" class="headerlink" title="2. 观察"></a>2. 观察</h3><figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">观察 </span>=<span class="string"> 选择 + 归类</span></div></pre></td></tr></table></figure>
<h3 id="3-想象"><a href="#3-想象" class="headerlink" title="3. 想象"></a>3. 想象</h3><figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">想象 </span>=<span class="string"> 看到那些并不在眼前的事物</span></div></pre></td></tr></table></figure>
<h3 id="4-展示"><a href="#4-展示" class="headerlink" title="4. 展示"></a>4. 展示</h3><figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">展示 </span>=<span class="string"> 让一切清楚明白</span></div></pre></td></tr></table></figure>
<p>　　虽然视觉化思考的四个步骤常常是按照次序自然地逐步推进，但是其实整个视觉化思考的过程运作起来，更像是一连串循环往复的程序，就像下面所示：<br><img src="/imgs/餐巾纸的背面-视觉化思考-步骤循环.jpg" width="600" height="250"><br>　　看和观察这两个步骤总是在不停地交替，并且相互支持。<br>　　想象则变成了一座桥梁，在一端，我们对进入脑海的视觉信息进行处理；在另一端，视觉创意在不断输出。<br>　　当我们开始向其他人展示自己的成果时，他们就会启动视觉化思考过程————看我们展示的图片，观察吸引他们的地方，想象他们该如何处理这些材料，还会对我们展示的东西进行修改。<br>　　视觉化思考的循环过程就会一遍一遍地重复下去。</p>
<h2 id="八、六个方法"><a href="#八、六个方法" class="headerlink" title="八、六个方法"></a>八、六个方法</h2><p>　　6个方法对应于上面所提到的视觉化思考的6个要素，也对应到后面<a href="">餐巾纸的背面（二）发现创意</a>的<code>六六法则</code>。</p>
<img src="/imgs/餐巾纸的背面-视觉化思考-6种方法.jpg" width="600" height="350">
<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>　<br><img src="/imgs/餐巾纸的背面-视觉化思考-导向绳.jpg" width="600" height="250"><br>上图是《餐巾纸的背面》一书的导向绳，顺应着该导向绳，进行视觉化思考的过程中，上述三个主题会频繁出现。</p>
<p>　本篇的主要内容对应于《餐巾纸的背面》的导言一章，对视觉化思考涉及到的进行进行了归纳总结。至于四个步骤的详细做法可以阅读<a href="http://zhangyuyu.github.io/2017/12/02/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%91%E7%8E%B0%E5%88%9B%E6%84%8F/" target="_blank" rel="external">餐巾纸的背面（二）发现创意</a>。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://www.jianshu.com/p/413c2acfe8b0" target="_blank" rel="external">关于视觉化思考的一些思考</a></li>
<li><a href="http://www.jianshu.com/p/cb39a06d95c2" target="_blank" rel="external">视觉化思维练习总结</a></li>
<li><a href="http://www.jianshu.com/p/55376a84d951" target="_blank" rel="external">视觉化思维，聪明人的选择</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;　　《餐巾纸的背面》不是告诉你如何成为一个画家，而是告诉你如何进行思考。将视觉化思考的观点，移植到你的工作、生活、交往、个人品牌规划以及你的一切中。学会用眼睛看待世界，用心思考世界，从而用笔与世界沟通。&lt;/p&gt;
&lt;img src=&quot;/imgs/餐巾纸的背面-视觉化思考-大纲.jpg&quot; width=&quot;500&quot; height=&quot;800&quot;&gt;
&lt;h2 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h2&gt;&lt;p&gt;　　转眼已经2017年的年底了，回顾这一年虽然看了不少书，但是却是边看边忘，边焦虑边放松，似乎每次都能给自己找到足够的借口来“堕落”，继而冠冕堂皇的继续“优雅地享受生活”。&lt;br&gt;　　上次的《Buddy Workshop》，顿似醍醐灌顶，让人不容小觑&lt;code&gt;输出&lt;/code&gt;的重要性；&lt;br&gt;　　邮件里面看到的《21天写工作坊》，蓦地振聋发聩，让人歆羡&lt;code&gt;坚持&lt;/code&gt;的点滴沉淀；&lt;br&gt;　　考虑年底的training budget的书籍，忽地豁然开朗，让人开始沉静下来总结些许。&lt;/p&gt;
&lt;h2 id=&quot;三、什么是视觉化思考&quot;&gt;&lt;a href=&quot;#三、什么是视觉化思考&quot; class=&quot;headerlink&quot; title=&quot;三、什么是视觉化思考&quot;&gt;&lt;/a&gt;三、什么是视觉化思考&lt;/h2&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="餐巾纸的背面" scheme="http://yoursite.com/tags/%E9%A4%90%E5%B7%BE%E7%BA%B8%E7%9A%84%E8%83%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Buddy Workshop</title>
    <link href="http://yoursite.com/2017/09/14/Buddy-workshop/"/>
    <id>http://yoursite.com/2017/09/14/Buddy-workshop/</id>
    <published>2017-09-14T14:02:53.000Z</published>
    <updated>2017-12-27T07:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>每个职场新人，初入职场时候，或多或少遇到了很多需要帮助的地方，有技术上的，有情绪上的，有环境上的，我们盼望着有一个“导师”能够引导、指导我们度过最开始的那段迷茫期。<br>抑或是，当换到一个新环境，开始一个崭新的工作，很多流程、机制、文化都难以快速适应，这时候如果有一个“老司机”带我们轻松度过最开始的那段适应期，真真是极好的。</p>
<p>每个人都曾度过这个阶段，每个人都有过期盼，那么如果你作为一个“导师”，你会怎么做呢？</p>
<p>本篇文章，不是从“职场小白”或“新入职同事”的角度出发，而是从“带人（Buddy）”的角度出发，了解一些“培养人这件事”中，可能需要知道的理论知识。</p>
<h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>在ThoughtWorks已经两年了，这中间虽然自己有在带新人，包括应届毕业生，社招进来的同事，但是一直没有系统的梳理过这中间需要的软技能，只是用以自己被带过的感受在努力带好新人，给他们营造良好的氛围、帮助他们更快的适应环境、督促或者指引他们持续学习、不断进步。</p>
<p>最近，参加了公司举办的一次Buddy Workshop，系统的梳理了Buddy应知应会的一些内容。</p>
<p>培训是让人快速完成一些重要理论知识从0到1的过程，而真正的从1到100的过程，还需要在未来的实践中不断前行。有些理论可能当下并没有那么深刻的感触，在以后的道路上才会感触颇多，因此以此博文记录一下要点，方便以后再次回忆。</p>
<p>具体内容分为以下几个方面：</p>
<ul>
<li>为什么要带人？</li>
<li>培养成什么样的人？</li>
<li>如何培养？</li>
<li>面对的挑战</li>
<li>构建完善的培养体系</li>
<li>练习<a id="more"></a>
</li>
</ul>
<h2 id="三、为什么要带人"><a href="#三、为什么要带人" class="headerlink" title="三、为什么要带人"></a>三、为什么要带人</h2><h3 id="1-提升自己的能力"><a href="#1-提升自己的能力" class="headerlink" title="1. 提升自己的能力"></a>1. 提升自己的能力</h3><p>正如Cone of experience（学习金字塔）里面告诉我们的，我们是通过“教“的过程才真正学会，而不是学好了才能去教。<br><img src="/imgs/buddy-cone-of-experience.png" width="500" height="250"></p>
<p>Teaching is Learning，这一点在费曼技巧里面也有一些体现。把教别人的过程作为帮助自己学习的过程。表面看起来是知识输出，但实际上这个过程还有额外的三个价值：</p>
<ul>
<li>因为要教别人，就会督促自己发现知识阻塞，进一步打通已有知识。</li>
<li>教别人的过程，是一个强化记忆和认识的过程</li>
<li>教别人之后，别人提出疑问、质疑和新想法，会增强我们的认识</li>
</ul>
<p>具体的对自己能力的提升，我列举了一些如下：</p>
<ul>
<li>自身对相应知识的掌握</li>
<li>知识的表达能力</li>
<li>沟通能力等软技能</li>
</ul>
<h3 id="2-构建组织环境"><a href="#2-构建组织环境" class="headerlink" title="2. 构建组织环境"></a>2. 构建组织环境</h3><p>我们工作都是以团队为单位的，站在团队的角度，我们不希望因为某一个人某段时间的离开，造成了交付的延迟，因此持续培养新人，让其慢慢承担我们所承担的事情，是非常重要的。<br>此外，在一个团队中，我们不可能一个人做所有的事情，在带人过程中，把自己的事情share出去，也是一个非常明智的选择。</p>
<h3 id="3-发展他人拥有我们希望具备的品质"><a href="#3-发展他人拥有我们希望具备的品质" class="headerlink" title="3. 发展他人拥有我们希望具备的品质"></a>3. 发展他人拥有我们希望具备的品质</h3><p>我们都希望和同事相处融洽，培养他们拥有我们希望具备的品质，能够增加合作默契等。<br>但是，这并不代表着，我们把他们全部培养成只适合这一家公司的人才，我们还要站在他们未来的角度，培养他们应当具备的品质，这一点在下面”培养成什么样的人“中会涉及到。</p>
<h2 id="四、培养成什么样的人"><a href="#四、培养成什么样的人" class="headerlink" title="四、培养成什么样的人"></a>四、培养成什么样的人</h2><p>在如今这个信息爆炸和知识爆炸的时代，我们需要不断的学习，不断的进步，以保持持续竞争力，来督促自己的成长，应对未知的变化，从而走向我们希望的生活，因此<strong>培养<u>终身学习</u>的<u>数字化人才</u></strong>就是我们培养的目标。</p>
<h3 id="1-终身学习"><a href="#1-终身学习" class="headerlink" title="1. 终身学习"></a>1. 终身学习</h3><p>“终身学习”是指持续的、自愿的和自我激励式的学习。“终身学习”不仅发生在童年时期或者教室中，而是贯穿人的一生，可以发生在任何时间、任何场合、任何条件下。学习的目的可以是为了个人发展，也可以是为了职业需要。﻿<br>终身学习有几个特点：</p>
<ul>
<li>持续</li>
<li>自愿</li>
<li>自我激励<br>更多终身学习内容，可以参考文末的Reference。</li>
</ul>
<h3 id="2-数字化人才"><a href="#2-数字化人才" class="headerlink" title="2. 数字化人才"></a>2. 数字化人才</h3><p>数字化人才的定义是以敏捷为核心，具备设计思维、商业视角和工程实践能力的人才。<br><img src="/imgs/buddy-digital-talent.png" width="500" height="250"></p>
<p>数字化人才既具备工程实现的能力，又有商业嗅觉，了解用户和市场，还有设计思维，知道如何一步步做出用户满意的产品。以敏捷的心态为基础：快速试错、持续改进。当今社会，想要取得成功，跨界能力显得愈发重要。</p>
<h2 id="五、如何培养"><a href="#五、如何培养" class="headerlink" title="五、如何培养"></a>五、如何培养</h2><p><strong>构建以<u>学习者为中心</u>的<u>可视化教学</u></strong></p>
<h3 id="1-少讲课、多辅导"><a href="#1-少讲课、多辅导" class="headerlink" title="1. 少讲课、多辅导"></a>1. 少讲课、多辅导</h3><p>讲课，老师是主角，它是一种告知行为；辅导，主角是学员自己，它带有训练性质。</p>
<p>以我切身的经验来看，讲课了很多东西，吸收到的只有一小部分，有些事情，讲了很多次，可能学习者都没有印象。反而，你讲的也累了，耐心也没有那么多了，学习者也怅惘了，自信心没有那么足了。<br>而辅导，你告诉他怎么找答案，不会的再来问你。那么久而久之，学习者学习的方式就自主了，掌握的知识更牢固了。</p>
<h3 id="2-验收"><a href="#2-验收" class="headerlink" title="2. 验收"></a>2. 验收</h3><p>验收机制顾名思义就是把我们学习过的知识重新整理一篇，看哪些是我们已经掌握好的，哪些是未能渗透掌握的，并以此加深巩固。</p>
<p>也许你还会觉得很陌生，但其实我们每个人都会有使用过验收机制：</p>
<ul>
<li>学校里接受教育时，不定期或定期的各种考试；</li>
<li>敏捷里写Story时，各种场景的Acceptance Criteria；</li>
<li>游戏里闯关时，每一关都要达到的标准。</li>
</ul>
<table>
<thead>
<tr>
<th>维度</th>
<th>可视化工具 </th>
</tr>
</thead>
<tbody>
<tr>
<td>知识储备</td>
<td>读书打卡  </td>
</tr>
<tr>
<td>概念掌握</td>
<td>概念图  </td>
</tr>
<tr>
<td>业务理解</td>
<td>业务蓝图  </td>
</tr>
<tr>
<td>任务拆分</td>
<td>Taksing  </td>
</tr>
<tr>
<td>技能掌握</td>
<td>限时编程  </td>
</tr>
<tr>
<td>持续改进</td>
<td>总结 / 述职 /5w2h</td>
</tr>
</tbody>
</table>
<h3 id="3-反馈"><a href="#3-反馈" class="headerlink" title="3. 反馈"></a>3. 反馈</h3><p>戴明循环（PDCA）讲究从计划开始，经过实践，再反思，产生的改进行动再纳入下一轮计划的持续改进过程。<br><img src="/imgs/buddy-pdca.png" width="500" height="250"></p>
<p>Plan - Do - Check - Action是持续改进提升的模型，这一套适用于很多方面，这里我们也可以用来不断改进我们的培养过程、以及锻炼学习过程。</p>
<h3 id="4-正确对待时间鸿沟与现实约束"><a href="#4-正确对待时间鸿沟与现实约束" class="headerlink" title="4. 正确对待时间鸿沟与现实约束"></a>4. 正确对待时间鸿沟与现实约束</h3><h4 id="德弗雷斯模型"><a href="#德弗雷斯模型" class="headerlink" title="德弗雷斯模型"></a>德弗雷斯模型</h4><p>德雷福斯模型（Dreyfus model of skill acquisition）概括了从新手到专家必须经历的 5 个阶段，每两个阶段之间都需要经历一定的时间，无法避免。因此在培养的时候，不能一蹴而就，要正确对待这个时间的鸿沟。</p>
<img src="/imgs/buddy-coaching-evolution.png" width="500" height="250">
<h4 id="一切能力的核心"><a href="#一切能力的核心" class="headerlink" title="一切能力的核心"></a>一切能力的核心</h4><p>公司同事曾经做过一个调查，具体内容是，到底是什么样的人，才是能够让我司每一个团队（注意，是每一个团队）都能说出“我愿意与他共事”的人呢？<br>经过大量的各种访谈，并对结果进行整理和记录，大致列出如下16个维度：</p>
<ul>
<li>努力程度</li>
<li>上进心</li>
<li>责任心</li>
<li>认真的做事态度</li>
<li>理解能力</li>
<li>表达能力</li>
<li>自学能力</li>
<li>英文能力</li>
<li>协作能力</li>
<li>改进速度</li>
<li>求知欲</li>
<li>主动性</li>
<li>文化契合度</li>
<li>正能量</li>
<li>分享精神</li>
<li>思维能力</li>
</ul>
<p>其实，最后总结下来，核心能力就是<strong>理解能力</strong>和<strong>表达能力</strong>，也就是我们的听、说、读、写的能力。而这些能力是在我们小学一、二年级时候建立的。<br>这个现实的约束，与我们成长的环境有关，我们无法从头再来，因此正确认识到这个现实约束，显得尤为关键。</p>
<h4 id="院校、企业在人员培养方面的区别"><a href="#院校、企业在人员培养方面的区别" class="headerlink" title="院校、企业在人员培养方面的区别"></a>院校、企业在人员培养方面的区别</h4><h2 id="六、面对的挑战"><a href="#六、面对的挑战" class="headerlink" title="六、面对的挑战"></a>六、面对的挑战</h2><h3 id="1-自身业务"><a href="#1-自身业务" class="headerlink" title="1. 自身业务"></a>1. 自身业务</h3><h3 id="2-发展他人"><a href="#2-发展他人" class="headerlink" title="2. 发展他人"></a>2. 发展他人</h3><p>由于 Buddy 的工作经验和带人技巧参差不齐，所以是否能够准确评价毕业生，是否能够高质量的提升毕业生水平，并不能达成一致效果，导致一部分毕业生缺乏方向，缺乏安全感，进步有限。</p>
<h3 id="3-缺少导师和可视化工具"><a href="#3-缺少导师和可视化工具" class="headerlink" title="3. 缺少导师和可视化工具"></a>3. 缺少导师和可视化工具</h3><h3 id="4-难以关注整体"><a href="#4-难以关注整体" class="headerlink" title="4. 难以关注整体"></a>4. 难以关注整体</h3><h2 id="七、构建完善的培养体系"><a href="#七、构建完善的培养体系" class="headerlink" title="七、构建完善的培养体系"></a>七、构建完善的培养体系</h2><h3 id="胜任力模型"><a href="#胜任力模型" class="headerlink" title="胜任力模型"></a>胜任力模型</h3><ul>
<li>Self Confidence（自信）</li>
<li>Developing Others（发展他人）</li>
<li>Delivering Customer Results（客户成果交付）</li>
<li>Technical Expertise（技术专长）</li>
</ul>
<h3 id="教头计划"><a href="#教头计划" class="headerlink" title="教头计划"></a>教头计划</h3><p>Buddy1.0  —专家组—&gt;  Buddy2.0 —技术系统—&gt; Buddy3.0</p>
<h2 id="八、练习"><a href="#八、练习" class="headerlink" title="八、练习"></a>八、练习</h2><h3 id="1-概念图"><a href="#1-概念图" class="headerlink" title="1. 概念图"></a>1. 概念图</h3><p>概念图是由概念，连接线和关注点组成。最小的单元是命题，命题由两个概念和一条连接线组成。它可以帮助我们把大脑中思考的事情用图来可视化。在这里可以帮助我们查看新人对事物的理解。如果新人的表达能力描述不清，借此辅助。<br>我们可以借助工具CmapTools进行概念图的绘制：<br><img src="/imgs/buddy-cmap-json.png" width="500" height="250"><br><a href="https://school.thoughtworks.cn:8341/rid=1RRC78MYB-1X88GJ7-PV6/JSON.cmap" target="_blank" rel="external">原cmap文件地址</a></p>
<h3 id="2-Tasking"><a href="#2-Tasking" class="headerlink" title="2. Tasking"></a>2. Tasking</h3><p>强调程序的输入和输出。</p>
<h3 id="3-反馈与倾听"><a href="#3-反馈与倾听" class="headerlink" title="3. 反馈与倾听"></a>3. 反馈与倾听</h3><h4 id="区分观察和评论"><a href="#区分观察和评论" class="headerlink" title="区分观察和评论"></a>区分观察和评论</h4><h4 id="区分感受和想法"><a href="#区分感受和想法" class="headerlink" title="区分感受和想法"></a>区分感受和想法</h4><h4 id="需要和感受的关系"><a href="#需要和感受的关系" class="headerlink" title="需要和感受的关系"></a>需要和感受的关系</h4><h4 id="区分请求和命令"><a href="#区分请求和命令" class="headerlink" title="区分请求和命令"></a>区分请求和命令</h4><p>最后最对这个话题，有兴趣的同学可以看一下两本书《非暴力沟通》、《关键对话》。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文系统的记录了此次培训的要点，和涉及到的练习。<br>此外，讲师在描述自己如何带buddy的时候提出了几点也很重要：</p>
<ul>
<li>阅读习惯的培养（<a href="http://www.jianshu.com/p/0cb14cbe3432" target="_blank" rel="external">思特沃克学院阅读习惯培养推荐书单</a>）</li>
<li>如何反思（5W1H、5Why）</li>
<li>反思的顺序（事实 -&gt; 矛盾 -&gt; 问题 -&gt; 观点）</li>
<li>Action（PDCA、SMART原则）</li>
<li>述职/总结（过去一个月的工作内容、回顾与反思、我有哪些问题或疑惑 ）</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://jiaching.com/%E6%95%99%E5%B0%B1%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%E5%AD%B8%E2%94%82%E6%AD%A3%E7%A2%BA%E7%9A%84%E5%AD%B8%E7%BF%92%E4%B9%8B%E9%81%93/" target="_blank" rel="external">教就是最好的学</a></li>
<li><a href="http://www.jianshu.com/p/15e3e774d6b9" target="_blank" rel="external">好好学习</a></li>
<li><a href="https://mp.weixin.qq.com/s/lz3Y237k3hNmb4zCusZNkw" target="_blank" rel="external">10个终身学习方法</a></li>
<li><a href="https://school.thoughtworks.cn/" target="_blank" rel="external">思沃学院</a></li>
<li><a href="http://www.jianshu.com/p/f196468e0203" target="_blank" rel="external">如何培养终身学习者</a></li>
<li><a href="http://www.360doc.com/content/16/0721/12/132526_577268647.shtml" target="_blank" rel="external">费曼技巧</a></li>
<li><a href="http://www.jianshu.com/p/8b62d8788c72" target="_blank" rel="external">开启我的奇妙人生的八个思考模型工具</a></li>
<li><a href="https://www.zybuluo.com/flysmart/note/213521" target="_blank" rel="external">德雷福斯模型</a></li>
<li><a href="https://www.zybuluo.com/jtong/note/504192" target="_blank" rel="external">像机器人一样思考 系列文章</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;每个职场新人，初入职场时候，或多或少遇到了很多需要帮助的地方，有技术上的，有情绪上的，有环境上的，我们盼望着有一个“导师”能够引导、指导我们度过最开始的那段迷茫期。&lt;br&gt;抑或是，当换到一个新环境，开始一个崭新的工作，很多流程、机制、文化都难以快速适应，这时候如果有一个“老司机”带我们轻松度过最开始的那段适应期，真真是极好的。&lt;/p&gt;
&lt;p&gt;每个人都曾度过这个阶段，每个人都有过期盼，那么如果你作为一个“导师”，你会怎么做呢？&lt;/p&gt;
&lt;p&gt;本篇文章，不是从“职场小白”或“新入职同事”的角度出发，而是从“带人（Buddy）”的角度出发，了解一些“培养人这件事”中，可能需要知道的理论知识。&lt;/p&gt;
&lt;h2 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h2&gt;&lt;p&gt;在ThoughtWorks已经两年了，这中间虽然自己有在带新人，包括应届毕业生，社招进来的同事，但是一直没有系统的梳理过这中间需要的软技能，只是用以自己被带过的感受在努力带好新人，给他们营造良好的氛围、帮助他们更快的适应环境、督促或者指引他们持续学习、不断进步。&lt;/p&gt;
&lt;p&gt;最近，参加了公司举办的一次Buddy Workshop，系统的梳理了Buddy应知应会的一些内容。&lt;/p&gt;
&lt;p&gt;培训是让人快速完成一些重要理论知识从0到1的过程，而真正的从1到100的过程，还需要在未来的实践中不断前行。有些理论可能当下并没有那么深刻的感触，在以后的道路上才会感触颇多，因此以此博文记录一下要点，方便以后再次回忆。&lt;/p&gt;
&lt;p&gt;具体内容分为以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么要带人？&lt;/li&gt;
&lt;li&gt;培养成什么样的人？&lt;/li&gt;
&lt;li&gt;如何培养？&lt;/li&gt;
&lt;li&gt;面对的挑战&lt;/li&gt;
&lt;li&gt;构建完善的培养体系&lt;/li&gt;
&lt;li&gt;练习
    
    </summary>
    
      <category term="Others" scheme="http://yoursite.com/categories/Others/"/>
    
    
      <category term="培训" scheme="http://yoursite.com/tags/%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Slf4j MDC使用和基于Logback的实现分析</title>
    <link href="http://yoursite.com/2017/08/17/Log-Slf4j%20MDC%20%E4%BD%BF%E7%94%A8%E5%92%8C%E5%9F%BA%E4%BA%8E%20Logback%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2017/08/17/Log-Slf4j MDC 使用和基于 Logback的实现/</id>
    <published>2017-08-17T06:01:52.000Z</published>
    <updated>2017-12-27T07:15:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>　　上一篇<a href="http://zhangyuyu.github.io/2017/08/17/Log-Java%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/" target="_blank" rel="external">Java日志管理</a>里面对Java相关的日志库进行了梳理，了解了常见的日志框架（Log Implement）和日志门面(Log Facade)。</p>
<ul>
<li>使用日志门面，开发者只需要针对门面接口开发，而调用组件的应用程序则可以搭配自己喜好的日志实现工具，目前来看Slf4j + LogBack组合方式是比较通用的方式。</li>
<li>对于web应用而言，多线程的调用是很常见的，我们可能需要对一个用户的操作流程进行归类标记，用来区分哪个行为和哪个日志事件有关，MDC则很好的处理这个需求。</li>
</ul>
<p>本篇将介绍Slf4j + LogBack的组合方式，介绍MDC的使用，并结合源码对实现原理进行分析。</p>
<h3 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h3><p>　　起源于最近看到项目使用了MDC，好奇这是个什么东西的情况下，系统的了解了Java的日志管理，并借此机会分析其实现原理，记录下来，理清思路。</p>
<a id="more"></a>
<h3 id="三、Slf4j-MDC-介绍"><a href="#三、Slf4j-MDC-介绍" class="headerlink" title="三、Slf4j MDC 介绍"></a>三、Slf4j MDC 介绍</h3><p>　　介绍Slf4j和MDC的由来，可以参考上一篇<a href="http://zhangyuyu.github.io/2017/08/17/Log-Java%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/" target="_blank" rel="external">Java日志管理</a>。</p>
<h4 id="1-Slf4j是什么？"><a href="#1-Slf4j是什么？" class="headerlink" title="1. Slf4j是什么？"></a>1. Slf4j是什么？</h4><p>　　Slf4j全称为Simple Logging Facade for Java (简单日志门面)，作为各种日志框架的简单门面或者抽象，包括JUL，Log4j，Logback。SLF4J允许用户在部署期间加入自己希望使用的日志系统。其实Slf4j与Log4j, Logback都是同一作者。</p>
<h4 id="2-MDC是什么"><a href="#2-MDC是什么" class="headerlink" title="2. MDC是什么?"></a>2. MDC是什么?</h4><p>　　MDC全称为Mapped Diagnostic Context（映射调试上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的功能。<br>　　典型的例子是 Web 应用服务器。当用户访问某个页面时，应用服务器可能会创建一个新的线程来处理该请求，也可能从线程池中复用已有的线程。在一个用户的会话存续期间，可能有多个线程处理过该用户的请求。这使得比较难以区分不同用户所对应的日志。当需要追踪某个用户在系统中的相关日志记录时，就会变得很麻烦。</p>
<blockquote>
<p>　　虽然，Slf4j 是用来适配其他的日志具体实现包的，但是针对 MDC功能，目前只有Logback 以及 Log4j 支持。</p>
</blockquote>
<h4 id="3-MDC的简单使用"><a href="#3-MDC的简单使用" class="headerlink" title="3. MDC的简单使用"></a>3. MDC的简单使用</h4><h5 id="3-1-使用MDC"><a href="#3-1-使用MDC" class="headerlink" title="3.1 使用MDC"></a>3.1 使用MDC</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package com.daimler.otr;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> org.slf4j.MDC;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> logger = <span class="type">LoggerFactory</span>.getLogger(<span class="type">LogTest</span>.<span class="keyword">class</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</div><div class="line">        <span class="type">MDC</span>.put(<span class="string">"THREAD_ID"</span>, <span class="type">String</span>.valueOf(<span class="type">Thread</span>.currentThread().getId()));</div><div class="line">        logger.info(<span class="string">"纯字符串信息的info级别日志"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-2-logback的配置"><a href="#3-2-logback的配置" class="headerlink" title="3.2 logback的配置"></a>3.2 logback的配置</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></div><div class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d<span class="template-variable">&#123;yyyy-MM-dd HH:mm:ss&#125;</span><span class="xml"> %highlight(%-5p) %logger.%M\(%F:%L\)] %X</span><span class="template-variable">&#123;THREAD_ID&#125;</span><span class="xml"> %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="3-3-运行结果"><a href="#3-3-运行结果" class="headerlink" title="3.3 运行结果"></a>3.3 运行结果</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">2017</span>-<span class="number">08</span>-<span class="number">24</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">17</span> INFO  com<span class="selector-class">.daimler</span><span class="selector-class">.otr</span><span class="selector-class">.LogTest</span><span class="selector-class">.main</span>(LogTest<span class="selector-class">.java</span>:<span class="number">13</span>)] <span class="number">1</span> 纯字符串信息的info级别日志</div></pre></td></tr></table></figure>
<h5 id="3-4-其他说明"><a href="#3-4-其他说明" class="headerlink" title="3.4 其他说明"></a>3.4 其他说明</h5><p>在笔者的web项目中，是将MDC的操作放在Filter中，对所有请求前进行filter拦截，然后加上自定义的唯一标识到MDC中，就可以在所有日志输出中，清楚看到某用户的操作流程。</p>
<ol>
<li><p>首先有一个单独的MDCRegister定义了对于key需要的put操作。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class MDCRegister &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> registerUUID(<span class="keyword">String</span> requestId)&#123;</div><div class="line">        MDC.<span class="built_in">put</span>(<span class="string">"uuid"</span>, requestId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> registerModuleName(<span class="keyword">String</span> requestUri)&#123;</div><div class="line">        MDC.<span class="built_in">put</span>(<span class="string">"module_name"</span>, requestUri);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> registerUserName(<span class="keyword">String</span> userName)&#123;</div><div class="line">        MDC.<span class="built_in">put</span>(<span class="string">"user_name"</span>, userName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> registerAppVersion(<span class="keyword">String</span> appVersion)&#123;</div><div class="line">        MDC.<span class="built_in">put</span>(<span class="string">"app_version"</span>, appVersion);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> registerSessionID(<span class="keyword">String</span> token)&#123;</div><div class="line">        <span class="keyword">String</span> sessionID = Base64.encodeBase64String((token + <span class="string">"300Fi67wJ4A4E0h"</span>).getBytes()).substring(<span class="number">0</span>, <span class="number">8</span>);</div><div class="line">        MDC.<span class="built_in">put</span>(<span class="string">"session_id"</span>, sessionID);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> registerLogInformationFromRequest(<span class="keyword">String</span> token, <span class="keyword">String</span> requestId, <span class="keyword">String</span> appVersion, <span class="keyword">String</span> requestUri)&#123;</div><div class="line">        MDC.<span class="built_in">clear</span>();</div><div class="line">        registerUUID(requestId);</div><div class="line">        registerAppVersion(appVersion);</div><div class="line">        registerSessionID(token);</div><div class="line">        registerModuleName(requestUri);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>然后自定义Filter，使用MDC相关操作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CustomAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AbstractPreAuthenticatedProcessingFilter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> <span class="type">MDCRegister</span> mdcRegister;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="type">Object</span> getPreAuthenticatedPrincipal(<span class="type">HttpServletRequest</span> request) &#123;</div><div class="line">        <span class="type">String</span> token = getRequestToken(request);</div><div class="line">        <span class="type">String</span> requestID = request.getHeader(<span class="string">"X-SERVICE-REQUEST-ID"</span>);</div><div class="line">        <span class="type">String</span> appVersion = request.getHeader(<span class="string">"X-CLIENT-VERSION"</span>);</div><div class="line">        <span class="type">String</span> requestUri = request.getRequestURI();</div><div class="line">        <span class="type">String</span> sessionId = token;</div><div class="line">       </div><div class="line">        mdcRegister.registerLogInformationFromRequest(sessionId, requestID, appVersion, requestUri);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义logback.xml中的pattern</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span>[<span class="string">V</span>][<span class="symbol">%d</span>][<span class="string">%-5p</span>][<span class="symbol">%t</span>][<span class="string">%c&#123;0&#125;</span>][<span class="symbol">%M</span>][<span class="string">%X&#123;uuid&#125;</span>][<span class="symbol">%X&#123;app_version&#125;</span>][<span class="string">%X&#123;user_name&#125;</span>][<span class="symbol">%X&#123;session_id&#125;</span>] - %m%n<span class="xml"><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span></div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>在日志模板logback.xml 中，使用 %X{ }来占位，替换到对应的 MDC 中 key 的值。</p>
</blockquote>
<h3 id="四、Log-MDC-实现分析"><a href="#四、Log-MDC-实现分析" class="headerlink" title="四、Log MDC 实现分析"></a>四、Log MDC 实现分析</h3><h4 id="1-Slf4j-MDC-实现分析"><a href="#1-Slf4j-MDC-实现分析" class="headerlink" title="1. Slf4j MDC 实现分析"></a>1. Slf4j MDC 实现分析</h4><p>查看Slf4j MDC的实现源码，可以发现Slf4j MDC内部实现很简单：实现一个单例对应实例，获取具体的MDC实现类，然后其对外接口，就是对参数进行校验，然后调用 MDCAdapter 的方法实现。</p>
<p>如下只显示了与mdcAdapter相关的Slf4j MDC源码：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class MDC &#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> MDCAdapter mdcAdapter;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> MDC() &#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mdcAdapter = bwCompatibleGetMDCAdapterFromBinder();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> put(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">String</span> val) <span class="keyword">throws</span> IllegalArgumentException &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key parameter cannot be null"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mdcAdapter == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"MDCAdapter cannot be null. See also "</span> + NULL_MDCA_URL);</div><div class="line">        &#125;</div><div class="line">        mdcAdapter.put(<span class="built_in">key</span>, val);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) <span class="keyword">throws</span> IllegalArgumentException &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key parameter cannot be null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mdcAdapter == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"MDCAdapter cannot be null. See also "</span> + NULL_MDCA_URL);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mdcAdapter.<span class="built_in">get</span>(<span class="built_in">key</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> remove(<span class="keyword">String</span> <span class="built_in">key</span>) <span class="keyword">throws</span> IllegalArgumentException &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key parameter cannot be null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mdcAdapter == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"MDCAdapter cannot be null. See also "</span> + NULL_MDCA_URL);</div><div class="line">        &#125;</div><div class="line">        mdcAdapter.remove(<span class="built_in">key</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">clear</span>() &#123;</div><div class="line">        <span class="keyword">if</span> (mdcAdapter == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"MDCAdapter cannot be null. See also "</span> + NULL_MDCA_URL);</div><div class="line">        &#125;</div><div class="line">        mdcAdapter.<span class="built_in">clear</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MDCAdapter getMDCAdapter() &#123;</div><div class="line">        <span class="keyword">return</span> mdcAdapter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>MDCAdapter接口源码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> interface MDCAdapter &#123;</div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> put(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">String</span> val);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">String</span> <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> remove(<span class="keyword">String</span> <span class="built_in">key</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">clear</span>();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; getCopyOfContextMap();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setContextMap(Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; contextMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-Logback-MDC-实现分析"><a href="#2-Logback-MDC-实现分析" class="headerlink" title="2. Logback MDC 实现分析"></a>2. Logback MDC 实现分析</h4><p>Logback 中，用LogbackMDCAdapter实现了Sl4j里面的MDCAdapter接口。<br>下面是get 和 put 的代码实现：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class LogbackMDCAdapter implements MDCAdapter &#123;</div><div class="line">    <span class="keyword">final</span> ThreadLocal&lt;Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;&gt; copyOnThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> WRITE_OPERATION = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> MAP_COPY_OPERATION = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; lastOperation = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Integer getAndSetLastOperation(<span class="built_in">int</span> op) &#123;</div><div class="line">        Integer lastOp = lastOperation.<span class="built_in">get</span>();</div><div class="line">        lastOperation.<span class="built_in">set</span>(op);</div><div class="line">        <span class="keyword">return</span> lastOp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="built_in">boolean</span> wasLastOpReadOrNull(Integer lastOp) &#123;</div><div class="line">        <span class="keyword">return</span> lastOp == <span class="keyword">null</span> || lastOp.intValue() == MAP_COPY_OPERATION;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; duplicateAndInsertNewMap(Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; oldMap) &#123;</div><div class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; newMap = Collections.synchronizedMap(<span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;());</div><div class="line">        <span class="keyword">if</span> (oldMap != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// we don't want the parent thread modifying oldMap while we are</span></div><div class="line">            <span class="comment">// iterating over it</span></div><div class="line">            <span class="keyword">synchronized</span> (oldMap) &#123;</div><div class="line">                newMap.putAll(oldMap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        copyOnThreadLocal.<span class="built_in">set</span>(newMap);</div><div class="line">        <span class="keyword">return</span> newMap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> put(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">String</span> val) <span class="keyword">throws</span> IllegalArgumentException &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"key cannot be null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; oldMap = copyOnThreadLocal.<span class="built_in">get</span>();</div><div class="line">        Integer lastOp = getAndSetLastOperation(WRITE_OPERATION);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (wasLastOpReadOrNull(lastOp) || oldMap == <span class="keyword">null</span>) &#123;</div><div class="line">            Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; newMap = duplicateAndInsertNewMap(oldMap);</div><div class="line">            newMap.put(<span class="built_in">key</span>, val);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            oldMap.put(<span class="built_in">key</span>, val);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">String</span> <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</div><div class="line">        <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = copyOnThreadLocal.<span class="built_in">get</span>();</div><div class="line">        <span class="keyword">if</span> ((<span class="built_in">map</span> != <span class="keyword">null</span>) &amp;&amp; (<span class="built_in">key</span> != <span class="keyword">null</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="五、-Logback-日志输出实现"><a href="#五、-Logback-日志输出实现" class="headerlink" title="五、 Logback 日志输出实现"></a>五、 Logback 日志输出实现</h3><p>MDC 的功能实现很简单，就是在线程上下文中，维护一个 Map<string,string> 属性来支持日志输出的时候，当我们在配置文件logback.xml中配置了%X{key}，则后台日志打印出对应的 key 的值。</string,string></p>
<h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><p>所谓初始化，就是我们构建logger的时候。在LoggerFactory.getLogger()，调用的是 slf4j 的方法，而底层使用的是logback的实现。因此，初始化的重点就是找到底层具体的实现接口，然后构建具体类。</p>
<p>Sl4j中LoggerFactory如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.slf4j;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerFactory</span> &#123;</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger getLogger(String name) &#123;</div><div class="line">        ILoggerFactory iLoggerFactory = getILoggerFactory();</div><div class="line">        <span class="keyword">return</span> iLoggerFactory.getLogger(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ILoggerFactory getILoggerFactory() &#123;</div><div class="line">        <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (LoggerFactory.<span class="keyword">class</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class="line">                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;</div><div class="line">                    performInitialization();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">switch</span> (INITIALIZATION_STATE) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">SUCCESSFUL_INITIALIZATION:</span></div><div class="line">            <span class="keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();</div><div class="line">        <span class="keyword">case</span> <span class="string">NOP_FALLBACK_INITIALIZATION:</span></div><div class="line">            <span class="keyword">return</span> NOP_FALLBACK_FACTORY;</div><div class="line">        <span class="keyword">case</span> <span class="string">FAILED_INITIALIZATION:</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(UNSUCCESSFUL_INIT_MSG);</div><div class="line">        <span class="keyword">case</span> <span class="string">ONGOING_INITIALIZATION:</span></div><div class="line">            <span class="keyword">return</span> SUBST_FACTORY;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unreachable code"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> performInitialization() &#123;</div><div class="line">        bind();</div><div class="line">        <span class="keyword">if</span> (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) &#123;</div><div class="line">            versionSanityCheck();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> bind() &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">if</span> (!isAndroid()) &#123;</div><div class="line">                staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();</div><div class="line">                reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// the next line does the binding</span></div><div class="line">            StaticLoggerBinder.getSingleton();</div><div class="line">            INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</div><div class="line">            reportActualBinding(staticLoggerBinderPathSet);</div><div class="line">            fixSubstituteLoggers();</div><div class="line">            replayEvents();</div><div class="line">            SUBST_FACTORY.clear();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</div><div class="line">            ...  </div><div class="line">        &#125; <span class="keyword">catch</span> (java.lang.NoSuchMethodError nsme) &#123;</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String STATIC_LOGGER_BINDER_PATH = <span class="string">"org/slf4j/impl/StaticLoggerBinder.class"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的部分代码，可以很明显看出，slf4j 会去调用classloader获取当前加载的类中，实现了指定的接口<code>org/slf4j/impl/StaticLoggerBinder.class</code>的类，如果多余1个，则会抛出异常。</p>
<p>直接在自己的包中实现一个和Slf4j要求路径一样的类，实现对应的接口，然后就可以调用了。</p>
<p>例如Logback中，则实现了一个 org.slf4j.impl.StaticLoggerBinder 类，而这个类，在上面的Slf4j的LogFactory中直接被使用<code>StaticLoggerBinder.getSingleton();</code></p>
<p>Logback中StaticLoggerBinder如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">package org.slf4j.impl;</div><div class="line"></div><div class="line"><span class="keyword">import</span> ch.qos.logback.core.status.StatusUtil;</div><div class="line"><span class="keyword">import</span> org.slf4j.ILoggerFactory;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> org.slf4j.helpers.Util;</div><div class="line"><span class="keyword">import</span> org.slf4j.spi.LoggerFactoryBinder;</div><div class="line"></div><div class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</div><div class="line"><span class="keyword">import</span> ch.qos.logback.classic.util.ContextInitializer;</div><div class="line"><span class="keyword">import</span> ch.qos.logback.classic.util.ContextSelectorStaticBinder;</div><div class="line"><span class="keyword">import</span> ch.qos.logback.core.CoreConstants;</div><div class="line"><span class="keyword">import</span> ch.qos.logback.core.joran.spi.JoranException;</div><div class="line"><span class="keyword">import</span> ch.qos.logback.core.util.StatusPrinter;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticLoggerBinder</span> <span class="title">implements</span> <span class="title">LoggerFactoryBinder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StaticLoggerBinder</span> <span class="type">SINGLETON</span> = new <span class="type">StaticLoggerBinder</span>();</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="type">SINGLETON</span>.<span class="keyword">init</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="type">LoggerContext</span> defaultLoggerContext = new <span class="type">LoggerContext</span>();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ContextSelectorStaticBinder</span> contextSelectorBinder = <span class="type">ContextSelectorStaticBinder</span>.getSingleton();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="type">StaticLoggerBinder</span>() &#123;</div><div class="line">        defaultLoggerContext.setName(<span class="type">CoreConstants</span>.<span class="type">DEFAULT_CONTEXT_NAME</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">StaticLoggerBinder</span> getSingleton() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">SINGLETON</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                new <span class="type">ContextInitializer</span>(defaultLoggerContext).autoConfig();</div><div class="line">            &#125; <span class="keyword">catch</span> (<span class="type">JoranException</span> je) &#123;</div><div class="line">               ...</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">Throwable</span> t) &#123;</div><div class="line">           ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-输出日志模板解析"><a href="#2-输出日志模板解析" class="headerlink" title="2. 输出日志模板解析"></a>2. 输出日志模板解析</h4><p>关于logback.xml的解析工作，也是在初始化的时候完成的。</p>
<p>2.1 首先StaticLoggerBinder.init()会执行ContextInitializer的autoConfig():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextInitializer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autoConfig</span><span class="params">()</span> <span class="keyword">throws</span> JoranException </span>&#123;</div><div class="line">            StatusListenerConfigHelper.installIfAsked(loggerContext);</div><div class="line">            URL url = findURLOfDefaultConfigurationFile(<span class="keyword">true</span>);</div><div class="line">            <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</div><div class="line">                configureByResource(url);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureByResource</span><span class="params">(URL url)</span> <span class="keyword">throws</span> JoranException </span>&#123;</div><div class="line">            ...</div><div class="line">            <span class="keyword">if</span> (urlString.endsWith(<span class="string">"groovy"</span>)) &#123;</div><div class="line">               ...</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (urlString.endsWith(<span class="string">"xml"</span>)) &#123;</div><div class="line">                JoranConfigurator configurator = <span class="keyword">new</span> JoranConfigurator();</div><div class="line">                configurator.setContext(loggerContext);</div><div class="line">                configurator.doConfigure(url);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.2 此后，会执行GenericConfigurator的下述doConfigure方法：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">doConfigure</span><span class="params">(<span class="keyword">final</span> List&lt;SaxEvent&gt; eventList)</span> <span class="keyword">throws</span> JoranException </span>&#123;</div><div class="line">        buildInterpreter();</div><div class="line">        <span class="comment">// disallow simultaneous configurations of the same context</span></div><div class="line">        <span class="keyword">synchronized</span> (context.getConfigurationLock()) &#123;</div><div class="line">            interpreter.getEventPlayer().play(eventList);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>2.3 紧接着，执行EventPlayer的play方法，解析xml：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void play(List&lt;SaxEvent&gt; aSaxEventList) &#123;</div><div class="line">       event<span class="class">List = aSaxEventList;</span></div><div class="line">       SaxEvent se;</div><div class="line">       for (currentIndex = 0; currentIndex &lt; eventList.size(); currentIndex++) &#123;</div><div class="line">           se = eventList.get(currentIndex);</div><div class="line"></div><div class="line">          <span class="built_in"> if </span>(se instanceof StartEvent) &#123;</div><div class="line">               interpreter.startElement((StartEvent) se);</div><div class="line">               //<span class="built_in"> invoke </span>fireInPlay after startElement processing</div><div class="line">               interpreter.getInterpretationContext().fireInPlay(se);</div><div class="line">           &#125;</div><div class="line">          <span class="built_in"> if </span>(se instanceof BodyEvent) &#123;</div><div class="line">               //<span class="built_in"> invoke </span>fireInPlay before characters processing</div><div class="line">               interpreter.getInterpretationContext().fireInPlay(se);</div><div class="line">               interpreter.characters((BodyEvent) se);</div><div class="line">           &#125;</div><div class="line">          <span class="built_in"> if </span>(se instanceof EndEvent) &#123;</div><div class="line">               //<span class="built_in"> invoke </span>fireInPlay before endElement processing</div><div class="line">               interpreter.getInterpretationContext().fireInPlay(se);</div><div class="line">               interpreter.endElement((EndEvent) se);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在 Logback 中，解析xml的工作，最后都是交给 Action 和其继承类来完成。在 Action 类中提供了三个方法begin、body和end三个方法，这三个抽象方法中：</p>
<ul>
<li>begin 方法负责处理ElementSelector元素的解析；</li>
<li>body 方法，一般为空，处理文本的；</li>
<li>end 方法则是处理模板解析的，所以我们的Logback.xml的模板解析实在end方法中。具体是在 NestedComplexPropertyIA类中来解析。其继承Action类，并且其会调用具体的模板解析工具类：PatternLayoutEncoder类和PatternLayout类。</li>
</ul>
<p>2.4 PatternLayoutEncoder会创建一个PatternLayout对象，然后获取到logback.xml中配置的模板字符串，即<code>[%d{yyyy-MM-dd HH:mm:ss} %highlight(%-5p) %logger.%M\(%F:%L\)] %X{THREAD_ID} %msg%n</code>，如配置的节点名一样，其在代码中同样赋值给pattern变量。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PatternLayoutEncoder</span> <span class="keyword">extends</span> <span class="title">PatternLayoutEncoderBase&lt;ILoggingEvent&gt;</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    public void start() &#123;</div><div class="line">        <span class="type">PatternLayout</span> patternLayout = <span class="keyword">new</span> <span class="type">PatternLayout</span>();</div><div class="line">        patternLayout.setContext(context);</div><div class="line">        patternLayout.setPattern(getPattern());</div><div class="line">        patternLayout.setOutputPatternAsHeader(outputPatternAsHeader);</div><div class="line">        patternLayout.start();</div><div class="line">        <span class="keyword">this</span>.layout = patternLayout;</div><div class="line">        <span class="keyword">super</span>.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PatternLayoutEncoder会执行start()方法，然后调用相关方法对pattern进行解析，然后构建一个节点链表，保存这个链表会在日志输出的时使用到。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (pattern == <span class="keyword">null</span> || pattern.length() == <span class="number">0</span>) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Parser&lt;E&gt; p = <span class="keyword">new</span> Parser&lt;E&gt;(pattern);</div><div class="line">        <span class="keyword">if</span> (getContext() != <span class="keyword">null</span>) &#123;</div><div class="line">            p.setContext(getContext());</div><div class="line">        &#125;</div><div class="line">        Node t = p.parse();</div><div class="line">        <span class="keyword">this</span>.head = p.compile(t, getEffectiveConverterMap());</div><div class="line">        ...</div><div class="line">    &#125; <span class="keyword">catch</span> (ScanException sce) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.5 Parse依次遍历pattern字符串，然后把符合要求的字符串放进tokenList中，这个list就维护了我们最终需要输出的模板的格式化模式了。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Parser(<span class="keyword">String</span> pattern, IEscapeUtil escapeUtil) throws ScanException &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        TokenStream ts = <span class="keyword">new</span> <span class="type">TokenStream</span>(pattern, escapeUtil);</div><div class="line">        <span class="built_in">this</span>.tokenList = ts.tokenize();</div><div class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException npe) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ScanException</span>(<span class="string">"Failed to initialize Parser"</span>, npe);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.6 Compiler会将这个tokenList进行转换，成为我们需要的Node类型的拥有head 和 tail 的链表。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">ContextAwareBase</span> </span>&#123;</div><div class="line">     <span class="type">Converter</span>&lt;<span class="type">E</span>&gt; compile() &#123;</div><div class="line">        head = tail = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="type">Node</span> n = top; n != <span class="literal">null</span>; n = n.next) &#123;</div><div class="line">            switch (n.<span class="keyword">type</span>) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="type">Node</span>.<span class="type">LITERAL</span>:</div><div class="line">                addToList(<span class="keyword">new</span> <span class="type">LiteralConverter</span>&lt;<span class="type">E</span>&gt;((<span class="type">String</span>) n.getValue()));</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="type">Node</span>.<span class="type">COMPOSITE_KEYWORD</span>:</div><div class="line">                <span class="type">CompositeNode</span> cn = (<span class="type">CompositeNode</span>) n;</div><div class="line">                <span class="type">CompositeConverter</span>&lt;<span class="type">E</span>&gt; compositeConverter = createCompositeConverter(cn);</div><div class="line">                <span class="keyword">if</span> (compositeConverter == <span class="literal">null</span>) &#123;</div><div class="line">                    addError(<span class="string">"Failed to create converter for [%"</span> + cn.getValue() + <span class="string">"] keyword"</span>);</div><div class="line">                    addToList(<span class="keyword">new</span> <span class="type">LiteralConverter</span>&lt;<span class="type">E</span>&gt;(<span class="string">"%PARSER_ERROR["</span> + cn.getValue() + <span class="string">"]"</span>));</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                compositeConverter.setFormattingInfo(cn.getFormatInfo());</div><div class="line">                compositeConverter.setOptionList(cn.getOptions());</div><div class="line">                <span class="type">Compiler</span>&lt;<span class="type">E</span>&gt; childCompiler = <span class="keyword">new</span> <span class="type">Compiler</span>&lt;<span class="type">E</span>&gt;(cn.getChildNode(), converterMap);</div><div class="line">                childCompiler.setContext(context);</div><div class="line">                <span class="type">Converter</span>&lt;<span class="type">E</span>&gt; childConverter = childCompiler.compile();</div><div class="line">                compositeConverter.setChildConverter(childConverter);</div><div class="line">                addToList(compositeConverter);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="type">Node</span>.<span class="type">SIMPLE_KEYWORD</span>:</div><div class="line">                <span class="type">SimpleKeywordNode</span> kn = (<span class="type">SimpleKeywordNode</span>) n;</div><div class="line">                <span class="type">DynamicConverter</span>&lt;<span class="type">E</span>&gt; dynaConverter = createConverter(kn);</div><div class="line">                <span class="keyword">if</span> (dynaConverter != <span class="literal">null</span>) &#123;</div><div class="line">                    dynaConverter.setFormattingInfo(kn.getFormatInfo());</div><div class="line">                    dynaConverter.setOptionList(kn.getOptions());</div><div class="line">                    addToList(dynaConverter);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// if the appropriate dynaconverter cannot be found, then replace</span></div><div class="line">                    <span class="comment">// it with a dummy LiteralConverter indicating an error.</span></div><div class="line">                    <span class="type">Converter</span>&lt;<span class="type">E</span>&gt; errConveter = <span class="keyword">new</span> <span class="type">LiteralConverter</span>&lt;<span class="type">E</span>&gt;(<span class="string">"%PARSER_ERROR["</span> + kn.getValue() + <span class="string">"]"</span>);</div><div class="line">                    addStatus(<span class="keyword">new</span> <span class="type">ErrorStatus</span>(<span class="string">"["</span> + kn.getValue() + <span class="string">"] is not a valid conversion word"</span>, <span class="keyword">this</span>));</div><div class="line">                    addToList(errConveter);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-日志输出分析"><a href="#3-日志输出分析" class="headerlink" title="3. 日志输出分析"></a>3. 日志输出分析</h4><p>前面部分进行了初始化配置，紧接着在<code>logger.info()</code>的时候，就可以根据初始化得到的Node链表head来解析，遇到%X的时候，从MDC中获取对应的key值，然后append到日志字符串中，然后输出。</p>
<p>3.1 Logger会执行buildLoggingEventAndAppend方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">slf4j</span>.<span class="title">Logger</span>, <span class="title">LocationAwareLogger</span>, <span class="title">AppenderAttachable</span>&lt;<span class="title">ILoggingEvent</span>&gt;, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">filterAndLog_0_Or3Plus</span><span class="params">(<span class="keyword">final</span> String localFQCN, <span class="keyword">final</span> Marker marker, <span class="keyword">final</span> Level level, <span class="keyword">final</span> String msg, <span class="keyword">final</span> Object[] params,</span></span></div><div class="line">                        <span class="keyword">final</span> Throwable t) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> FilterReply decision = loggerContext.getTurboFilterChainDecision_0_3OrMore(marker, <span class="keyword">this</span>, level, msg, params, t);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (decision == FilterReply.NEUTRAL) &#123;</div><div class="line">                <span class="keyword">if</span> (effectiveLevelInt &gt; level.levelInt) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(decision == FilterReply.DENY)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            buildLoggingEventAndAppend(localFQCN, marker, level, msg, params, t);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">buildLoggingEventAndAppend</span><span class="params">(<span class="keyword">final</span> String localFQCN, <span class="keyword">final</span> Marker marker, <span class="keyword">final</span> Level level, <span class="keyword">final</span> String msg, <span class="keyword">final</span> Object[] params,</span></span></div><div class="line">                        <span class="keyword">final</span> Throwable t) &#123;</div><div class="line">            LoggingEvent le = <span class="keyword">new</span> LoggingEvent(localFQCN, <span class="keyword">this</span>, level, msg, t, params);</div><div class="line">            le.setMarker(marker);</div><div class="line">            callAppenders(le);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">callAppenders</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> writes = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (Logger l = <span class="keyword">this</span>; l != <span class="keyword">null</span>; l = l.parent) &#123;</div><div class="line">            writes += l.appendLoopOnAppenders(event);</div><div class="line">            <span class="keyword">if</span> (!l.additive) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// No appenders in hierarchy</span></div><div class="line">        <span class="keyword">if</span> (writes == <span class="number">0</span>) &#123;</div><div class="line">            loggerContext.noAppenderDefinedWarning(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">int</span> <span class="title">appendLoopOnAppenders</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (aai != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="function"><span class="keyword">return</span> aai.<span class="title">appendLoopOnAppenders</span><span class="params">(event)</span></span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.2 继而调用OutputStreamAppender的append方法（由于配置文件配置的是Appender模式）<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamAppender&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">UnsynchronizedAppenderBase&lt;E&gt;</span> </span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void append(<span class="type">E</span> eventObject) &#123;</div><div class="line">        <span class="keyword">if</span> (!isStarted()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        subAppend(eventObject);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">  <span class="keyword">protected</span> void subAppend(<span class="type">E</span> event) &#123;</div><div class="line">        <span class="keyword">if</span> (!isStarted()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (event instanceof <span class="type">DeferredProcessingAware</span>) &#123;</div><div class="line">                ((<span class="type">DeferredProcessingAware</span>) event).prepareForDeferredProcessing();</div><div class="line">            &#125;</div><div class="line">            lock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                writeOut(event);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">IOException</span> ioe) &#123;</div><div class="line">            <span class="keyword">this</span>.started = <span class="literal">false</span>;</div><div class="line">            addStatus(<span class="keyword">new</span> <span class="type">ErrorStatus</span>(<span class="string">"IO failure in appender"</span>, <span class="keyword">this</span>, ioe));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">protected</span> void writeOut(<span class="type">E</span> event) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</div><div class="line">        <span class="keyword">this</span>.encoder.doEncode(event);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>3.3 按照模板获取值然后转换成字节流输出到后台<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doEncode</span>(<span class="params">E <span class="keyword">event</span></span>) throws IOException </span>&#123;</div><div class="line">    String txt = layout.doLayout(<span class="keyword">event</span>);</div><div class="line">    outputStream.write(convertToBytes(txt));</div><div class="line">    <span class="keyword">if</span> (immediateFlush)</div><div class="line">        outputStream.flush();</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doLayout</span>(<span class="params">ILoggingEvent <span class="keyword">event</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isStarted()) &#123;</div><div class="line">        <span class="keyword">return</span> CoreConstants.EMPTY_STRING;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> writeLoopOnConverters(<span class="keyword">event</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这里的head是上述2.4里面PatternLayoutEncoder里面start方法之中得到的。</span></div><div class="line"><span class="comment">// 这里输出就是按照解析后的链表进行分析输出的。然后根据c类型不同，获取字符串方法也不同</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">writeLoopOnConverters</span>(<span class="params">E <span class="keyword">event</span></span>) </span>&#123;</div><div class="line">    StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</div><div class="line">    Converter&lt;E&gt; c = head;</div><div class="line">    <span class="keyword">while</span> (c != <span class="literal">null</span>) &#123;</div><div class="line">        c.write(buf, <span class="keyword">event</span>);</div><div class="line">        c = c.getNext();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> buf.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在writeLoopOnConverters方法中，获取对应字符串是不同的，其根据不同的Converter，输出也不同。而Converter的判断，时就是根据我们配置的map映射来的。</p>
<p>3.4 MDCConverter的convert实现:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MDCConverter</span> <span class="keyword">extends</span> <span class="title">ClassicConverter</span> </span>&#123;</div><div class="line">    public <span class="type">String</span> convert(<span class="type">ILoggingEvent</span> event) &#123;</div><div class="line">        <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; mdcPropertyMap = event.getMDCPropertyMap();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mdcPropertyMap == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> defaultValue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> outputMDCForAllKeys(mdcPropertyMap);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            <span class="type">String</span> value = event.getMDCPropertyMap().get(key);</div><div class="line">            <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> value;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> defaultValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是LoggingEvent中的getMDCPropertyMap，可以看到转换类型是LogbackMDCAdapter。<br>因此，上述event.getMDCPropertyMap().get(key)就可以从LogbackMDCAdapter（MDC Logback实现）中调用get方法了。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public Map&lt;String, String&gt; getMDCPropertyMap() &#123;</div><div class="line">        // populate mdcPropertyMap <span class="keyword">if</span> <span class="literal">null</span></div><div class="line">        <span class="keyword">if</span> (<span class="attr">mdcPropertyMap</span> == <span class="literal">null</span>) &#123;</div><div class="line">            MDCAdapter <span class="attr">mdc</span> = MDC.getMDCAdapter();</div><div class="line">            <span class="keyword">if</span> (mdc instanceof LogbackMDCAdapter)</div><div class="line">                <span class="attr">mdcPropertyMap</span> = ((LogbackMDCAdapter) mdc).getPropertyMap();</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="attr">mdcPropertyMap</span> = mdc.getCopyOfContextMap();</div><div class="line">        &#125;</div><div class="line">        // mdcPropertyMap still <span class="literal">null</span>, use emptyMap()</div><div class="line">        <span class="keyword">if</span> (<span class="attr">mdcPropertyMap</span> == <span class="literal">null</span>)</div><div class="line">            <span class="attr">mdcPropertyMap</span> = Collections.emptyMap();</div><div class="line"></div><div class="line">        return mdcPropertyMap;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>自此，伴随着从SLF4J到Logback的运行流程，介绍了Logback MDC的使用：</p>
<ul>
<li>从LoggerFactory.getLogger()讲起</li>
<li>初始化找到底层具体的实现接口</li>
<li>日志模板解析</li>
<li>logger.info()实际调用</li>
<li>日志输出（打印MDC对应key的value）</li>
</ul>
<h3 id="六、Reference"><a href="#六、Reference" class="headerlink" title="六、Reference"></a>六、Reference</h3><ul>
<li><a href="https://ketao1989.github.io/2015/04/29/LogBack-Implemention-And-Slf4j-Mdc/" target="_blank" rel="external">Slf4j MDC 使用和 基于 Logback 的实现分析</a></li>
<li><a href="http://www.importnew.com/16331.html" target="_blank" rel="external">Java日志终极指南</a></li>
<li><a href="https://my.oschina.net/dabird/blog/821868" target="_blank" rel="external">https://my.oschina.net/dabird/blog/821868</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;　　上一篇&lt;a href=&quot;http://zhangyuyu.github.io/2017/08/17/Log-Java%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java日志管理&lt;/a&gt;里面对Java相关的日志库进行了梳理，了解了常见的日志框架（Log Implement）和日志门面(Log Facade)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用日志门面，开发者只需要针对门面接口开发，而调用组件的应用程序则可以搭配自己喜好的日志实现工具，目前来看Slf4j + LogBack组合方式是比较通用的方式。&lt;/li&gt;
&lt;li&gt;对于web应用而言，多线程的调用是很常见的，我们可能需要对一个用户的操作流程进行归类标记，用来区分哪个行为和哪个日志事件有关，MDC则很好的处理这个需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇将介绍Slf4j + LogBack的组合方式，介绍MDC的使用，并结合源码对实现原理进行分析。&lt;/p&gt;
&lt;h3 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h3&gt;&lt;p&gt;　　起源于最近看到项目使用了MDC，好奇这是个什么东西的情况下，系统的了解了Java的日志管理，并借此机会分析其实现原理，记录下来，理清思路。&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java日志管理</title>
    <link href="http://yoursite.com/2017/08/17/Log-Java%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/08/17/Log-Java日志管理/</id>
    <published>2017-08-17T05:53:47.000Z</published>
    <updated>2017-12-27T07:16:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>日志是所有软件系统非常重要的一部分；良好统一的日志规范和严格执行会大大提高系统的可维护性、可用性、可靠性，并进而提高开发效率，指导业务。</p>
<ul>
<li>过程监控－－通过分析程序的执行过程，用于验证程序的执行是否按照既定的方式运行。</li>
<li>问题定位－－通过查看程序错误日志的详细信息以及产生位置，迅速定位问题产生的原因。</li>
<li>业务指导，通过统计和分析相关的业务、用户行为日志，对业务进行预测指导。</li>
<li>数据恢复－－通过反向执行过程日志，可以将数据可以会滚到之前的状态。</li>
<li>健康检查以及系统优化－－通过查看系统日志，确定程序运行的健康状况，调节系统参数，优化程序性能。</li>
</ul>
<h3 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h3><p>猛地发现自己一直错误地把Sl4j和java.util.logging、Logback、Log4j理解为同一层次的概念。<br>继而查了相关的资料，站在更高一层，理解一下Java的日志管理相关的框架————Log4j、JUL、JCL、Slf4j、Logback 、Log4j2。</p>
<img src="/imgs/java-log-frameworks.png" width="500" height="350">
<p>分为两个层次的概念：</p>
<ul>
<li>日志框架(Implement)：日志系统是日志的具体实现。如Log4j、java.util.Logging、Logback、Log4j2。</li>
<li>日志门面（Facade）：为了解决多个日志系统的兼容问题，日志门面应运而生。如Commons logging和Slf4j。</li>
</ul>
<a id="more"></a>
<h3 id="三、Java常见日志库的历史"><a href="#三、Java常见日志库的历史" class="headerlink" title="三、Java常见日志库的历史"></a>三、Java常见日志库的历史</h3><p>Logging frameworks出现之前（Java 1.3及以前），Java打日志依赖System.out.println()，System.err.println()或者e.printStackTrace()。Debug日志被写入STDOUT流,错误日志被写入STDERR流。</p>
<p>Logging frameworks的出现：<br>先来一幅图从整体上看一下Java常见日志库的时间先后顺序：<br><img src="/imgs/java-log-history.png" width="500" height="350"></p>
<h4 id="1-Log4j"><a href="#1-Log4j" class="headerlink" title="1. Log4j"></a>1. Log4j</h4><p>Log4j可以说是一个里程碑式的框架，它提出的一些基本理念，深深地影响了后来者，直至今天，这些理念也依然在被广泛使用：</p>
<ul>
<li>Logger－－Logger负责捕捉事件并将其发送给合适的Appender。</li>
<li>Appender－－也被称为Handler，负责将日志事件记录到目标位置。在将日志事件输出之前，Appenders使用Layouts来对事件进行格式化处理。</li>
<li>Layout－－也被称为Formatter，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式。</li>
</ul>
<h4 id="2-Java-Util-Log"><a href="#2-Java-Util-Log" class="headerlink" title="2. Java Util Log"></a>2. Java Util Log</h4><p>Sun公司开始意识到JDK需要一个记录日志的特性。受Log4j的启发，Sun在Java 1.4版本中引入了一个新的API, 叫java.util.logging, 但是，JUL功能远不如Log4j完善，如果开发者要使用它，就意味着需要自己写Appenders(Sun称它为Handlers)，而且，只有两个Handlers可被使用：Console和File，这就意味着，开发者只能将日志写入Console和文件。</p>
<blockquote>
<p>如前面所述，JUL在Java 1.4才被引入，在这之前，并没有官方的日志库供开发者使用。于是便有了很多日志相关的”轮子”。我想这应该是当前会有如此多日志框架的一个很重要的原因。</p>
</blockquote>
<h4 id="3-Commons-Logging"><a href="#3-Commons-Logging" class="headerlink" title="3. Commons Logging"></a>3. Commons Logging</h4><p>由于项目的日志打印必然依赖以上两个框架中至少一个，无论是jul还是Log4j,开发者必须去两个都配置。这时候，Apache的Commons logging（Jakarta Commons Logging）出现了。<br>它的主要作用是提供一个日志门面，使用者可以使用不同的日志实现。用户可以自由选择第三方的日志组件作为具体实现（Log4j或JUL），JCL会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。JCL内部有一个Simple logger的简单实现，但是功能很弱。</p>
<h4 id="4-Slf4j"><a href="#4-Slf4j" class="headerlink" title="4. Slf4j"></a>4. Slf4j</h4><p>JCL是在运行期间查找符合条件的日志类，然后使用类加载的方式加载指定的日志类。这种机制带来了不可预见的后果，如类加载问题，这会让开发者遇到各种奇怪的问题，增加了调试的困难度。<br>也正是因为如此，Log4j 的作者发起了另一个项目，也就是 Slf4j（Simple Logging Facade for JAVA）。<br>Slf4j 同 JCL类似，也是提供了一个公共的接口，开发者只需要关注接口，不用关心下层实现。同时 Slf4j 的实现只要遵循这个接口，就可以做到各个日志系统之间的无缝兼容。</p>
<h4 id="5-Logback"><a href="#5-Logback" class="headerlink" title="5. Logback"></a>5. Logback</h4><p>Logback是Slf4j接口的一套具体实现，又是同一个作者，因而保证了其和Log4j相近的使用方式，也具有Slf4j的全部特性。</p>
<p>现在我们有了两个流行的 Log Facade，以及三个流行的 Log Implementation。Gülcü 是个追求完美的人，他决定让这些Log之间都能够方便的互相替换，所以做了各种 Adapter 和 Bridge 来连接。<br><img src="/imgs/java-log-adapter-bridge1.png" width="500" height="350"></p>
<blockquote>
<p>在这里需要注意不能搞出循环的桥接，比如下面这些依赖就不能同时存在:</p>
<ul>
<li>jcl-over-slf4j 和 slf4j-jcl</li>
<li>log4j-over-slf4j 和 slf4j-log4j12</li>
<li>jul-to-slf4j 和 slf4j-jdk14</li>
</ul>
</blockquote>
<h4 id="6-Log4j2"><a href="#6-Log4j2" class="headerlink" title="6. Log4j2"></a>6. Log4j2</h4><p>Log4j2 是 Log4j、Slf4j、Logback 的作者的又一个作品，它对 Log4j 做了很大的改进，提供了多种现代特性，而且它的异步性能优越，在分布式系统中性能要远好于 Logback，同时也支持 Slf4j 与 JCL。<br>Log4j2 也做了 Facade/Implementation 分离的设计，分成了 log4j-api 和 log4j-core。</p>
<p>现在好了，我们有了三个流行的Log Facade和四个流行的Log Implementation，这时候桥接关系的图如下图：<br><img src="/imgs/java-log-adapter-bridge2.png" width="500" height="350"></p>
<h3 id="四、Java-日志框架对比"><a href="#四、Java-日志框架对比" class="headerlink" title="四、Java 日志框架对比"></a>四、Java 日志框架对比</h3><p>这里主要讲述一下几个日志框架（Log4j、JUL、Logback、Log4j2）的对比。</p>
<h4 id="1-Log4j-VS-JUL"><a href="#1-Log4j-VS-JUL" class="headerlink" title="1. Log4j VS JUL"></a>1. Log4j VS JUL</h4><ul>
<li><p>处理器<br>JUL包含4种具体的handler的实现，而Log4j则包括超过12个的appender实现。<br>JUL的handler足够用来进行基本的日志记录 - 他们允许你写入到一个buffer，一个console，一个socket，和一个file中。Log4j的appenders，另一方面，大概覆盖了所有logging输出目的地你可以想到的。他们可以写到NT日志或者Unix syslog中，或者甚至发送Email。</p>
</li>
<li><p>格式化器<br>JUL包含了两个格式化类：XMLFormatter和SimpleFormatter。Log4j包含了对应的布局器:XMLLayout和SimpleLayout.Log4j还提供了TTCCLayout，它格式化LoggingEvents到富内容字符串，和HTMLLayout，它可格式化LoggingEvent到HMTL表格中。</p>
</li>
</ul>
<h4 id="2-Logback-VS-Log4j"><a href="#2-Logback-VS-Log4j" class="headerlink" title="2. Logback VS Log4j"></a>2. Logback VS Log4j</h4><p>Logback当前分成三个模块：logback-core,logback- classic和logback-access:</p>
<ul>
<li>logback-core是其它两个模块的基础模块。</li>
<li>logback-classic是log4j的一个改良版本。此外logback-classic完整实现Slf4j API使你可以很方便地更换成其它日记系统如Log4j或JDK14 Logging。</li>
<li>logback-access访问模块与Servlet容器集成提供通过Http来访问日记的功能。 </li>
</ul>
<h4 id="3-Log4j2-VS-Logback"><a href="#3-Log4j2-VS-Logback" class="headerlink" title="3. Log4j2 VS Logback"></a>3. Log4j2 VS Logback</h4><p>Log4j2是Log4j的升级版，与之前的版本Log4j 1.x相比、有重大的改进，在修正了Logback固有的架构问题的同时，改进了许多Logback所具有的功能。log4j2与log4j1发生了很大的变化，不兼容。</p>
<ul>
<li><p>性能<br>由于采用了更先进的锁机制和LMAX Disruptor库，Log4j2的性能优于Logback，特别是在多线程环境下和使用异步日志的环境下。</p>
</li>
<li><p>垃圾<br>Log4j2实现了“无垃圾”和“低垃圾”模式。Log4j2在记录日志时，能够重用对象（如String等），尽可能避免实例化新的临时对象，减少因日志记录产生的垃圾对象，减少垃圾回收带来的性能下降。<br>Logback能够自动压缩/删除旧日志。</p>
</li>
<li><p>与Slf4j的适配<br>二者都能够适配Slf4j，Logback与Slf4j的适配应该会更好一些，毕竟省掉了一层适配库</p>
</li>
</ul>
<h3 id="五、Java-日志门面对比"><a href="#五、Java-日志门面对比" class="headerlink" title="五、Java 日志门面对比"></a>五、Java 日志门面对比</h3><p>这里主要对比一下日志门面Commons logging和Slf4j：</p>
<p>Common logging通过<em>动态查找</em>的机制，在程序运行时自动找出真正使用的日志库。由于它使用了ClassLoader寻找和载入底层的日志库， 导致了象OSGI这样的框架无法正常工作，因为OSGI的不同的插件使用自己的ClassLoader。 OSGI的这种机制保证了插件互相独立，然而却使Apache Common-Logging无法工作。</p>
<p>Slf4j在编译时<em>静态绑定</em>真正的Log库,因此可以在OSGI中使用。另外，Slf4j 支持参数化的log字符串，避免了之前为了减少字符串拼接的性能损耗而不得不写的if(logger.isDebugEnable())，现在你可以直接写：logger.debug(“current user is: {}”, user)。拼装消息被推迟到了它能够确定是不是要显示这条消息的时候，但是获取参数的代价并没有幸免。</p>
<h3 id="六、日志框架与日志门面组合"><a href="#六、日志框架与日志门面组合" class="headerlink" title="六、日志框架与日志门面组合"></a>六、日志框架与日志门面组合</h3><p>使用日志门面可以方便的切换具体的日志实现。而且如果依赖多个项目，使用了不同的Log Facade，还可以方便的通过Adapter 转接到同一个实现上。 因此为了考虑扩展性，一般我们在程序开发的时候，会选择使用commons-logging或者slf4j这些日志门面，而不是直接使用log4j或者logback这些实现。</p>
<p>以下是几种比较常见的日志方案组合：</p>
<h4 id="1-JCL-Log4j"><a href="#1-JCL-Log4j" class="headerlink" title="1. JCL + Log4j"></a>1. JCL + Log4j</h4><p>需要的jar包：</p>
<ul>
<li>commons-logging</li>
<li>log4j</li>
</ul>
<h4 id="2-Slf4j-Logback"><a href="#2-Slf4j-Logback" class="headerlink" title="2. Slf4j + Logback"></a>2. Slf4j + Logback</h4><p>需要的jar包：</p>
<ul>
<li>slf4j-api</li>
<li>logback-core</li>
<li>logback-classic(集成包)</li>
</ul>
<h4 id="3-Log4j2"><a href="#3-Log4j2" class="headerlink" title="3. Log4j2"></a>3. Log4j2</h4><p>Log4j2需要的jar分成2个：</p>
<ul>
<li>log4j-api： 作为日志接口层，用于统一底层日志系统</li>
<li>log4j-core : 作为上述日志接口的实现，是一个实际的日志框架</li>
</ul>
<h4 id="4-JCL-log4j2"><a href="#4-JCL-log4j2" class="headerlink" title="4. JCL + log4j2"></a>4. JCL + log4j2</h4><p>需要的jar包：</p>
<ul>
<li>commons-logging</li>
<li>log4j-api</li>
<li>log4j-core</li>
<li>log4j-jcl（log4j2与commons-logging的集成包）</li>
</ul>
<p>现在的方式JCL + Log4j组合在性能和部分功能上都比较弱，如果要改进可以考虑以下几点：</p>
<ul>
<li>考虑性能和占位符等功能方面<br>推荐slf4j + logback方式 或者log4j2方式，这种方式对现有系统迁移改动较大，无论是代码内log声明还是配置文件上，而且slf4j不支持fatal打印；</li>
<li>考虑系统迁移性<br>推荐commons-logging+log4j2,代码不需要改动，只需要改动对应log4j配置文件即可，但是无法利用其占位符功能；</li>
<li>新系统搭建<br>不涉及到系统迁移的情况，新系统搭建可以采用纯log4j2方式，其既提供了接口也提供了实现，在性能上也得到了比较大提升。</li>
</ul>
<h3 id="七、NDC、MDC、ThreadContext"><a href="#七、NDC、MDC、ThreadContext" class="headerlink" title="七、NDC、MDC、ThreadContext"></a>七、NDC、MDC、ThreadContext</h3><p>当处理多线程应用程序，特别是web服务时，跟踪事件可能会变得困难。当针对多个同时存在的多个用户生成日志记录时，你如何区分哪个行为和哪个日志事件有关呢？如何两个用户没有成功打开一个相同的文件，或者在同一时间没有成功登陆，那么怎么处理日志记录？你可能需要一种方式来将日志记录和程序中的唯一标示符关联起来，这些标识符可能是用户ID，会话ID或者设备ID。而这就是NDC、MDC以及ThreadContext的用武之地。</p>
<p>NDC、MDC和ThreadContext通过向单独的日志记录中添加独一无二的数据戳，来创建日志足迹（log trails）。这些数据戳也被称为鱼标记（fish tagging），我们可以通过一个或者多个独一无二的值来区分日志。这些数据戳在每个线程级别上进行管理，并且一直持续到线程结束，或者直到数据戳被删掉。例如，如果你的Web应用程序为每个用户生成一个新的线程，那么你可以使用这个用户的ID来标记日志记录。当你想在一个复杂的系统中跟踪特定的请求、事务或者用户，这是一种非常有用的方法。</p>
<h4 id="1-NDC"><a href="#1-NDC" class="headerlink" title="1. NDC"></a>1. NDC</h4><p>NDC或者嵌套诊断上下文（Nested Diagnostic Context）是基于栈的思想，信息可以被放到栈上或者从栈中移除。而栈中的值可以被Logger访问，并且Logger无需显示想日志方法中传入任何值。</p>
<ul>
<li>NDC.push()方法将值存储在栈中；</li>
<li>NDC.pop()方法将一些项从栈中移除；</li>
<li>NDC.remove()方法让Java回收内存，以免造成内存溢出。</li>
</ul>
<h4 id="2-MDC"><a href="#2-MDC" class="headerlink" title="2. MDC"></a>2. MDC</h4><p>MDC或者映射诊断上下文和NDC很相似，不同之处在于MDC将值存储在键值对中，而不是栈中。这样你可以很容易的在Layout中引用一个单独的键。</p>
<ul>
<li>MDC.put(key,value) 方法将一个新的键值对添加到上下文中；</li>
<li>MDC.remove(key) 方法会移除指定的键值对；</li>
<li>MDC.clear()方法将所有的键值对从MDC中移除，这样会降低内存的使用量，并阻止MDC在后面试图调用那些已经过期的数据。</li>
</ul>
<blockquote>
<p>Slf4j 只有 MDC，没有 NDC<br>Logback内置没有实现NDC，但是slf4j-ext包提供了一个NDC实现，它使用MDC作为基础。</p>
</blockquote>
<h4 id="3-ThreadContext"><a href="#3-ThreadContext" class="headerlink" title="3. ThreadContext"></a>3. ThreadContext</h4><blockquote>
<p>Log4j版本2中将MDC和NDC合并到一个单独的组件中，这个组件被称为ThreadContext(线程上下文)。</p>
</blockquote>
<p>ThreadContext可以看成是NDC和MDC的结合体，它分别用<code>Thread Context Stack</code>和<code>Thread Context Map</code>来表示<code>NDC</code>和<code>MDC</code>。</p>
<ul>
<li>ThreadContext.clearStack()，清除NDC；</li>
<li>ThreadContext.clearMap()，清除MDC；</li>
<li>ThreadContext.clearAll()，清除所有。</li>
</ul>
<h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>本文从日志的好处讲起，先总体上概述了日志相关库分为：日志框架和日志门面；然后按照时间顺序列举了这些日志常见库；随后对它们进行简单的对比；提出了几个常见的日之框架与日志门面的组合使用；最后提到了NDC、MDC、ThreadContext的概念为<a href="http://zhangyuyu.github.io/2017/08/17/Log-Slf4j%20MDC%20%E4%BD%BF%E7%94%A8%E5%92%8C%E5%9F%BA%E4%BA%8E%20Logback%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">下一篇文章</a>提供一点理论基础。<br>针对每个库更详细的特性或者具体的使用步骤，大家可以自行去对应的官网查看。</p>
<h3 id="九、Reference"><a href="#九、Reference" class="headerlink" title="九、Reference"></a>九、Reference</h3><ul>
<li><a href="http://patchouli-know.com/2017/04/08/java-log/" target="_blank" rel="external">Java 日志系统梳理</a></li>
<li><a href="http://group.jobbole.com/30249/" target="_blank" rel="external">聊一聊那些年我们用过的 Java 日志框架</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/" target="_blank" rel="external">Java 日志管理最佳实践</a></li>
<li><a href="http://blog.csdn.net/yycdaizi/article/details/8276265" target="_blank" rel="external">Java日志组件介绍</a></li>
<li><a href="http://blog.csdn.net/gaojiaweir0011/article/details/8217604" target="_blank" rel="external">Log4j 对比 java.util.logging</a></li>
<li><a href="http://dev.sei.pku.edu.cn/trac/pkuas/blog/2011/04/06/zhanglei09/my_topic" target="_blank" rel="external">Log4J与Java Logging调研</a></li>
<li><a href="http://tech.lede.com/2017/02/06/rd/server/log4jSearch/" target="_blank" rel="external">日志工具现状调研</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-usertrack/index.html" target="_blank" rel="external">在Web 应用中增加用户跟踪功能</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;日志是所有软件系统非常重要的一部分；良好统一的日志规范和严格执行会大大提高系统的可维护性、可用性、可靠性，并进而提高开发效率，指导业务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过程监控－－通过分析程序的执行过程，用于验证程序的执行是否按照既定的方式运行。&lt;/li&gt;
&lt;li&gt;问题定位－－通过查看程序错误日志的详细信息以及产生位置，迅速定位问题产生的原因。&lt;/li&gt;
&lt;li&gt;业务指导，通过统计和分析相关的业务、用户行为日志，对业务进行预测指导。&lt;/li&gt;
&lt;li&gt;数据恢复－－通过反向执行过程日志，可以将数据可以会滚到之前的状态。&lt;/li&gt;
&lt;li&gt;健康检查以及系统优化－－通过查看系统日志，确定程序运行的健康状况，调节系统参数，优化程序性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h3&gt;&lt;p&gt;猛地发现自己一直错误地把Sl4j和java.util.logging、Logback、Log4j理解为同一层次的概念。&lt;br&gt;继而查了相关的资料，站在更高一层，理解一下Java的日志管理相关的框架————Log4j、JUL、JCL、Slf4j、Logback 、Log4j2。&lt;/p&gt;
&lt;img src=&quot;/imgs/java-log-frameworks.png&quot; width=&quot;500&quot; height=&quot;350&quot;&gt;
&lt;p&gt;分为两个层次的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志框架(Implement)：日志系统是日志的具体实现。如Log4j、java.util.Logging、Logback、Log4j2。&lt;/li&gt;
&lt;li&gt;日志门面（Facade）：为了解决多个日志系统的兼容问题，日志门面应运而生。如Commons logging和Slf4j。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Docker Workshop（六）Docker安全</title>
    <link href="http://yoursite.com/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2017/07/20/Docker-workshop-6-Docker安全/</id>
    <published>2017-07-20T00:49:15.000Z</published>
    <updated>2017-12-27T07:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">上一篇 Docker网络</a>主要讲述了网络模型、网络模式。<br>本篇将讲述Docker安全性体现在哪些方面，并探讨每个方面的最佳实践。</p>
<h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">容器简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">Docker简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">Docker的基本操作</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">Docker数据存储</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">Docker网络</a></li>
<li><strong>Docker安全</strong></li>
<li>多主机部署</li>
<li>服务发现</li>
<li>日志、跟踪、监控</li>
</ul>
<h2 id="三、Docker访问主机系统"><a href="#三、Docker访问主机系统" class="headerlink" title="三、Docker访问主机系统"></a>三、Docker访问主机系统</h2><p>很多时候，我们启动Docker容器时都以root用户权限在运行。那么，如果有ROOT权限可以做什么呢？当然可以做很多的事情，比如：访问所有信息、修改任何内容、关闭机器、结束进程以及安装各种软件等。<br><a id="more"></a></p>
<h3 id="【练习】访问主机系统"><a href="#【练习】访问主机系统" class="headerlink" title="【练习】访问主机系统"></a>【练习】访问主机系统</h3><p>1）主机上访问文件系统</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/shadow  # 使用普通用户访问</div><div class="line">cat: /etc/shadow: Permission denied</div><div class="line">$ who am i<span class="comment">; groups;  # 查看当前的用户和组</span></div><div class="line">vagrant  pts/<span class="number">0</span>        <span class="number">2017-09-14</span> <span class="number">08</span>:<span class="number">08</span> (<span class="number">10.0.2.2</span>)</div><div class="line">vagrant docker</div><div class="line">$ sudo cat /etc/shadow  # 使用root用户访问</div><div class="line">root:$<span class="number">6</span>$HmunRCSU$YXNgfbnj2AQVtJS8DWFqb2ZxXIFGp3eRXMbXtuF9XUfgkAD1X8o2cQxBK6SHEH/K6D77PYMuv9p7rVtjAFfmh<span class="number">0:16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">daemon:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">bin:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">sys:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">sync:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">games:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">man:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">...</div></pre></td></tr></table></figure>
<p>2) Docker容器里访问文件系统</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker run -v /:/hostfs busybox cat /hostfs/etc/shadow</div><div class="line">root:$<span class="number">6</span>$HmunRCSU$YXNgfbnj2AQVtJS8DWFqb2ZxXIFGp3eRXMbXtuF9XUfgkAD1X8o2cQxBK6SHEH/K6D77PYMuv9p7rVtjAFfmh<span class="number">0:16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">daemon:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">bin:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">sys:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">sync:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">games:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">man:*:<span class="number">16744:0</span>:<span class="number">99999:7</span>:::</div><div class="line">...</div></pre></td></tr></table></figure>
<p>可以看出只有root用户才能访问上面的文件。而Docker容器是用root权限运行的，所以在docker group下的用户间接地就有了root权限，也就可以访问到上述文件了。</p>
<p>3）Docker容器里修改主机文件系统</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls / | grep threat</div><div class="line">$ docker <span class="built_in">run</span> -<span class="keyword">it</span> -v /:/hostfs busybox touch /hostfs/threat-<span class="keyword">on</span>-<span class="keyword">the</span>-way</div><div class="line">$ ls / | grep threat</div><div class="line">threat-<span class="keyword">on</span>-<span class="keyword">the</span>-way</div></pre></td></tr></table></figure>
<p>可以看到，在Docker容器中创建的文件出现在了宿主机中，即在Docker容器中能够修改主机文件系统。</p>
<p>更严重的时，如果是 Privileged 容器，即在运行容器时指定–privileged=true参数，则能够允许容器所有设备执行任意操作，能够读写内核内存/proc/kcore，使用参数–net=host可以嗅探主机所有网络流量。</p>
<p>4）查看Docker容器和Metadata在宿主机上存储的地址</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ll /var/lib/docker/</div><div class="line">total 84</div><div class="line">drwxr-xr-x  <span class="number"> 9 </span>root root <span class="number"> 4096 </span>Sep<span class="number"> 14 </span>12:24 ./</div><div class="line">drwxr-xr-x <span class="number"> 52 </span>root root <span class="number"> 4096 </span>Nov<span class="number"> 22 </span><span class="number"> 2015 </span>../</div><div class="line">drwxr-xr-x  <span class="number"> 5 </span>root root <span class="number"> 4096 </span>Nov<span class="number"> 22 </span><span class="number"> 2015 </span>aufs/</div><div class="line">drwx------  <span class="number"> 8 </span>root root <span class="number"> 4096 </span>Sep<span class="number"> 14 </span>12:24 containers/</div><div class="line">drwx------<span class="number"> 259 </span>root root<span class="number"> 36864 </span>Sep<span class="number"> 14 </span>08:10 graph/</div><div class="line">-rw-r--r--  <span class="number"> 1 </span>root root <span class="number"> 5120 </span>Sep<span class="number"> 14 </span>12:24 linkgraph.db</div><div class="line">drwxr-x---  <span class="number"> 3 </span>root root <span class="number"> 4096 </span>Nov<span class="number"> 22 </span><span class="number"> 2015 </span>network/</div><div class="line">-rw-------  <span class="number"> 1 </span>root root <span class="number"> 2116 </span>Sep<span class="number"> 14 </span>08:14 repositories-aufs</div><div class="line">drwx------  <span class="number"> 2 </span>root root <span class="number"> 4096 </span>Sep<span class="number"> 14 </span>08:10 tmp/</div><div class="line">drwx------  <span class="number"> 2 </span>root root <span class="number"> 4096 </span>Nov<span class="number"> 22 </span><span class="number"> 2015 </span>trust/</div><div class="line">drwx------  <span class="number"> 3 </span>root root <span class="number"> 4096 </span>Sep<span class="number"> 14 </span>08:08 volumes/</div></pre></td></tr></table></figure>
<p>运行态容器默认都是使用/var/lib/docker目录，容器内部写日志、产生运行时数据等都会影响该目录，并且产生的文件越来越多，占用空间越来越大，因此需要定期清理无用的镜像和容器。可以用Logical Volume Manager (LVM)为Docker挂载点/var/lib/docker创建单独的分区，最好是SSD盘。</p>
<h2 id="四、Docker的安全性"><a href="#四、Docker的安全性" class="headerlink" title="四、Docker的安全性"></a>四、Docker的安全性</h2><p>Docker的安全性主要体现在如下几个方面：</p>
<ul>
<li><a href="4-1.Docker容器的安全性">Docker容器的安全性</a></li>
<li><a href="4-2.镜像的安全性">镜像的安全性</a></li>
<li><a href="4-3.Docker daemon的安全性">Docker daemon的安全性</a></li>
</ul>
<h3 id="4-1-Docker容器的安全性"><a href="#4-1-Docker容器的安全性" class="headerlink" title="4-1.Docker容器的安全性"></a>4-1.Docker容器的安全性</h3><p>指容器是否会危害到宿主机或其他容器。<br>容器的安全性问题的根源在于容器和宿主机共用内核，因此受攻击的面特别大，另外，如果容器里的应用导致Linux内核崩溃，那么毫无疑问，整个系统哥都会崩溃。这一点与虚拟机是不同的，虚拟机与宿主机的接口非常有限，而且虚拟机崩溃一般不会导致宿主机崩溃。</p>
<h3 id="4-2-镜像的安全性"><a href="#4-2-镜像的安全性" class="headerlink" title="4-2.镜像的安全性"></a>4-2.镜像的安全性</h3><p>用户如何确保下载下来的镜像是可信的、未被篡改过的；</p>
<h3 id="4-3-Docker-daemon的安全性"><a href="#4-3-Docker-daemon的安全性" class="headerlink" title="4-3.Docker daemon的安全性"></a>4-3.Docker daemon的安全性</h3><p>如何确保发送给daemon的命令是由可信用户发起的。用户通过CLI或者REST API向daemon发送命令已完成对容器的各种操作，例如通过docker exec命令删除容器里的数据，因此需要保证client与daemon的连接时可信的。</p>
<h2 id="五、Docker安全最佳实践"><a href="#五、Docker安全最佳实践" class="headerlink" title="五、Docker安全最佳实践"></a>五、Docker安全最佳实践</h2><h3 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h3><ul>
<li>保持内核及时更新，防止黑客利用未修复的漏洞进行攻击</li>
<li>增强主机安全保护，如果主机不安全了，容器也就谈不上安全了</li>
<li>保持Docker及时更新，特别要关注Docker安全相关方面的更新</li>
</ul>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul>
<li>在Dockerfile中为容器创建一个非root用户</li>
<li>以非root用户运行容器进程，最大程度控制用户的权限范围</li>
<li>只使用受信的基础镜像，可由最小基础镜像开始(Busybox, Alpine)，最好是建立本地仓库镜像</li>
<li>仅安装必要的包，因为可能有些包会有漏洞，一定程度上降低风险</li>
<li>重新构建镜像时需要包含安全补丁，防止黑客利用漏洞实施攻击</li>
</ul>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul>
<li>只允许受信用户控制Docker守护进程，保证与Daemon的连接是可信的</li>
<li>不使用不受信的镜像仓库，因为镜像可能会被篡改过</li>
<li>必要时请为Docker守护进程应用 TLS 认证网络</li>
<li>限制容器之间的网络通信，如果两个容器之间没有通信的必要就限制其网络通信功能</li>
</ul>
<h3 id="容器运行时"><a href="#容器运行时" class="headerlink" title="容器运行时"></a>容器运行时</h3><ul>
<li>不要到产品环境中使用任何开发者工具(boot2docker, kinematic)</li>
<li>限制容器使用Linux内核能力和资源使用，为守护进程设置受限的控制资源权限(–ulimit)</li>
<li>不要使用 Privileged 容器，如果使用–privileged参数将授予容器与主机几乎相同的权限</li>
<li>指定容器重启策略为on-failure，重启策略(Restart policies)有四种：<code>no</code>、<code>on-failure</code>、<code>always</code>、<code>unless-stopped</code>。</li>
<li>使用强制权限控制系统 AppArmor 和 Linux安全增强工具 SELinux 保证额外的安全层</li>
</ul>
<p>更多详情，可以参考<a href="https://learn.cisecurity.org/benchmarks" target="_blank" rel="external">Security Benchmarks</a>制定的容器的安全基准。下面截取了其中的一部分目录：<br><img src="/imgs/docker-security-host.png" width="500" height="250"></p>
<center>主机</center><br><br><br><img src="/imgs/docker-security-images.png" width="500" height="250"><br><center>镜像</center><br><br><br><img src="/imgs/docker-security-daemon.png" width="500" height="250"><br><center>守护进程</center><br><br><br><img src="/imgs/docker-security-container-runtime.png" width="500" height="250"><br><center>容器运行时</center>

<h3 id="六、构建容器平台时候的安全问题"><a href="#六、构建容器平台时候的安全问题" class="headerlink" title="六、构建容器平台时候的安全问题"></a>六、构建容器平台时候的安全问题</h3><p>上面说到的安全问题基本上是容器自身的，就是单独去考虑一个容器时，容器自身的一个安全性的问题。那么，当我们构建一个云平台的时候，这时容器是大量的，也可能是多租户的，特别是公有云，用户上传上来的应用是否安全，在这种情况下，怎么来去考虑一个容器平台的安全问题。可以从四个方面：</p>
<ul>
<li>基础架构层安全</li>
<li>容器调度层安全</li>
<li>容器调度层安全</li>
<li>容器调度层安全</li>
</ul>
<p>我们可以采取的一些措施：</p>
<ul>
<li>建立容器云平台的安全基线</li>
<li>容器 CI/CD 过程加密验证</li>
<li>加强平台的权限访问控制或者 API 密钥管理</li>
<li>加强容器的安全测试及渗透测试</li>
<li>加强安全漏洞扫</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本篇文章主要列举了一些Docker安全的最佳实践，并没有做过多的解释，具体情况还需要结合具体的项目实践。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://www.freebuf.com/articles/system/69809.html" target="_blank" rel="external">浅谈Docker隔离性和安全性</a></li>
<li><a href="https://segmentfault.com/a/1190000005794220" target="_blank" rel="external">Docker安全</a></li>
<li><a href="https://mp.weixin.qq.com/s/IN_JJhg_oG7ILVjNj-UexA" target="_blank" rel="external">绝不避谈 Docker 安全</a></li>
<li><a href="http://securityer.lofter.com/post/1d0f3ee7_d4e69b1" target="_blank" rel="external">如何打造安全的容器云平台</a></li>
<li><a href="http://www.10tiao.com/html/167/201707/2650762256/2.html" target="_blank" rel="external">从自身漏洞与架构缺陷，谈Docker安全建设</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇 Docker网络&lt;/a&gt;主要讲述了网络模型、网络模式。&lt;br&gt;本篇将讲述Docker安全性体现在哪些方面，并探讨每个方面的最佳实践。&lt;/p&gt;
&lt;h2 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h2&gt;&lt;p&gt;　　该系列《Docker in Prodcution》内容包含如下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;容器简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker的基本操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker数据存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker安全&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;多主机部署&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;日志、跟踪、监控&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;三、Docker访问主机系统&quot;&gt;&lt;a href=&quot;#三、Docker访问主机系统&quot; class=&quot;headerlink&quot; title=&quot;三、Docker访问主机系统&quot;&gt;&lt;/a&gt;三、Docker访问主机系统&lt;/h2&gt;&lt;p&gt;很多时候，我们启动Docker容器时都以root用户权限在运行。那么，如果有ROOT权限可以做什么呢？当然可以做很多的事情，比如：访问所有信息、修改任何内容、关闭机器、结束进程以及安装各种软件等。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Workshop（五）Docker网络</title>
    <link href="http://yoursite.com/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2017/07/17/Docker-workshop-5-Docker网络/</id>
    <published>2017-07-17T08:50:23.000Z</published>
    <updated>2017-12-27T07:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>　　<a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">上一篇 Docker的数据存储</a>主要讲述Docker数据管理的两种方式：数据卷和数据卷容器。<br>本篇主要讲述网络的实现、网络模型、网络模式等相关知识。</p>
<h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">容器简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">Docker简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">Docker的基本操作</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">Docker数据存储</a></li>
<li><strong>Docker网络</strong></li>
<li><a href="http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/" target="_blank" rel="external">Docker安全</a></li>
<li>多主机部署</li>
<li>服务发现</li>
<li>日志、跟踪、监控</li>
</ul>
<h2 id="三、网络的实现"><a href="#三、网络的实现" class="headerlink" title="三、网络的实现"></a>三、网络的实现</h2><p>　　Docker现有的网络模型主要是通过使用Network namespace、Linux Bridge、Iptables、veth pair等技术实现的。<br><a id="more"></a></p>
<ul>
<li>Network namespace（网络命名空间）<br>　　Network namespace主要提供了关于网络资源的隔离，包括网络设备、IPv4和IPv6协议栈、IP路由表、防火墙、/proc/net目录、/sys/class/net目录、端口（socket）等。</li>
<li>Linux Bridge<br>　　功能相当于物理交换机，为连在其上的设备（容器）转发数据帧。如docker0网桥。</li>
<li>Iptables<br>　　主要为容器提供NAT以及容器网络安全。</li>
<li>veth pair（虚拟网络设备）<br>　　两个虚拟网卡组成的数据通道。在Docker中，用于连接Docker容器和Linux Bridge。一端在容器中作为eth0网卡，另一端在Linux Bridge中作为网桥的一个端口。</li>
</ul>
<h2 id="四、网络创建过程"><a href="#四、网络创建过程" class="headerlink" title="四、网络创建过程"></a>四、网络创建过程</h2><img src="/imgs/docker-network-implement.png" width="500" height="250">
<p>　　Docker创建一个容器的时候，会具体执行如下操作：</p>
<ul>
<li>创建一对虚拟接口，即veth pair，分别放到宿主机和容器中;</li>
<li>本地主机一端的虚拟接口，连接到默认的docker0网桥或指定网桥上，并具有一个以veth开头的唯一的名字，如veth0ac844e;</li>
<li>容器一端的虚拟接口，将放到新容器中，并修改名字为eth0，该接口只在容器的命名空间可见;</li>
<li>从网桥可用地址段中获取一个空闲地址分配给容器的eth0（例如172.17.0.2/16），并配置默认路由网关为dokcer0的IP地址。</li>
</ul>
<p>　　完成这些配置之后，该容器就可以使用eth0虚拟网卡来连接其它容器和访问外部网络了。<br>　　当该容器结束后，Docker会清空容器，容器内的网络接口eth0会随网络命名空间一起被清除，veth0ac844e接口也被自动从docker0卸载。</p>
<p>　　另外，可以在docker运行的时候通过–net参数指定容器的网络配置，有<a href="#1-单节点网络模式">四个可选值</a>。</p>
<h3 id="【练习1】网络创建细节"><a href="#【练习1】网络创建细节" class="headerlink" title="【练习1】网络创建细节"></a>【练习1】网络创建细节</h3><p>1）启动一个 /bin/bash 容器，指定 –net=none 参数</p>
<pre><code>$ sudo docker run -i -t --rm --net=none busybox /bin/sh
</code></pre><p>2) 在<code>本地主机</code>查找容器的进程 id，并为它创建网络命名空间。</p>
<pre><code>$ sudo docker inspect -f &apos;{{.State.Pid}}&apos; 5259b04d2a50
2559
$ pid=2559
$ sudo mkdir -p /var/run/netns
$ sudo ln -s /proc/$pid/ns/net /var/run/netns/$pid
</code></pre><p>3）查看网桥docker0分配的子网段</p>
<pre><code>$ ip addr show docker0
6: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:89:d3:35:32 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:89ff:fed3:3532/64 scope link
       valid_lft forever preferred_lft forever
</code></pre><p>4) 创建一对 “veth pair” 接口 A 和 B，绑定 A 到网桥 docker0，并启用它</p>
<pre><code>$ sudo ip link add A type veth peer name B
$ sudo brctl addif docker0 A
$ sudo ip link set A up
</code></pre><p>5）将B放到容器的网络命名空间，命名为 eth0，启动它并配置一个可用 IP（桥接网段）和默认网关</p>
<pre><code>$ sudo ip link set B netns $pid
$ sudo ip netns exec $pid ip link set dev B name eth0
$ sudo ip netns exec $pid ip link set eth0 up
$ sudo ip netns exec $pid ip addr add 172.17.42.1/16 dev eth0
$ sudo ip netns exec $pid ip route add default via 172.17.0.1
</code></pre><p>6) 其他指令</p>
<pre><code># 查看网桥docker0上的虚拟接口
$ brctl show
bridge name bridge id       STP enabled interfaces
br-fe42067d4b8f     8000.0242987a3884   no
docker0     8000.024289d33532   no      veth76e4a32
lxcbr0      8000.000000000000   no

# 查看网桥docker0的生成树状态
$ brctl show docker0
bridge name bridge id       STP enabled interfaces
docker0     8000.024289d33532   no      veth76e4a32

# 查看网桥docker0的网卡驱动类型
$ ethtool -i docker0
driver: bridge
version: 2.3
firmware-version: N/A
bus-info: N/A
supports-statistics: no
supports-test: no
supports-eeprom-access: no
supports-register-dump: no
supports-priv-flags: no

# 查看该网络接口的唯一识别编号peer_ifindex
$ ethtool -S veth76e4a32
NIC statistics:
     peer_ifindex: 7

# 查看路由信息
$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:domain
ACCEPT     udp  --  anywhere             anywhere             udp dpt:domain
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:bootps
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootps
Chain FORWARD (policy ACCEPT)
target     prot opt source               destination
DROP       all  --  172.18.0.0/16        172.17.0.0/16
DROP       all  --  172.17.0.0/16        172.18.0.0/16
DOCKER     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
DOCKER     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere
Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
Chain DOCKER (2 references)
target     prot opt source               destination
ACCEPT     tcp  --  anywhere             172.17.0.2           tcp dpt:5000
</code></pre><h2 id="五、网络模型"><a href="#五、网络模型" class="headerlink" title="五、网络模型"></a>五、网络模型</h2><h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><p>　　在容器网络模型中，通常会包括容器(Container)、沙箱(Sandbox)、端点(Endpoint)、网络(Network)等组件，其中，网络会涉及桥接网(Bridge Network)或重叠网(Overlay Network)。<br><img src="/imgs/docker-network-concept.png" width="500" height="250"></p>
<ul>
<li>容器(Container): 容器能够作为任意一个或多个网络的一部分，能够同时对接桥接网和重叠网网络。</li>
<li>沙箱(Sandbox): 包含容器网络堆栈配置信息，是一个隔离的环境，可能包含多网络的多个端点。</li>
<li>端点(Endpoint): 连接沙箱和网络的接口，绑定到特定的网络，比如之前提到的veth pair。</li>
<li>网络(Network): 使得一组端点之间能够相互直接交流的，实现可以是Linux网桥或重叠</li>
</ul>
<h3 id="与Docker-Links对比"><a href="#与Docker-Links对比" class="headerlink" title="与Docker Links对比"></a>与Docker Links对比</h3><p>与Docker Links进行简单对比，Docker Links允许容器之间互相发现，并使用容器名作为别名进行互相之间的通信，比DNS或服务发现更容易使用，且不用关心端口映射，但Docker Links有一些限制，比如:</p>
<ul>
<li>只能在同一宿主机内使用，不能跨主机</li>
<li>重新创建容器会移除之前的链接(Links)</li>
<li>被链接的容器必须是一个已经启动的容器<br>因此，在Docker 1.9版本之后，官方推荐使用Docker网络功能代替Docker Links。Docker容器网络模型的主要优势在于:</li>
<li>在某个特定网络下的所有容器能自由地相互通信</li>
<li>多个网络有助于分散容器之间的流量传输</li>
<li>多个端点允许一个容器加入到多个网络中</li>
<li>能够支持同主机和跨主机的容器间通信</li>
</ul>
<h2 id="四、Docker网络模式"><a href="#四、Docker网络模式" class="headerlink" title="四、Docker网络模式"></a>四、Docker网络模式</h2><p><a href="#1-单节点网络模式">1. 单节点网络模式</a></p>
<ul>
<li><a href="#1-1.bridge模式">bridge模式</a></li>
<li><a href="#1-2.host模式">host模式</a></li>
<li><a href="#1-3.container模式">container模式</a> </li>
<li><a href="#1-4.none模式">none模式</a></li>
</ul>
<p><a href="#2-多节点网络模式">2. 多节点网络模式</a></p>
<ul>
<li><a href="#2-1.原生支持">原生支持</a></li>
<li><a href="#2-2.插件">插件</a></li>
</ul>
<h3 id="1-单节点网络模式"><a href="#1-单节点网络模式" class="headerlink" title="1-单节点网络模式"></a>1-单节点网络模式</h3><h4 id="1-1-bridge模式"><a href="#1-1-bridge模式" class="headerlink" title="1-1.bridge模式"></a>1-1.bridge模式</h4><p>使用–net=bridge指定<br>该模式中，Docker守护进程创建一个虚拟以太网桥docker0，附加在其上的任何网卡之间都能自动转发数据包。默认情况下，守护进程会创建一对对等接口，将其中一个接口设置为容器的eth0接口，另一个接口放置在宿主机的命名空间中，从而将宿主机上的所有容器都连接到这个内部网络上。同时，守护进程还会从网桥的私有地址空间中分配一个IP地址和子网给该容器。</p>
<h4 id="1-2-host模式"><a href="#1-2-host模式" class="headerlink" title="1-2.host模式"></a>1-2.host模式</h4><p>使用–net=host指定<br>该模式将禁用Docker容器的网络隔离。因为容器共享了宿主机的网络命名空间，直接暴露在公共网络中。因此，你需要通过端口映射（port mapping）来进行协调。</p>
<p>当使用host模式网络时，容器实际上继承了宿主机的IP地址。该模式比bridge模式更快（因为没有路由开销），但是它将容器直接暴露在公共网络中，是有安全隐患的。</p>
<h4 id="1-3-container模式"><a href="#1-3-container模式" class="headerlink" title="1-3.container模式"></a>1-3.container模式</h4><p>使用–net=container指定<br>该模式会重用另一个容器的网络命名空间。通常来说，当你想要自定义网络栈时，该模式是很有用的。实际上，该模式也是Kubernetes使用的网络模式。</p>
<h4 id="1-4-none模式"><a href="#1-4-none模式" class="headerlink" title="1-4.none模式"></a>1-4.none模式</h4><p>使用–net=none指定<br>该模式将容器放置在它自己的网络栈中，但是并不进行任何配置。实际上，该模式关闭了容器的网络功能，在以下两种情况下是有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）；你希望自定义网络。</p>
<p>####【练习2】单主机创建网络<br>1) 创建<code>web</code>网络，并创建一个基于<code>web</code>网络的容器<code>web_container</code></p>
<pre><code>$ docker network create web
a3f32cf362412ca10cc375c0cbf304c15b1cfd2a0da6addb97ef3606bcb04350
$ docker network ls
NETWORK ID          NAME                DRIVER
134b9d559a29        host                host
20d10cc6ad42        bridge              bridge
a3f32cf36241        web                 bridge
e7f9d75e45b8        none                null
$ docker run -itd --net=web --name web_container busybox
fdec55f5db5da821825fe5b091e69e248f8f346273a9397ea66a931b4c26bb7f
$ docker network inspect web
[
    {
        &quot;Name&quot;: &quot;web&quot;,
        &quot;Id&quot;: &quot;a3f32cf362412ca10cc375c0cbf304c15b1cfd2a0da6addb97ef3606bcb04350&quot;,
        &quot;Scope&quot;: &quot;local&quot;,
        &quot;Driver&quot;: &quot;bridge&quot;,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;default&quot;,
            &quot;Config&quot;: [
                {}
            ]
        },
        &quot;Containers&quot;: {
            &quot;fdec55f5db5da821825fe5b091e69e248f8f346273a9397ea66a931b4c26bb7f&quot;: {
                &quot;EndpointID&quot;: &quot;67b284bcef2544ec153c90e041c7d51351d5f2cea63e31537352e37ac8fb1fe6&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,
                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        },
        &quot;Options&quot;: {}
    }
]
</code></pre><p>2） 重复操作<code>1）</code>，创建另外一个基于<code>app</code>网络的容器</p>
<pre><code>$ docker network create app
$ docker network ls
NETWORK ID          NAME                DRIVER
20d10cc6ad42        bridge              bridge
a3f32cf36241        web                 bridge
e7f9d75e45b8        none                null
134b9d559a29        host                host
73eda6fce093        app                 bridge
$ docker run -itd --name app_container --net=app busybox
$ docker network inspect app
</code></pre><p>3) 连接<code>web_container</code>到<code>app</code>网络</p>
<pre><code>$ docker network connect app web_container
</code></pre><p>这样<code>web_container</code>就可以通过<code>web_container.app</code>连接<code>app</code>网络了:</p>
<pre><code>$ docker exec app_container ping web_container.app
PING web_container.app (172.19.0.3): 56 data bytes
64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.118 ms
64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.080 ms
</code></pre><p>4) 连接<code>app_container</code>到<code>web</code>网络</p>
<pre><code># 连接之前：
$ docker exec web_container ping app_container.web
ping: bad address &apos;app_container.web&apos;

# 连接
$ docker network connect web app_container

# 连接之后
$ docker exec web_container ping app_container.web
PING app_container.web (172.18.0.3): 56 data bytes
64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.219 ms
64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.111 ms
</code></pre><p>5) 查看网络信息</p>
<ul>
<li><p>查看连接之后web网络的containers里面就有两个container了</p>
<p>  $ docker network inspect web<br>  [</p>
<pre><code>{
    &quot;Name&quot;: &quot;web&quot;,
    &quot;Id&quot;: &quot;a3f32cf362412ca10cc375c0cbf304c15b1cfd2a0da6addb97ef3606bcb04350&quot;,
    &quot;Scope&quot;: &quot;local&quot;,
    &quot;Driver&quot;: &quot;bridge&quot;,
    &quot;IPAM&quot;: {
        &quot;Driver&quot;: &quot;default&quot;,
        &quot;Config&quot;: [
            {}
        ]
    },
    &quot;Containers&quot;: {
        &quot;59b01ca0444b4c708b521725532762512bc57ec9fdfccb2e2a6addef8a072f05&quot;: {
            &quot;EndpointID&quot;: &quot;dd969e4ec9703cf87adfd97b22bb8e06ec8a12139c948aceb6aea70388d23d31&quot;,
            &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,
            &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,
            &quot;IPv6Address&quot;: &quot;&quot;
        },
        &quot;fdec55f5db5da821825fe5b091e69e248f8f346273a9397ea66a931b4c26bb7f&quot;: {
            &quot;EndpointID&quot;: &quot;67b284bcef2544ec153c90e041c7d51351d5f2cea63e31537352e37ac8fb1fe6&quot;,
            &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,
            &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,
            &quot;IPv6Address&quot;: &quot;&quot;
        }
    },
    &quot;Options&quot;: {}
}
</code></pre><p>  ]                                   </p>
</li>
<li><p>查看container的NetworkSettings，里面Networks有两个网络了：</p>
<p>  $ docker inspect web_container<br>  “Networks”: {</p>
<pre><code>    &quot;app&quot;: {
        &quot;EndpointID&quot;: &quot;b06bbe5ea7dbaa96fecb2165404185effa0d6ebf01b028633f2afe00664cf16d&quot;,
        &quot;Gateway&quot;: &quot;172.19.0.1&quot;,
        &quot;IPAddress&quot;: &quot;172.19.0.3&quot;,
        &quot;IPPrefixLen&quot;: 16,
        &quot;IPv6Gateway&quot;: &quot;&quot;,
        &quot;GlobalIPv6Address&quot;: &quot;&quot;,
        &quot;GlobalIPv6PrefixLen&quot;: 0,
        &quot;MacAddress&quot;: &quot;02:42:ac:13:00:03&quot;
    },
    &quot;web&quot;: {
        &quot;EndpointID&quot;: &quot;67b284bcef2544ec153c90e041c7d51351d5f2cea63e31537352e37ac8fb1fe6&quot;,
        &quot;Gateway&quot;: &quot;172.18.0.1&quot;,
        &quot;IPAddress&quot;: &quot;172.18.0.2&quot;,
        &quot;IPPrefixLen&quot;: 16,
        &quot;IPv6Gateway&quot;: &quot;&quot;,
        &quot;GlobalIPv6Address&quot;: &quot;&quot;,
        &quot;GlobalIPv6PrefixLen&quot;: 0,
        &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;
    }
}
</code></pre></li>
</ul>
<h3 id="2-多节点网络模式"><a href="#2-多节点网络模式" class="headerlink" title="2-多节点网络模式"></a>2-多节点网络模式</h3><h4 id="2-1-原生支持"><a href="#2-1-原生支持" class="headerlink" title="2-1.原生支持"></a>2-1.原生支持</h4><p>Docker 在 1.19 版本中引入的基于 VxLAN 的对跨节点网络的原生支持，即自带重叠网络(Overlay Network) 组件。<br>Docker 支持 Consul, Etcd, 和 ZooKeeper 三种分布式key-value 存储。其中，etcd 是一个高可用的分布式 k/v存储系统，使用etcd的场景默认处理的数据都是控制数据，对于应用数据，只推荐数据量很小，但是更新访问频繁的情况。</p>
<h4 id="【练习3】利用Docker-Swarm多主机创建网络"><a href="#【练习3】利用Docker-Swarm多主机创建网络" class="headerlink" title="【练习3】利用Docker Swarm多主机创建网络"></a>【练习3】利用Docker Swarm多主机创建网络</h4><p>1) 先准备两台虚拟机作为Docker Swarm的两个节点Node1，Node2。</p>
<pre><code>$ midir docker-cluster
$ cd docker-cluster
$ vim Vagrantfile
</code></pre><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Vagrant.configure(<span class="number">2</span>) <span class="built_in">do</span> |<span class="type">config</span>|</div><div class="line">  <span class="type">(1</span>.<span class="number">.2</span>).each <span class="built_in">do</span> |<span class="type">i</span>|</div><div class="line">    <span class="type">config</span>.vm.define <span class="string">"wanzi-node#&#123;i&#125;"</span> <span class="built_in">do</span> |<span class="type">node</span>|</div><div class="line">      <span class="type">node</span>.vm.box = <span class="string">"comiq/dockerbox"</span></div><div class="line">      node.vm.provider <span class="string">"virtualbox"</span> <span class="built_in">do</span> |<span class="type">vb</span>|</div><div class="line">        <span class="type">vb</span>.name = <span class="string">"wanzi-node#&#123;i&#125;"</span></div><div class="line">      <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<pre><code>$ vagrant up
Bringing machine &apos;wanzi-node1&apos; up with &apos;virtualbox&apos; provider...
Bringing machine &apos;wanzi-node2&apos; up with &apos;virtualbox&apos; provider...
==&gt; wanzi-node1: Checking if box &apos;comiq/dockerbox&apos; is up to date...
==&gt; wanzi-node1: VirtualBox VM is already running.
==&gt; wanzi-node2: Importing base box &apos;comiq/dockerbox&apos;...
==&gt; wanzi-node2: Matching MAC address for NAT networking...
==&gt; wanzi-node2: Checking if box &apos;comiq/dockerbox&apos; is up to date...
==&gt; wanzi-node2: Setting the name of the VM: wanzi-node2
==&gt; wanzi-node2: Fixed port collision for 22 =&gt; 2222. Now on port 2201.
==&gt; wanzi-node2: Clearing any previously set network interfaces...
==&gt; wanzi-node2: Preparing network interfaces based on configuration...
    wanzi-node2: Adapter 1: nat
==&gt; wanzi-node2: Forwarding ports...
    wanzi-node2: 22 =&gt; 2201 (adapter 1)
==&gt; wanzi-node2: Booting VM...
==&gt; wanzi-node2: Waiting for machine to boot. This may take a few minutes...
    wanzi-node2: SSH address: 127.0.0.1:2201
    wanzi-node2: SSH username: vagrant
    wanzi-node2: SSH auth method: private key
    wanzi-node2: Warning: Connection timeout. Retrying...
==&gt; wanzi-node2: Machine booted and ready!
==&gt; wanzi-node2: Checking for guest additions in VM...
==&gt; wanzi-node2: Mounting shared folders...
    wanzi-node2: /vagrant =&gt; /Users/yuzhang/Downloads/Devops/docker_cluster
</code></pre><p>2） <strong>Node1</strong>作为Manager<br>登陆到Node1:</p>
<pre><code>$ vagrant ssh wanzi-node1
Welcome to Ubuntu 16.04 LTS (GNU/Linux 4.4.0-21-generic x86_64)
 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage
</code></pre><p>在Node1上初始化并创建Docker Swarm，作为Manager:</p>
<pre><code>vagrant@vagrant:~$  docker swarm init --advertise-addr 192.168.59.1:2377
Swarm initialized: current node (85qhfwludbf603gcazjqippl2) is now a manager.
To add a worker to this swarm, run the following command:
docker swarm join \
--token SWMTKN-1-5rv6l22kow7fhpthihiy5oqi8ka4mospeele38ycsfuwsviv1y-bekemef3aafmbanavzkeekjch \
192.168.59.1:2377
</code></pre><p>To add a manager to this swarm, run ‘docker swarm join-token manager’ and follow the instructions.</p>
<p>3) <strong>Node2</strong>作为Worker<br>登陆到Node2:</p>
<pre><code>$ vagrant ssh wanzi-node1
</code></pre><p>在Node2上运行如下命令加入到Swarm中，作为Worker:</p>
<pre><code>vagrant@vagrant:~$ docker swarm join \
&gt;     --token SWMTKN-1-5rv6l22kow7fhpthihiy5oqi8ka4mospeele38ycsfuwsviv1y-bekemef3aafmbanavzkeekjch \
&gt;     192.168.59.1:2377
This node joined a swarm as a worker.
</code></pre><p>4) 在<strong>Node1</strong>上查看所有node信息</p>
<pre><code>vagrant@vagrant:~$ docker node ls
ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
85qhfwludbf603gcazjqippl2 *  vagrant   Ready   Active        Leader
9o4sy1vcd5nygr77jrjpl28sn    vagrant   Ready   Active
</code></pre><p>5) 在<strong>Node2</strong>上则<strong>不</strong>能查看所有node信息</p>
<pre><code>vagrant@vagrant:~$ docker node ls
Error response from daemon: This node is not a swarm manager. Worker nodes can&apos;t be used to view or modify cluster state. Please run this command on a manager node or promote the current node to a manager.
</code></pre><p>6) 在<strong>Node1</strong>上创建<code>overlay</code>网络</p>
<pre><code>vagrant@vagrant:~$ docker network create -d=overlay net_overlay
0aa8c2nu8vwwbep0spui8upva
vagrant@vagrant:~$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
9cbbdda300b9        bridge              bridge              local
eb0832fa48cc        docker_gwbridge     bridge              local
d9cbc7492332        host                host                local
6agtuhiw3e1r        ingress             overlay             swarm
0aa8c2nu8vww        net_overlay         overlay             swarm
e5bb8590c3b8        none                null                local
</code></pre><p>这样，所有在Swarm中的主机都可以访问该网络了，除了docker0默认网桥外，这里多出了一个docker_gwbridge的网桥，docker0在跨多主机容器网络中并没有被用到，而是docker_gwbridge替代了docker0用来实现Overlay网络中容器间的通信以及容器到外部的通信，其职能就和单机容器网络中docker0一样。</p>
<pre><code>vagrant@vagrant:~$ docker network inspect net_overlay
[
    {
        &quot;Name&quot;: &quot;net_overlay&quot;,
        &quot;Id&quot;: &quot;0aa8c2nu8vwwbep0spui8upva&quot;,
        &quot;Scope&quot;: &quot;swarm&quot;,
        &quot;Driver&quot;: &quot;overlay&quot;,
        &quot;EnableIPv6&quot;: false,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;default&quot;,
            &quot;Options&quot;: null,
            &quot;Config&quot;: []
        },
        &quot;Internal&quot;: false,
        &quot;Containers&quot;: null,
        &quot;Options&quot;: {
            &quot;com.docker.network.driver.overlay.vxlanid_list&quot;: &quot;257&quot;
        },
        &quot;Labels&quot;: null
    }
]
</code></pre><p>7) 创建服务<br>　　创建一个名为hello的服务，包含2个副本，使用sleep infinity的命令运行，该命令使得容器不会立即退出:</p>
<pre><code>vagrant@vagrant:~$ docker service ls
ID            NAME   REPLICAS  IMAGE   COMMAND
alq1vrojrwd6  hello  0/2       ubuntu  sleep infinity
vagrant@vagrant:~$ docker service ps hello
ID                         NAME     IMAGE   NODE     DESIRED STATE  CURRENT STATE          ERROR
66zkihz10oaoxv1i94niud0cy  hello.1  ubuntu  vagrant  Running        Running 4 seconds ago
08stnpfqhg3rhtb1nd3dxxade  hello.2  ubuntu  vagrant  Running        Running 5 seconds ago
</code></pre><p>可以分别在Node1和Node2上查看运行的容器：<br>Node1:</p>
<pre><code>vagrant@vagrant:~$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
63f768d6b911        ubuntu:latest       &quot;sleep infinity&quot;    28 seconds ago      Up 27 seconds                           hello.2.08stnpfqhg3rhtb1nd3dxxade
</code></pre><p>Node2:</p>
<pre><code>vagrant@vagrant:~$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
e506461b95f3        ubuntu:latest       &quot;sleep infinity&quot;    48 seconds ago      Up 47 seconds                           hello.1.66zkihz10oaoxv1i94niud0cy
</code></pre><p>8) 检查连通性<br>Node1:</p>
<pre><code>vagrant@vagrant:~$ docker inspect -f {{.NetworkSettings.Networks.net_overlay.IPAddress}}  63f768d6b911
10.0.0.4
</code></pre><p>Node2:</p>
<pre><code>vagrant@vagrant:~$ docker inspect -f {{.NetworkSettings.Networks.net_overlay.IPAddress}}  e506461b95f3
10.0.0.3

 vagrant@vagrant:~$ docker exec hello.1.66zkihz10oaoxv1i94niud0cy apt-get update; apt-get install iputils-ping -y; ping 10.0.0.4
</code></pre><h4 id="2-2-插件"><a href="#2-2-插件" class="headerlink" title="2-2.插件"></a>2-2.插件</h4><p>该方式是通过插件（plugin）方式引入的第三方实现方案，比如 Weave, Calico, Contiv Netplugin, Cisco, VMware, MidoNet, pipework, flannel等等。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本篇文章主要是讲述Docker网络相关的内容，包括Docker的网络实现、网络创建过程、网络模型组件与优势、网络模式（单节点、多节点）等。<br><a href="http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/" target="_blank" rel="external">下一篇</a>将讲述Docker的安全。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://dockone.io/article/1261" target="_blank" rel="external">Docker网络模式</a></li>
<li><a href="http://www.cnblogs.com/sammyliu/p/5894191.html" target="_blank" rel="external">理解Docker网络</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/advanced_network/&lt;ptp class=&quot;html&quot;&gt;&lt;/ptp" target="_blank" rel="external">Docker从入门到实践-高级网络配置</a></li>
<li><a href="http://dockone.io/article/1736" target="_blank" rel="external">使用Docker Swarm来运行服务</a></li>
<li><a href="http://kiwenlau.com/2016/07/03/vagrant-vm-cluster/" target="_blank" rel="external">使用Vagrant创建多节点虚拟机集群</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;　　&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇 Docker的数据存储&lt;/a&gt;主要讲述Docker数据管理的两种方式：数据卷和数据卷容器。&lt;br&gt;本篇主要讲述网络的实现、网络模型、网络模式等相关知识。&lt;/p&gt;
&lt;h2 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h2&gt;&lt;p&gt;　　该系列《Docker in Prodcution》内容包含如下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;容器简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker的基本操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker数据存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker网络&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;多主机部署&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;日志、跟踪、监控&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;三、网络的实现&quot;&gt;&lt;a href=&quot;#三、网络的实现&quot; class=&quot;headerlink&quot; title=&quot;三、网络的实现&quot;&gt;&lt;/a&gt;三、网络的实现&lt;/h2&gt;&lt;p&gt;　　Docker现有的网络模型主要是通过使用Network namespace、Linux Bridge、Iptables、veth pair等技术实现的。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Workshop（四）Docker数据存储</title>
    <link href="http://yoursite.com/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2017/07/13/Docker-workshop-4-Docker数据存储/</id>
    <published>2017-07-13T00:18:24.000Z</published>
    <updated>2017-12-27T07:12:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>　　<a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">上一篇 Docker的基本操作</a>按照构建流程练习了docker的一些常见基本指令。<br>本篇主要讲述Docker数据管理相关的内容。</p>
<h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">容器简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">Docker简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">Docker的基本操作</a></li>
<li><strong>Docker数据存储</strong></li>
<li><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">Docker网络</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/" target="_blank" rel="external">Docker安全</a></li>
<li>多主机部署</li>
<li>服务发现</li>
<li>日志、跟踪、监控</li>
</ul>
<p>本章主要通过练习<code>数据卷</code>和<code>数据卷容器</code>来理解Docker的数据管理。</p>
<h2 id="三、Docker的存储方式"><a href="#三、Docker的存储方式" class="headerlink" title="三、Docker的存储方式"></a>三、Docker的存储方式</h2><a id="more"></a>
<p>　　Docker存储驱动包含：AUFS、Device mapper、OverlayFS、Btrfs、ZF，它们提供了接口支持<strong>镜像分层</strong>与<strong>写时复制机制Cow</strong>，这两种技术满足了容器的核心价值，即极快的创建速度，极小的存储资源消耗以及容器迁移的便捷性。<br>容器的Root Image存储分为以下三类：</p>
<ul>
<li>AUFS，Overlay : 联合文件系统。</li>
<li>DeviceMapper：CoW块存储。</li>
<li>ZFS，btrfs: CoW文件系统。</li>
</ul>
<p>　　Docker并不推荐采用Root Image的存储方式来存储应用数据。因为应用数据对安全，可用性，共享，性能等方面的要求和Root Image的要求是完全不一样的。<br>　　Docker采用了Volume这样一个独立的数据访问接口，应用通过Volume去访问相关的数据，Volume的实现和CoW的分层文件系统完全独立。<br>　　Volume通过Rancher Convoy或者Flocker这样的存储驱动去管理和访问具体的存储设备。</p>
<h2 id="四、卷是什么"><a href="#四、卷是什么" class="headerlink" title="四、卷是什么"></a>四、卷是什么</h2><p>　　Docker的理念之一是将应用与其运行的环境进行打包，因此通常docker容器的生存周期与在容器中运行的程序的生存周期是一致的，当容器被销毁时，容器里的数据也会随之消失。</p>
<p>　　为了能够<strong>保存（持久化）数据</strong>以及<strong>共享容器间的数据</strong>，Docker提出了Volume的概念。<br>简单来说，Volume就是目录或者文件，它可以绕过默认的联合文件系统，而以正常的文件或者目录的形式存在于宿主机上。</p>
<h2 id="五、管理数据的两种方式"><a href="#五、管理数据的两种方式" class="headerlink" title="五、管理数据的两种方式"></a>五、管理数据的两种方式</h2><p>在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷（Data volumes）</li>
<li>数据卷容器（Data volume containers）</li>
</ul>
<h3 id="1-数据卷（Data-volumes）"><a href="#1-数据卷（Data-volumes）" class="headerlink" title="1. 数据卷（Data volumes）"></a>1. 数据卷（Data volumes）</h3><p>　　数据卷是容器内的一个特殊目录，该目录绕过UFS，不向顶层的可读写layer写入。数据卷用来保存、固化数据，独立于容器的生存周期，不会主动被回收。</p>
<p>数据卷特性：</p>
<ul>
<li>处于UFS(Union File System)之外</li>
<li>主机文件系统中的普通目录</li>
<li>在卷上的I/O性能应与主机上的完全相同</li>
<li>卷的内容不包含在Docker镜像中</li>
<li>任何对卷内容的修改不是镜像的一部分</li>
<li>可被多个容器共享和重用</li>
<li>持久化数据（即使容器已被删除</li>
</ul>
<blockquote>
<p><strong>注意</strong>：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。</p>
</blockquote>
<p>可以使用以下两种方式创建：</p>
<ul>
<li>在Dockerfile中指定VOLUME /some/dir</li>
<li>执行docker run -v /some/dir命令来指定<br>　　两种方式的区别在于<code>run的-v</code>可以指定挂载到宿主机的哪个目录，而<code>Dockerfile的VOLUME</code>不能，其挂载目录由docker随机生成。</li>
</ul>
<h4 id="【练习1】用-v添加一个数据卷"><a href="#【练习1】用-v添加一个数据卷" class="headerlink" title="【练习1】用-v添加一个数据卷"></a>【练习1】用-v添加一个数据卷</h4><p>1）启动一个基于busybox镜像的容器volume-example,并在其根目录下挂载一个data卷</p>
<pre><code>$ docker run -d -it --name volume-example -v /data busybox
</code></pre><p>2）查看data是否挂载成功</p>
<pre><code>$ docker exec volume-example ls | grep data
</code></pre><p>3) 查看data卷对应主机的目录；</p>
<pre><code>$ docker inspect -f {{.Mounts}} volume-example
[{093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f /var/lib/docker/volumes/093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f/_data /data local  true}]
</code></pre><blockquote>
<p>如果<code>步骤1）</code>，没有指定host的挂载目录，那么docker会自动创建一个挂载文件夹放在<br><code>/var/lib/docker/volumes/</code>下。上述例子中，在主机下的挂载目录是:</p>
<pre><code>/var/lib/docker/volumes/093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f/_data
</code></pre><p>如果<code>步骤1）</code>，指定了主机目录：</p>
<pre><code>$ docker run -d -it --name volume-example -v ~/volume/data:/data busybox
$ docker inspect -f {{.Mounts}} volume-example
[{ /home/vagrant/volume/data /data   true}]
</code></pre><p>那么在主机下挂载的目录则是自己指定的<code>~/volume/data</code>了。</p>
</blockquote>
<p>4) 在主机对应的目录创建一个文件</p>
<pre><code>$ sudo touch &lt;paste the copied host directory location&gt;/test-file
</code></pre><p>5) 在容器里面检查一下刚才创建的文件</p>
<pre><code>$ docker exec volume-example ls data/
</code></pre><p>6) 查看所有volumn</p>
<pre><code>$ docker volume ls
DRIVER              VOLUME NAME
local               bd0769d0b9a94e475b370d08ceafd9417499a8f3549a7b0f55f3be96f46b1b56
local               093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f
</code></pre><p>7） 查看volumn详细信息</p>
<pre><code>$ docker volume inspect 093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f
[
    {
        &quot;Name&quot;: &quot;093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/093c2cccfcc37e01d0ae4c145dcfb25a6c65a4b94617944efaa8f130463bcc6f/_data&quot;
    }
]
</code></pre><h4 id="【练习2】用Dockerfile挂载数据卷"><a href="#【练习2】用Dockerfile挂载数据卷" class="headerlink" title="【练习2】用Dockerfile挂载数据卷"></a>【练习2】用Dockerfile挂载数据卷</h4><p>1） 创建一个<code>Dockerfile</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">FROM</span> <span class="string">busybox</span></div><div class="line"><span class="string">RUN</span> <span class="string">mkdir</span> <span class="string">/test-dir</span></div><div class="line"><span class="string">COPY</span> <span class="string">test.yml</span> <span class="string">/test-dir</span></div><div class="line"><span class="string">VOLUME</span> <span class="string">/test-dir</span></div></pre></td></tr></table></figure></p>
<p>2) 创建一个<code>test.yml</code>文件</p>
<pre><code>$ echo &quot;This is a test file for testing volume from Dockerfile.&quot; &gt; test.yml
</code></pre><p>3) 构建一个镜像</p>
<pre><code>$ docker build -t volume-example:test .
Sending build context to Docker daemon 8.192 kB
Step 1 : FROM busybox
 ---&gt; 103e96d345c0
Step 2 : RUN mkdir /test-dir
 ---&gt; Running in 10aa732b4099
 ---&gt; ef6b4c6bde95
Removing intermediate container 10aa732b4099
Step 3 : COPY test.yml /test-dir
 ---&gt; 7fe861cb8aef
Removing intermediate container 50b4cec740b7
Step 4 : VOLUME /test-dir
 ---&gt; Running in c20cfc350b8f
 ---&gt; 8ea4d7630233
Removing intermediate container c20cfc350b8f
Successfully built 8ea4d7630233
</code></pre><p>4） 查看该镜像所包含的卷信息</p>
<pre><code>$ docker inspect -f {{.Config.Volumes}} volume-example:test
map[/test-dir:{}]
</code></pre><p>5) Dockerfile中声明卷会占用镜像体积么？</p>
<pre><code>$ docker history volume-example:test
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
8ea4d7630233        39 seconds ago      /bin/sh -c #(nop) VOLUME [/test-dir]            0 B
7fe861cb8aef        39 seconds ago      /bin/sh -c #(nop) COPY file:6d145c083d0383b1b   56 B
ef6b4c6bde95        39 seconds ago      /bin/sh -c mkdir /test-dir                      0 B
103e96d345c0        4 weeks ago         /bin/sh -c #(nop)  CMD [&quot;sh&quot;]                   0 B
f16f9e1c2f42        4 weeks ago         /bin/sh -c #(nop) ADD file:aa56bc8f2fea9c0c81   1.106 MB
</code></pre><p>6) 运行容器</p>
<pre><code>$ docker run -d --name volume-example-container volume-example:test
c063baa2d2bd07373a563316a05a0c2793bca41883bc0964039dd96a8887cc3b

$ docker inspect -f {{.Mounts}} volume-example-container
[{054802484b2f99171b7d96be0b1e8028662d151b5491c80296d9b92e7d7d392b /var/lib/docker/volumes/054802484b2f99171b7d96be0b1e8028662d151b5491c80296d9b92e7d7d392b/_data /test-dir local  true}]

$ docker exec volume-example-container ls /test-dir
test.yml
</code></pre><p>7) 查看挂载的<code>test.yml</code>文件</p>
<pre><code>$ sudo ls /var/lib/docker/volumes/054802484b2f99171b7d96be0b1e8028662d151b5491c80296d9b92e7d7d392b/_data
test.yml
</code></pre><blockquote>
<p>Dockerfile中每一句指令，都会生成一个临时的容器，如:</p>
<pre><code>Step 4 : VOLUME /test-dir
---&gt; Running in c20cfc350b8f
---&gt; 8ea4d7630233
</code></pre><p>首先，<code>Step 4</code>里面生成了一个临时容器<code>c20cfc350b8f</code>;<br>然后，commit容器得到了镜像<code>8ea4d7630233</code>;<br>因此，<code>VOLUME /test-dir</code>是通过<code>是通过docker run -v  /test-dir</code>来实现的，随后由于容器的commit，该配置保存到了镜像<code>8ea4d7630233</code>里，可以通过如下质量查看</p>
<pre><code>$ docker inspect -f {{.Config.Volumes}} 8ea4d7630233
map[/test-dir:{}]
</code></pre><p>由于没有指定挂载到的宿主机目录，因此会默认挂载到宿主机的/var/lib/docker/volumes下的一个随机名称的目录下，因此Dockerfile里面的VOLUME不能指定主机挂载目录。</p>
</blockquote>
<h3 id="2-数据卷容器（Data-volume-containers）"><a href="#2-数据卷容器（Data-volume-containers）" class="headerlink" title="2. 数据卷容器（Data volume containers）"></a>2. 数据卷容器（Data volume containers）</h3><p>　　如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。<br>数据卷容器，其实就是一个正常的容器，是一个挂载了数据卷但是不执行任何命令的容器，其目的只是为其他容器提供数据卷，方便数据在多容器之间共享、复用。</p>
<p>使用数据容器的两个注意点：</p>
<ul>
<li>不要运行数据容器，这纯粹是在浪费资源。</li>
<li>不要为了数据容器而使用“最小的镜像”，如busybox或scratch，只使用数据库镜像本身就可以了。你已经拥有该镜像，所以并不需要占用额外的空间。</li>
</ul>
<h4 id="【练习3】创建数据卷容器"><a href="#【练习3】创建数据卷容器" class="headerlink" title="【练习3】创建数据卷容器"></a>【练习3】创建数据卷容器</h4><p>练习2里面已经创建了一个挂载数据卷的镜像了，这里我们只需要用该镜像创建(create，不用run)一个数据卷容器</p>
<pre><code>$ docker create --name volume-data-container volume-example:test
90cd6d51d364e6054c715f554c9a7921519ef4e4cddb2f5a54e1f86d8d202840
$ docker run -d --volumes-from volume-data-container --name volume-other volume-example:test
db57d89a10ee101df15e5fbbfa2b084526382a6ba5c15d133728011865f09a67
$ docker inspect -f {{.Mounts}} volume-data-container
[{2ce7145b0c5c286b13ef653349979a0f9f22048d6d80113b7edf98ceb61fc264 /var/lib/docker/volumes/2ce7145b0c5c286b13ef653349979a0f9f22048d6d80113b7edf98ceb61fc264/_data /test-dir local  true}]
$ docker inspect -f {{.Mounts}} volume-other
[{2ce7145b0c5c286b13ef653349979a0f9f22048d6d80113b7edf98ceb61fc264 /var/lib/docker/volumes/2ce7145b0c5c286b13ef653349979a0f9f22048d6d80113b7edf98ceb61fc264/_data /test-dir local  true}]
</code></pre><ul>
<li>可以使用超过一个的 –volumes-from 参数来指定从多个容器挂载不同的数据卷。 </li>
<li>使用 –volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。</li>
<li>也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。</li>
</ul>
<h4 id="【练习4】备份数据"><a href="#【练习4】备份数据" class="headerlink" title="【练习4】备份数据"></a>【练习4】备份数据</h4><pre><code>$  sudo docker run  --volumes-from volume-data-container -v ~/backup:/backup --name volume-backup volume-example:test tar cvf /backup/backup.tar /test-dir
test-dir/
test-dir/test.yml
</code></pre><ul>
<li>首先利用<code>volume-example:test</code>镜像创建了一个叫做<code>volume-backup</code>的容器。</li>
<li>使用<code>--volumes-from volume-data-container</code>来让<code>volume-backup</code>容器挂载<code>volume-data-container</code>的数据卷。</li>
<li>使用-v参数挂载本地的<code>~/backup</code>目录到容器的<code>/backup</code>目录下。</li>
<li><p>容器启动之后，使用了<code>tar cvf /backup/backup.tar /test-dir</code>来将数据容器<code>/test-dir</code>下的内容备份为<code>/backup/backup.tar</code>(对应到宿主机下~/bakup.tar)。</p>
<p>  $ ls ~/backup/<br>  backup.tar</p>
</li>
</ul>
<h4 id="【练习5】恢复数据"><a href="#【练习5】恢复数据" class="headerlink" title="【练习5】恢复数据"></a>【练习5】恢复数据</h4><p>1）创建一个带有数据卷的容器</p>
<pre><code>$ sudo docker run -v /test-dir --name volumn-data-container2 volume-example:test /bin/sh 
</code></pre><p>2）创建另外一个新的容器，挂载上面的数据卷容器，并使用untar解压备份文件到所挂载的容器卷</p>
<pre><code>$ sudo docker run --volumes-from volumn-data-container2 -v ~/backup:/backup busybox tar xvf /backup/backup.tar
</code></pre><h4 id="【练习6】删除数据卷"><a href="#【练习6】删除数据卷" class="headerlink" title="【练习6】删除数据卷"></a>【练习6】删除数据卷</h4><p>如果你已经使用docker rm来删除你的容器，那可能有很多的孤立的Volume仍在占用着空间。</p>
<p>Volume只有在下列情况下才能被删除：</p>
<ul>
<li>该容器是用docker rm －v命令来删除的（-v是必不可少的）。</li>
<li>docker run中使用了–rm参数</li>
<li>手动去<code>/var/lib/docker/volumes/</code>删除</li>
</ul>
<h3 id="3-数据卷和数据卷容器的比较"><a href="#3-数据卷和数据卷容器的比较" class="headerlink" title="3. 数据卷和数据卷容器的比较"></a>3. 数据卷和数据卷容器的比较</h3><img src="/imgs/docker-volumn-vs-container.png" width="500" height="250">
<h2 id="六、卷插件"><a href="#六、卷插件" class="headerlink" title="六、卷插件"></a>六、卷插件</h2><p>数据卷<br>优点：</p>
<ul>
<li>跟主机磁盘性能一样</li>
<li>容器删除后依然保留</li>
</ul>
<p>缺点：</p>
<ul>
<li>仅限本地磁盘</li>
<li>不能随容器迁移</li>
</ul>
<p>Docker推出了Volume plugin接口机制，让第三方的存储厂商来支持Docker Volume并且在此基础上进行功能拓展。</p>
<img src="/imgs/docker-volumn-plugin.png" width="500" height="250">
<ul>
<li><p>Rancher Convoy：Convoy是Rancher Labs用go开发的支持Device Mapper、NFS、EBS、GlusterFS多种后端存储的Docker Volume plugin driver. Convoy还提供了一个存储拓展功能（如快照、备份恢复等）的接口框架。</p>
</li>
<li><p>Flocker：Flocker volume plugin driver主要用于多主机环境Docker数据卷的迁移，从而支持数据库应用等stateful有状态应用的主机间迁移。</p>
</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>　　本篇文章主要是讲述了Docker的数据存储以及数据管理。<br><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">下一篇</a>将讲述Docker的网络。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://dockone.io/article/1257" target="_blank" rel="external">Docker容器对存储的定义</a></li>
<li><a href="http://dockone.io/article/1729" target="_blank" rel="external">Docker存储方式选型建议</a></li>
<li><a href="https://medium.com/@ramangupta/why-docker-data-containers-are-good-589b3c6c749e" target="_blank" rel="external">Why Docker Data Containers (Volumes!) are Good</a></li>
<li><a href="https://rominirani.com/docker-tutorial-series-part-7-data-volumes-93073a1b5b72" target="_blank" rel="external">Data Volumes</a></li>
<li><a href="http://container-solutions.com/understanding-volumes-docker/" target="_blank" rel="external">Understanding Volumes in Docker</a></li>
<li><a href="http://clusterhq.com/2015/12/09/difference-docker-volumes-flocker-volumes/" target="_blank" rel="external">Docker Volumes vs Docker Volumes with Flocker</a></li>
<li><a href="http://feisky.xyz/docker/data_management/volume.html" target="_blank" rel="external">Docker数据管理</a></li>
<li><a href="http://www.ywnds.com/?p=7015" target="_blank" rel="external">Docker：容器数据管理</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;　　&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇 Docker的基本操作&lt;/a&gt;按照构建流程练习了docker的一些常见基本指令。&lt;br&gt;本篇主要讲述Docker数据管理相关的内容。&lt;/p&gt;
&lt;h2 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h2&gt;&lt;p&gt;　　该系列《Docker in Prodcution》内容包含如下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;容器简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker的基本操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker数据存储&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;多主机部署&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;日志、跟踪、监控&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本章主要通过练习&lt;code&gt;数据卷&lt;/code&gt;和&lt;code&gt;数据卷容器&lt;/code&gt;来理解Docker的数据管理。&lt;/p&gt;
&lt;h2 id=&quot;三、Docker的存储方式&quot;&gt;&lt;a href=&quot;#三、Docker的存储方式&quot; class=&quot;headerlink&quot; title=&quot;三、Docker的存储方式&quot;&gt;&lt;/a&gt;三、Docker的存储方式&lt;/h2&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Workshop（三）Docker的基本操作</title>
    <link href="http://yoursite.com/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/07/11/Docker-workshop-3-Docker的基本操作/</id>
    <published>2017-07-11T14:08:27.000Z</published>
    <updated>2017-12-27T07:12:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>　　<a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">上一篇 Docker简介</a>讲述了Docker相关的理论知识，了解了Docker的场景及优势，练习了内核的namespace以及cgroup。<br>　　本篇将开始实际动手操作，熟悉docker基本的指令。</p>
<h3 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h3><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">容器简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">Docker简介</a></li>
<li><strong>Docker的基本操作</strong></li>
<li><a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">Docker数据存储</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">Docker网络</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/" target="_blank" rel="external">Docker安全</a></li>
<li>多主机部署</li>
<li>服务发现</li>
<li>日志、跟踪、监控</li>
</ul>
<p>本章通过以下系列过程，来熟悉Docker的基本指令：</p>
<ul>
<li>构建镜像；</li>
<li>搭建私有registry；</li>
<li>上传镜像、获取镜像；</li>
<li>创建容器、运行容器；</li>
<li>连接容器</li>
<li>使用Docker-compose工具</li>
</ul>
<h3 id="三、Docker镜像"><a href="#三、Docker镜像" class="headerlink" title="三、Docker镜像"></a>三、Docker镜像</h3><a id="more"></a>
<h4 id="1-镜像是什么"><a href="#1-镜像是什么" class="headerlink" title="1. 镜像是什么"></a>1. 镜像是什么</h4><p>　　Docker镜像是一个特殊的<strong>文件系统</strong>，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>镜像通常包含：</p>
<ul>
<li>一个轻量级的操作系统发行版</li>
<li>相关依赖</li>
<li>单个应用或服务</li>
</ul>
<h4 id="2-镜像的分层存储"><a href="#2-镜像的分层存储" class="headerlink" title="2. 镜像的分层存储"></a>2. 镜像的分层存储</h4><p>　　传统的Linux加载bootfs时会先将rootfs设为read-only，然后在系统自检之后将rootfs从read-only改为read-write，然后我们就可以在rootfs上进行写和读的操作了。<br>　　但Docker的镜像却不是这样，它在bootfs自检完毕之后并不会把rootfs的read-only改为read-write。而是利用union mount（UnionFS的一种挂载机制）将一个或多个read-only的rootfs加载到之前的read-only的rootfs层之上。</p>
<img src="/imgs/docker-image-layer1.png" width="400" height="250">
<p>可以通过<code>docker info</code>查看宿主机上docker的文件系统方式：</p>
<pre><code>$ docker info
Containers: 3
Images: 267
Server Version: 1.9.1
Storage Driver: aufs
 Root Dir: /var/lib/docker/aufs
 Backing Filesystem: extfs
 Dirs: 273
 Dirperm1 Supported: true
Execution Driver: native-0.2
Logging Driver: json-file
Kernel Version: 3.19.0-32-generic
Operating System: Ubuntu 14.04.3 LTS
CPUs: 2
Total Memory: 3.431 GiB
Name: workshop
id=: 27OE:SE73:WCPT:366X:CCGS:G2NQ:RB2A:UVJ2:A3OC:CZUJ:RYCB:XDDE
WARNING: No swap limit support
</code></pre><h4 id="3-练习构建镜像"><a href="#3-练习构建镜像" class="headerlink" title="3. 练习构建镜像"></a>3. 练习构建镜像</h4><p>　　<a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">上一篇</a>讲到获取镜像有三种方式，其中自己从无到有地创建镜像，Docker有两种方式：</p>
<ul>
<li>创建一个容器，运行若干命令，再使用<code>docker commit</code>来生成一个新的镜像。以这种方式创建的镜像不具备再生产能力且无法实现版本控制性，因此绝对<strong>不值得提倡</strong>。</li>
<li>创建一个<code>Dockerfile</code>然后再使用<code>docker build</code>来创建一个镜像。大多人会使用<code>Dockerfile</code>来创建镜像。</li>
</ul>
<h4 id="【练习1】通过Dockerfile构建镜像"><a href="#【练习1】通过Dockerfile构建镜像" class="headerlink" title="【练习1】通过Dockerfile构建镜像"></a>【练习1】通过Dockerfile构建镜像</h4><p>1）创建一个Dockerfile<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">FROM</span> <span class="attr">debian:8</span></div><div class="line"><span class="string">MAINTAINER</span> <span class="string">John</span> <span class="string">Citizen</span></div><div class="line"><span class="string">RUN</span> <span class="string">apt-get</span> <span class="string">update</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></div><div class="line"><span class="string">apt-get</span> <span class="string">install</span> <span class="bullet">-y</span> <span class="string">nginx</span></div><div class="line"><span class="string">EXPOSE</span> <span class="number">80</span></div><div class="line"><span class="string">CMD</span> <span class="string">["nginx",</span> <span class="string">"-g"</span><span class="string">,</span> <span class="string">"daemon off;"</span><span class="string">]</span></div></pre></td></tr></table></figure></p>
<img src="/imgs/docker-image-layers-history.png" width="500" height="350">
<p>2）生成镜像<br><code>docker build -t nginx-demo .</code>其中<code>.</code>是当前目录，包含<code>Dockerfile</code>文件</p>
<pre><code>$ docker build -t nginx-demo .
Sending build context to Docker daemon 7.168 kB
Step 1 : FROM debian:8
8: Pulling from library/debian
aaec12cbddb4: Pull complete
a4231e14d761: Pull complete
Digest: sha256:64682f1a6d256b358b10dba3669b22f3594c69ec790548f5ba6362276ac9d4ca
Status: Downloaded newer image for debian:8
 ---&gt; a4231e14d761
Step 2 : MAINTAINER John Citizen
 ---&gt; Running in 35d7b813f3ec
 ---&gt; 3abd0b877321
Removing intermediate container 35d7b813f3ec
Step 3 : RUN apt-get update &amp;&amp; apt-get install -y nginx
 ---&gt; Running in f75d9c834ee9
 ---&gt; 352a72a3b8a8
Removing intermediate container f75d9c834ee9
Step 4 : EXPOSE 80
 ---&gt; Running in c9939361ce4d
 ---&gt; e55ea9a20dd4
Removing intermediate container c9939361ce4d
Step 5 : CMD nginx -g daemon off;
 ---&gt; Running in bdac893db4aa
 ---&gt; 7bd0c6e98644
Removing intermediate container bdac893db4aa
Successfully built 7bd0c6e98644
</code></pre><p>可以看到Docker会创建（create -&gt; commit -&gt; destroy）一些临时的容器，如<code>Step 2</code>的<code>35d7b813f3ec</code>，生成的新的镜像作为中间镜像会被保存在cache中。可以通过下面两种方式查看该临时容器：</p>
<pre><code>$ docker inspect 3abd0b877321
$ docker images -a |grep 3abd0b877321
</code></pre><p>3）查看所有镜像</p>
<pre><code>$ docker images
</code></pre><p>4）查看<code>nginx-demo</code>镜像信息</p>
<pre><code>$ docker inspect nginx-demo
$ docker inspect -f &apos;{{ .Config.ExposedPorts }}&apos; nginx-demo
</code></pre><p>5) 查看创建镜像的历史</p>
<pre><code>$ docker history nginx-demo:latest
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
7bd0c6e98644        5 minutes ago       /bin/sh -c #(nop) CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon o   0 B
e55ea9a20dd4        5 minutes ago       /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B
352a72a3b8a8        5 minutes ago       /bin/sh -c apt-get update &amp;&amp; apt-get install    71.8 MB
3abd0b877321        6 minutes ago       /bin/sh -c #(nop) MAINTAINER John Citizen       0 B
a4231e14d761        3 weeks ago         /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0 B
aaec12cbddb4        3 weeks ago         /bin/sh -c #(nop) ADD file:9c48682ff75c756544   123.5 MB
</code></pre><ul>
<li>容器镜像包括元数据和文件系统，其中文件系统是指对基础镜像的文件系统的修改，元数据不影响文件系统，只是会影响容器的配置;</li>
<li>每个步骤都会生成一个新的镜像，新的镜像与上一次的镜像相比，要么元数据有了变化，要么文件系统有了变化而多加了一层;</li>
<li>Docker在需要执行指令时通过创建临时镜像，运行指定的命令，再通过<code>docker commit</code>来生成新的镜像;</li>
<li>Docker会将中间镜像都保存在缓存中，这样将来如果能直接使用的话就不需要再从头创建了。</li>
<li>由于每一行指令，都会产生一个镜像，因此可以使用链式指令，有助于构建较小的镜像。(更多内容可以阅读《高性能Docker》)</li>
</ul>
<h3 id="四、Docker仓库"><a href="#四、Docker仓库" class="headerlink" title="四、Docker仓库"></a>四、Docker仓库</h3><h4 id="【练习2】使用Docker-public仓库"><a href="#【练习2】使用Docker-public仓库" class="headerlink" title="【练习2】使用Docker public仓库"></a>【练习2】使用Docker public仓库</h4><pre><code>$ docker search busybox
NAME                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
busybox                         Busybox base image.                             1052      [OK]
progrium/busybox                                                                65                   [OK]
radial/busyboxplus              Full-chain, Internet enabled, busybox made...   13                   [OK]
container4armhf/armhf-busybox   Automated build of Busybox for armhf devic...   8                    [OK]
ofayau/busybox-jvm              Prepare busybox to install a 32 bits JVM.       2                    [OK]
azukiapp/busybox                This image is meant to be used as the base...   2                    [OK]
multiarch/busybox               multiarch ports of ubuntu-debootstrap           2                    [OK]
ofayau/busybox-libc32           Busybox with 32 bits (and 64 bits) libs         1                    [OK]
skomma/busybox-data             Docker image suitable for data volume cont...   1                    [OK]
prom/busybox                    Prometheus Busybox Docker base images           1                    [OK]
elektritter/busybox-teamspeak   Leightweight teamspeak3 container based on...   1                    [OK]
clover/busybox                  BusyBox base image                              1                    [OK]
getblank/busybox                Docker container busybox for Blank              1                    [OK]
zanner/busybox                  https://github.com/sergej-kucharev/zanner-...   1                    [OK]
cucy/busybox                    aouto  build busybox                            0                    [OK]
adamant/busybox                 Busybox base image and debian package inst...   0                    [OK]
sdurrheimer/prom-busybox        Moved to https://hub.docker.com/r/prom/bus...   0                    [OK]
ggtools/busybox-ubuntu          Busybox ubuntu version with extra goodies       0                    [OK]
ddn0/busybox                    fork of official busybox                        0                    [OK]
hongtao12310/busybox            for busybox image based on the gcr.io/goog...   0                    [OK]
freenas/busybox                 Simple Busybox interactive Linux container      0                    [OK]
kakaximeng/busybox              busybox                                         0                    [OK]
jahroots/busybox                Busybox containers                              0                    [OK]
jiangshouzhuang/busybox         busybox                                         0                    [OK]
stubbornrock/busybox            busybox:latest                                  0                    [OK]

$ docker pull busybox
</code></pre><h4 id="【练习3】搭建Docker-private仓库"><a href="#【练习3】搭建Docker-private仓库" class="headerlink" title="【练习3】搭建Docker private仓库"></a>【练习3】搭建Docker private仓库</h4><p>1) 需要提前创建证书文件cert，并放到相应的地方。<br>通过<code>registry:2</code>镜像运行起了一个私有registry如下：</p>
<pre><code>docker run -d \
  -p 5000:5000 \
  --restart=always \
  --name registry \
  -v /home/vagrant/topics/tmp/registry-certs:/certs \
  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/registry_hostname.crt \
  -e REGISTRY_HTTP_TLS_KEY=/certs/registry_hostname.key \
  registry:2
</code></pre><p>2) 查看所有docker容器</p>
<pre><code>$ docker ps -a
</code></pre><p>3) 访问私有registry接口</p>
<pre><code>$ sudo curl -is --cacert /etc/docker/certs.d/registry:5000/registry.crt https://registry:5000/v2/
HTTP/1.1 200 OK
Content-Length: 2
Content-Type: application/json; charset=utf-8
Docker-Distribution-Api-Version: registry/2.0
Date: Wed, 12 Jul 2017 13:30:17 GMT
HTTP/1.1 200 OK
</code></pre><h3 id="五、发布镜像到仓库"><a href="#五、发布镜像到仓库" class="headerlink" title="五、发布镜像到仓库"></a>五、发布镜像到仓库</h3><h4 id="【练习4】上传镜像到registry"><a href="#【练习4】上传镜像到registry" class="headerlink" title="【练习4】上传镜像到registry"></a>【练习4】上传镜像到registry</h4><p>1）给镜像打标签</p>
<pre><code>$ docker tag nginx-demo registry:5000/nginx-demo
</code></pre><p>2) 查看所有镜像</p>
<pre><code>$ docker images
REPOSITORY                      TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
nginx-demo                      latest              8ef43fa97b67        About a minute ago   195.3 MB
registry:5000/nginx-demo        latest              8ef43fa97b67        About a minute ago   195.3 MB
</code></pre><p>3）上传镜像</p>
<pre><code>$ docker push registry:5000/nginx-demo
The push refers to a repository [registry:5000/nginx-demo] (len: 1)
8ef43fa97b67: Pushed
5982f0a481be: Pushed
c329ad2e9994: Pushed
cdea4d036852: Pushed
aaec12cbddb4: Pushed
latest: digest: sha256:399e271209f61771afc03896bea5cd107d2da64985b7bea6733b9380b181b31b size: 8470
</code></pre><p>4）访问registry接口查看镜像是否存在</p>
<pre><code>$ export CERT_PATH=/etc/docker/certs.d/registry:5000/registry.crt
$ sudo curl -s --cacert ${CERT_PATH} https://registry:5000/v2/_catalog
{&quot;repositories&quot;:[&quot;nginx-demo&quot;]}
</code></pre><p>5) 删除本地镜像</p>
<pre><code>$ docker rmi nginx-demo
Untagged: nginx-demo:latest
Deleted: 7bd0c6e986444a5855665a4b746130088904bc5b7626d5bb5c0dc3ab52fc1142
Deleted: e55ea9a20dd4b5d4ede4a4873e18e94f139df646085c79c83d12f71815559dda
Deleted: 352a72a3b8a8ad51f8a84a357fcb3af0a127c8cefc34b6d5839fdcd8c06ececd
Deleted: 3abd0b8773212881d3e73babe2304d5b760c0b156095bd9496ceb2fedf71fd62
</code></pre><p>6）从私有registry上拉取镜像</p>
<pre><code>$ docker pull registry:5000/nginx-demo
Using default tag: latest
latest: Pulling from nginx-demo
31f1e1f22679: Pull complete
51c8e8d08671: Pull complete
04ec693a6b9c: Pull complete
ae06ee9e3b16: Pull complete
59c395799b5f: Pull complete
26d4e0d847a6: Pull complete
Digest: sha256:399e271209f61771afc03896bea5cd107d2da64985b7bea6733b9380b181b31b
Status: Downloaded newer image for registry:5000/nginx-demo:latest
</code></pre><h3 id="六、启动Docker容器"><a href="#六、启动Docker容器" class="headerlink" title="六、启动Docker容器"></a>六、启动Docker容器</h3><h4 id="【练习5】启动Docker容器"><a href="#【练习5】启动Docker容器" class="headerlink" title="【练习5】启动Docker容器"></a>【练习5】启动Docker容器</h4><p>1) 启动一个容器</p>
<pre><code>$ docker run -d -p 80:80 --name nginx-app registry:5000/nginx-demo
a56d494e8af22247eccbd7e99f108501684b52395a50f479cca09caa8ec18b19
$ docker ps
CONTAINER ID        IMAGE                      COMMAND                  CREATED             STATUS              PORTS                    NAMES
a56d494e8af2        registry:5000/nginx-demo   &quot;nginx -g &apos;daemon off&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:80-&gt;80/tcp       nginx-app
7d01136fd367        registry:2                 &quot;/bin/registry /etc/d&quot;   22 minutes ago      Up 22 minutes       0.0.0.0:5000-&gt;5000/tcp   registry
</code></pre><p>此处用<code>docker run</code>是创建并启动，<code>docker create</code>是单纯创建容器。<br>2）查看容器log</p>
<pre><code>$ docker logs nginx-app
</code></pre><h3 id="七、连接Docker容器"><a href="#七、连接Docker容器" class="headerlink" title="七、连接Docker容器"></a>七、连接Docker容器</h3><h4 id="【练习6】连接多个Docker容器"><a href="#【练习6】连接多个Docker容器" class="headerlink" title="【练习6】连接多个Docker容器"></a>【练习6】连接多个Docker容器</h4><p>假设我们有如下三个应用，且都已经publish到了registry中：</p>
<ul>
<li>shop-app，需要连接review和catalogue</li>
<li>review，微服务</li>
<li>catalogue，微服务</li>
</ul>
<p>1）先启动<code>review</code>和<code>catalogue</code></p>
<pre><code>$ docker run -d -p 8082:8082 --name review registry:5000/review
$ docker run -d -p 8084:8084 --name catalogue registry:5000/catalogue
</code></pre><p>2）连接<code>shop-app</code>到<code>review</code>和<code>catalogue</code></p>
<pre><code>$ docker run -d -p 8080:8080 --name shop-app --link review:review --link catalogue:catalogue registry:5000/shop-app
</code></pre><p>3）查看<code>shop-app</code>容器</p>
<pre><code>$ docker exec shop-app cat /etc/hosts
</code></pre><p>4）确认<code>shop-app</code>可以连接到<code>review</code></p>
<pre><code>$ docker exec -t shop-app ping review
</code></pre><p>　　以下是Docker link的一些限制：</p>
<ul>
<li>Docker link 只在同一宿主机内可以使用</li>
<li>重新创建容器将会移除之前的链接</li>
<li>被连接的容器必须是一个已经启动的容器</li>
</ul>
<p>　　在Docker发布1.9版本的时候推荐使用<code>Docker Networks</code>代替<code>Docker link</code>，后面的<a href="">Docker Workshop（五）Docker网络</a>会讲到Docker Networks。</p>
<h3 id="八、使用Docker-Compose"><a href="#八、使用Docker-Compose" class="headerlink" title="八、使用Docker Compose"></a>八、使用Docker Compose</h3><p>　　Compose是用于定义和运行复杂Docker应用的工具。你可以在一个文件中定义一个多容器的应用，然后使用一条命令来启动你的应用，然后所有相关的操作都会被自动完成。</p>
<h4 id="【练习7】使用Docker-compose工具"><a href="#【练习7】使用Docker-compose工具" class="headerlink" title="【练习7】使用Docker compose工具"></a>【练习7】使用Docker compose工具</h4><p>1）创建一个<code>docker-compose.yml</code>文件<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="attr">shop-app:</span></div><div class="line"><span class="attr">  image:</span> <span class="attr">registry:5000/shop-app</span></div><div class="line"><span class="attr">  ports:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">"8080:8080"</span></div><div class="line"><span class="attr">  links:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">review</span></div><div class="line"><span class="bullet">    -</span> <span class="string">catalogue</span></div><div class="line"></div><div class="line"><span class="attr">review:</span></div><div class="line"><span class="attr">  image:</span> <span class="attr">registry:5000/review</span></div><div class="line"></div><div class="line"><span class="attr">catalogue:</span></div><div class="line"><span class="attr">  image:</span> <span class="attr">registry:5000/catalogue</span></div></pre></td></tr></table></figure></p>
<p>2) 启动三个容器</p>
<pre><code>$ docker-compose up
</code></pre><p>3） 查看运行的容器</p>
<pre><code>$ docker-compose ps
</code></pre><p>3）查看log</p>
<pre><code>$ docker-compose logs
</code></pre><p><code>docker-compose</code>可以查看所有在<code>docker-compose.yml</code>中声明的容器的日志，不用切换tab查看单独的docker容器日志。</p>
<h3 id="九、使用容器时要避免的做法"><a href="#九、使用容器时要避免的做法" class="headerlink" title="九、使用容器时要避免的做法"></a>九、使用容器时要避免的做法</h3><ul>
<li>不要在容器中保存数据（Don’t store data in containers）</li>
<li>将应用打包到镜像再部署而不是更新到已有容器（Don’t ship your application in two pieces）</li>
<li>不要产生过大的镜像 （Don’t create large images）</li>
<li>不要使用单层镜像 （Don’t use a single layer image）</li>
<li>不要从运行着的容器上产生镜像 （Don’t create images from running containers ）</li>
<li>不要只是使用 “latest”标签 （Don’t use only the “latest” tag）</li>
<li>不要在容器内运行超过一个的进程 （Don’t run more than one process in a single container ）</li>
<li>不要在容器内保存 credentials，而是要从外面通过环境变量传入 （ Don’t store credentials in the image. Use environment variables）</li>
<li>不要使用 root 用户跑容器进程（Don’t run processes as a root user ）</li>
<li>不要依赖于IP地址，而是要从外面通过环境变量传入 （Don’t rely on IP addresses ）</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>　　本篇文章主要是按照构建流程练习了docker的一些常见基本指令，指令并不全面，详细的指令可以参考<a href="https://docs.docker.com/engine/reference/commandline/docker/#parent-command" target="_blank" rel="external">官网</a>进行练习。<br>　　<a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">下一篇</a>将讲述Docker的数据存储。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="http://feisky.xyz/docker/index.html" target="_blank" rel="external">Docker笔记</a></li>
<li><a href="https://developers.redhat.com/blog/2016/02/24/10-things-to-avoid-in-docker-containers/" target="_blank" rel="external">10 things to avoid in docker containers</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;　　&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇 Docker简介&lt;/a&gt;讲述了Docker相关的理论知识，了解了Docker的场景及优势，练习了内核的namespace以及cgroup。&lt;br&gt;　　本篇将开始实际动手操作，熟悉docker基本的指令。&lt;/p&gt;
&lt;h3 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h3&gt;&lt;p&gt;　　该系列《Docker in Prodcution》内容包含如下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;容器简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker的基本操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker数据存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;多主机部署&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;日志、跟踪、监控&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本章通过以下系列过程，来熟悉Docker的基本指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建镜像；&lt;/li&gt;
&lt;li&gt;搭建私有registry；&lt;/li&gt;
&lt;li&gt;上传镜像、获取镜像；&lt;/li&gt;
&lt;li&gt;创建容器、运行容器；&lt;/li&gt;
&lt;li&gt;连接容器&lt;/li&gt;
&lt;li&gt;使用Docker-compose工具&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;三、Docker镜像&quot;&gt;&lt;a href=&quot;#三、Docker镜像&quot; class=&quot;headerlink&quot; title=&quot;三、Docker镜像&quot;&gt;&lt;/a&gt;三、Docker镜像&lt;/h3&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Workshop（二）Docker简介</title>
    <link href="http://yoursite.com/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/07/10/Docker-workshop-2-Docker简介/</id>
    <published>2017-07-10T00:59:59.000Z</published>
    <updated>2017-12-27T07:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>　　容器技术已经出现了相当一段时间了，例如LXC, BSD Jails, Solaris Zones… 那为什么出现了Docker，中间缺失了什么呢？<br>　　<a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">上一篇</a>讲述了容器相关的知识，练习了LXC容器的相关指令，本篇接着讲述Docker的出现以及Docker相关的理论基础。</p>
<h3 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h3><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">容器简介</a></li>
<li><strong>Docker简介</strong></li>
<li><a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">Docker的基本操作</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">Docker数据存储</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">Docker网络</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/" target="_blank" rel="external">Docker安全</a></li>
<li>多主机部署</li>
<li>服务发现</li>
<li>日志、跟踪、监控</li>
</ul>
<h3 id="三、从Linux容器到Docker"><a href="#三、从Linux容器到Docker" class="headerlink" title="三、从Linux容器到Docker"></a>三、从Linux容器到Docker</h3><a id="more"></a>
<blockquote>
<p>尽管有着光辉的历史，容器仍未得到广泛的认可。一个很重要的原因就是容器技术的复杂性：容器本身就比较复杂，不易安装 管理和自动化也很困难。而Docker就是为了改变这一切而生 ——《第一本Docker书》</p>
</blockquote>
<p>　　<a href="http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8/" target="_blank" rel="external">上一篇</a>练习里，我们可以明显感受到，LXC存在的问题是难以移动——难以通过标准化的模板制作、重建、复制和移动container。</p>
<p>　　在LXC的基础上，Docker进一步优化了容器的使用体验。Docker提供了各种容器管理工具（如：<strong>分发、版本、移植</strong>等）让用户无需关注底层的操作，可以更简单的管理和使用容器。</p>
<p>　　早期的Docker代码实现是直接基于LXC的。自0.9版本开始，Docker开发了libcontainer项目，作为更广泛的容器驱动实现，从而替换掉了LXC的实现。</p>
<blockquote>
<p>Docker官网上对于<a href="https://docs.docker.com/engine/faq/#what-open-source-license-are-you-using" target="_blank" rel="external">Docker在单纯的LXC之上做了哪些事情</a>的解释：</p>
<ul>
<li>Portable deployment across machines(跨主机可移植性部署)</li>
<li>Application-centric(以应用为中心)</li>
<li>Automatic build(自动构建)</li>
<li>Versioning(版本)</li>
<li>Component re-use(组件重用)</li>
<li>Sharing(共享)</li>
<li>Tool ecosystem(工具生态系统)</li>
</ul>
</blockquote>
<h3 id="四、Docker是什么？"><a href="#四、Docker是什么？" class="headerlink" title="四、Docker是什么？"></a>四、Docker是什么？</h3><p>　　Docker是一个开源的引擎，可以轻松的为任何应用创建一个<strong>轻量级的、可移植的、自给自足的</strong>容器。</p>
<p>　　Docker可以让你将所有应用软件以及它的依赖打包成软件开发的标准化单元。</p>
<p>　　Docker容器将软件以及它运行安装所需的一切文件（代码、运行时、系统工具、系统库）打包到一起，这就保证了不管是在什么样的运行环境，总是能以相同的方式运行。就好像 Java 虚拟机一样，“一次编写，到处运行（Write once, run anywhere）”，而 Docker 是“一次构建，到处运行（Build once，run anywhere）”。</p>
<h3 id="五、Docker与Microservices的关系"><a href="#五、Docker与Microservices的关系" class="headerlink" title="五、Docker与Microservices的关系"></a>五、Docker与Microservices的关系</h3><p>　　Microservices（微服务）依赖于“基础设施自动化”，而Docker正是“基础设施自动化”的利器。可以说Docker的火爆，一定程度上也带动了微服务架构的兴起，而微服务的广泛应用也促进了Docker 繁荣，可以说两者相辅相成。</p>
<h3 id="六、为什么使用Docker？"><a href="#六、为什么使用Docker？" class="headerlink" title="六、为什么使用Docker？"></a>六、为什么使用Docker？</h3><h4 id="1-Why-Docker"><a href="#1-Why-Docker" class="headerlink" title="1. Why Docker?"></a>1. Why Docker?</h4><p>　　按照当前官网<a href="https://docs.docker.com/engine/#why-docker" target="_blank" rel="external">Why Docker?</a>的解释，主要有四个方面：</p>
<h5 id="1-1更快速的交付应用（Faster-delivery-of-your-applications）"><a href="#1-1更快速的交付应用（Faster-delivery-of-your-applications）" class="headerlink" title="1.1更快速的交付应用（Faster delivery of your applications）"></a>1.1更快速的交付应用（Faster delivery of your applications）</h5><ul>
<li>借助于Docker容器，程序开发员，系统管理员甚至QA和版本控制工程师都可以进行协同工作。Docker创建了一套标准的容器数据格式，在这套标准数据格式基础上，当系统管理员管理操作容器时，程序开发员不需要关心容器的变化，这样就可以更专心的关注自己的应用代码。而这种管理和开发的任务隔离，大大的简化了开发和部署的成本。</li>
<li>Docker容器的创建非常容易，这样应用程序就可以进行快速迭代开发，从而缩短产品的上市周期。</li>
<li>Docker的容器属于轻量级的容器，因此启动和停止都特别快。容器启动只需要毫秒级的时间，因此在进行开发、测试和部署各个环境之间切换时几乎感受不到时间的流失。</li>
</ul>
<h5 id="1-2-更轻松的部署和扩展（Deploy-and-scale-more-easily）"><a href="#1-2-更轻松的部署和扩展（Deploy-and-scale-more-easily）" class="headerlink" title="1.2 更轻松的部署和扩展（Deploy and scale more easily）"></a>1.2 更轻松的部署和扩展（Deploy and scale more easily）</h5><ul>
<li>Docker容器几乎可以在任何地方执行，至少在理论层面是可以再任意地方执行。Dokcer可以在桌面操作系统，物理服务器，虚拟机，数据中心或者共有/私有云上面执行。</li>
<li>因为Docker容器可以在各种环境下运行，因此容器之间的迁移也非常方便。你可以非常方便的将容器从测试环境迁移到云环境中。</li>
</ul>
<h5 id="1-3-更多的工作负载（Get-higher-density-and-run-more-workloads）"><a href="#1-3-更多的工作负载（Get-higher-density-and-run-more-workloads）" class="headerlink" title="1.3 更多的工作负载（Get higher density and run more workloads）"></a>1.3 更多的工作负载（Get higher density and run more workloads）</h5><ul>
<li>Docker的容器本身不需要额外创建虚拟机管理系统，因此你可以启动多套Docker容器，这样就可以充分发挥主机服务器的物理资源，也可以降低因为采购服务器licenses而带来的额外成本。</li>
</ul>
<h5 id="1-4-更简单的管理（Faster-deployment-makes-for-easier-management）"><a href="#1-4-更简单的管理（Faster-deployment-makes-for-easier-management）" class="headerlink" title="1.4 更简单的管理（Faster deployment makes for easier management）"></a>1.4 更简单的管理（Faster deployment makes for easier management）</h5><ul>
<li>Docker快速部署和轻量级的特性，可以使应用快速迭代。同时所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</li>
</ul>
<h4 id="2-Docker的使用场景"><a href="#2-Docker的使用场景" class="headerlink" title="2. Docker的使用场景"></a>2. Docker的使用场景</h4><ul>
<li>简化配置</li>
<li>代码流水线（Code Pipeline）管理</li>
<li>提高开发效率</li>
<li>隔离应用</li>
<li>整合服务器</li>
<li>调适能力</li>
<li>多租户环境</li>
<li>快速部署</li>
</ul>
<h3 id="七、Docker的组件"><a href="#七、Docker的组件" class="headerlink" title="七、Docker的组件"></a>七、Docker的组件</h3><p>Docker主要包括两个大组件：</p>
<ul>
<li><p>The Docker Engine<br>　　Docker Engine是基于虚拟化技术的一个轻量级的并且功能非常强大的开源容器管理工具。它可以将不同的work flow组合起来，然后构建或者管理你的容器。</p>
</li>
<li><p>Docker Hub<br>　　一个分享和管理你所创建的image的SAAS（Software-as-a-Service）平台。</p>
</li>
</ul>
<h3 id="八、Docker的架构"><a href="#八、Docker的架构" class="headerlink" title="八、Docker的架构"></a>八、Docker的架构</h3><p>　　Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。</p>
<img src="/imgs/docker-architecture.svg" width="500" height="400">
<p>　　Docker的核心组件：</p>
<ul>
<li>Docker 客户端 - Client</li>
<li>Docker 服务器 - Docker daemon</li>
<li>Docker 镜像 - Image</li>
<li>Docker 容器 - Container</li>
<li>Registry</li>
</ul>
<h4 id="1-Docker-客户端"><a href="#1-Docker-客户端" class="headerlink" title="1. Docker 客户端"></a>1. Docker 客户端</h4><p>　　最常用的 Docker 客户端是 docker 命令。通过 docker 我们可以方便地在 Host 上构建和运行容器。<br>　　除了 docker 命令行工具，用户也可以通过 REST API 与服务器通信。</p>
<h4 id="2-Docker-服务器"><a href="#2-Docker-服务器" class="headerlink" title="2. Docker 服务器"></a>2. Docker 服务器</h4><p>　　Docker daemon 是服务器组件，以 Linux 后台服务的方式运行，所谓“运行 docker”，指的就是运行 Docker daemon。<br>　　Docker daemon 运行在 Docker host 上，负责创建、运行、监控容器，构建、存储镜像。</p>
<h4 id="3-Docker镜像"><a href="#3-Docker镜像" class="headerlink" title="3.Docker镜像"></a>3.Docker镜像</h4><p>　　可将 Docker 镜像看着只读模板，通过它可以创建 Docker 容器。<br>镜像有多种生成方法：</p>
<ul>
<li>可以从无到有开始创建镜像</li>
<li>也可以下载并使用别人创建好的现成的镜像</li>
<li>还可以在现有镜像上创建新的镜像</li>
</ul>
<p>在<a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">下一篇 Docker的基本操作</a>里会有对镜像的详细介绍。</p>
<h4 id="4-Docker容器"><a href="#4-Docker容器" class="headerlink" title="4. Docker容器"></a>4. Docker容器</h4><p>　　Docker 容器就是 Docker 镜像的运行实例。用户可以通过 CLI（docker）或是 API 启动、停止、移动或删除容器。可以这么认为，对于应用软件，镜像是软件生命周期的构建和打包阶段，而容器则是启动和运行阶段。<br>　　总结起来，Docker容器就是：</p>
<ul>
<li>一个镜像格式</li>
<li>一系列标准的操作</li>
<li>一个执行环境</li>
</ul>
<h4 id="5-Registry"><a href="#5-Registry" class="headerlink" title="5.Registry"></a>5.Registry</h4><p>　　Docker用Registry保存用户构建的镜像。<br>Registry 分私有和公有两种：</p>
<ul>
<li><a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>是默认的 Registry，由 Docker公司维护，上面有数以万计的镜像，用户可以自由下载和使用。</li>
<li>出于对速度或安全的考虑，用户也可以创建自己的私有Registry</li>
</ul>
<h3 id="九、Docker核心技术"><a href="#九、Docker核心技术" class="headerlink" title="九、Docker核心技术"></a>九、Docker核心技术</h3><img src="/imgs/docker-core-tech.png" width="300" height="150">
<p>　　Docker核心是一个操作系统级虚拟化方法, 理解起来可能并不像VM那样直观。我们从虚拟化方法的四个方面：隔离性、可配额/可度量、便携性、安全性来详细介绍Docker的技术细节。</p>
<img src="/imgs/docker-core-engine.png" width="300" height="150">
<h4 id="1-隔离性-namespace资源隔离"><a href="#1-隔离性-namespace资源隔离" class="headerlink" title="1. 隔离性: namespace资源隔离"></a>1. 隔离性: namespace资源隔离</h4><ul>
<li>pid：每个容器都运行在自己的进程环境中；</li>
<li>user：在container内部用container内部的用户执行程序而非Host上的用户。</li>
<li>net：容器间的虚拟网络接口和IP地址都是分开的；</li>
<li>mnt：允许不同namespace的进程看到的文件结构不同；</li>
<li>uts：UNIX Time-sharing System,使其在网络上可以被视作一个独立的节点而非Host上的一个进程；</li>
<li>ipc：进程间交互；</li>
</ul>
<p>　　例如：在主机和docker容器里，都可以拥有自己的init进程（PID=1），init进程是所有其他进程的祖先进程，docker容器其实是主机里的一个进程。<br><img src="/imgs/docker-namespace-pid.png" width="300" height="150"></p>
<h4 id="2-可配额-可度量：cgroups资源限制"><a href="#2-可配额-可度量：cgroups资源限制" class="headerlink" title="2. 可配额/可度量：cgroups资源限制"></a>2. 可配额/可度量：cgroups资源限制</h4><p>　　cgroups是Linux内核提供的一种机制，用来限制、控制与分离一个进程组群的资源（如CPU、Memory、IO等）</p>
<p>主要提供了如下功能:</p>
<ul>
<li>资源限制：限制任务使用的资源总额，并在超过这个配额时发出提示</li>
<li>优先级分配：分配CPU时间片数量及磁盘IO带宽大小、控制任务运行的优先级</li>
<li>资源统计：统计系统资源使用量，如CPU使用时长、内存用量等</li>
<li>任务控制：对任务执行挂起、恢复等操作</li>
</ul>
<p>　　在实践中，系统管理员一般会利用cgroup做下面这些事（有点像为某个虚拟机分配资源似的）：</p>
<ul>
<li>隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。</li>
<li>为这组进程分配其足够使用的内存</li>
<li>为这组进程分配相应的网络带宽和磁盘存储限制</li>
<li>限制访问某些设备（通过设置设备的白名单)</li>
</ul>
<h4 id="3-便携性-文件系统"><a href="#3-便携性-文件系统" class="headerlink" title="3. 便携性: 文件系统"></a>3. 便携性: 文件系统</h4><p>　　最初docker仅能在支持Aufs文件系统的Linux发行版上运行，但是由于Aufs未能加入linux内核，为了寻求兼容性、扩展性，Docker在内部通过graphdriver机制这种可扩展的方式来实现对不同文件系统的支持。目前，Docker支持Aufs，Devicemapper，Btrfs和Vfs四种文件系统。</p>
<p>　　典型的Linux文件系统由bootfs和rootfs两部分组成，bootfs(boot file system)主要包含 bootloader和kernel，bootloader主要是引导加载kernel，当kernel被加载到内存中后 bootfs就被umount了。 rootfs (root file system) 包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件。<br><img src="/imgs/docker-aufs1.png" width="300" height="150"></p>
<p>　　对于不同的linux发行版，bootfs基本是一致的，但rootfs会有差别，因此不同的发行版可以公用bootfs:<br><img src="/imgs/docker-aufs2.png" width="300" height="150"></p>
<h4 id="4-安全性-AppArmor-SELinux-GRSEC"><a href="#4-安全性-AppArmor-SELinux-GRSEC" class="headerlink" title="4. 安全性: AppArmor, SELinux, GRSEC"></a>4. 安全性: AppArmor, SELinux, GRSEC</h4><p>　　安全永远是相对的，这里有三个方面可以考虑Docker的安全特性:</p>
<ul>
<li>由kernel namespaces和cgroups实现的Linux系统固有的安全标准;</li>
<li>Docker Deamon的安全接口;</li>
<li>Linux本身的安全加固解决方案,类如AppArmor, SELinux;</li>
</ul>
<h3 id="十、内核机制的练习"><a href="#十、内核机制的练习" class="headerlink" title="十、内核机制的练习"></a>十、内核机制的练习</h3><h4 id="【练习1】命名空间的练习"><a href="#【练习1】命名空间的练习" class="headerlink" title="【练习1】命名空间的练习"></a>【练习1】命名空间的练习</h4><pre><code># 创建一个Docker容器
$ docker run -it --rm busybox

# 列出所有的namespace
$ ls -l /proc/$$/ns
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 mnt -&gt; mnt:[4026531840]
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 net -&gt; net:[4026531957]
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 pid -&gt; pid:[4026531836]
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 user -&gt; user:[4026531837]
lrwxrwxrwx 1 vagrant vagrant 0 Jul 11 13:04 uts -&gt; uts:[4026531838]

# 查看 pid namespace:
$ ps aux

# 查看 mnt namespace:
$ cat /proc/mounts

# 查看 uts namespace
$ hostname

# 查看 ipc namespace
$ ipcs

# 在宿主机里使用ipcmk -Q命令创建一个message queue
$ ipcmk -Q
Message queue id: 0

# 再次查看宿主机ipc namespace
$ ipcs

# 在容器里查看ipc namespace
$ ipcs
</code></pre><p>退出容器，按<code>ctrl + d</code></p>
<h4 id="【练习2】cgroup的练习"><a href="#【练习2】cgroup的练习" class="headerlink" title="【练习2】cgroup的练习"></a>【练习2】cgroup的练习</h4><pre><code># 列出所有的subsystem
$ ls /sys/fs/cgroup/ -l
dr-xr-xr-x 4 root root  0 Jul 11 12:47 blkio
drwxr-xr-x 2 root root 60 Jul 11 12:47 cgmanager
dr-xr-xr-x 4 root root  0 Jul 11 12:47 cpu
dr-xr-xr-x 4 root root  0 Jul 11 12:47 cpuacct
dr-xr-xr-x 4 root root  0 Jul 11 12:47 cpuset
dr-xr-xr-x 4 root root  0 Jul 11 12:47 devices
dr-xr-xr-x 4 root root  0 Jul 11 12:47 freezer
dr-xr-xr-x 4 root root  0 Jul 11 12:47 hugetlb
dr-xr-xr-x 4 root root  0 Jul 11 12:47 memory
dr-xr-xr-x 4 root root  0 Jul 11 12:47 net_cls
dr-xr-xr-x 4 root root  0 Jul 11 12:47 net_prio
dr-xr-xr-x 4 root root  0 Jul 11 12:47 perf_event
dr-xr-xr-x 3 root root  0 Jul 11 12:47 systemd
</code></pre><p>　　默认情况下，Docker 启动一个容器后，会在<code>/sys/fs/cgroup</code>目录下的各个资源目录下生成以容器ID为名字的目录（group）:</p>
<pre><code>$ ls /sys/fs/cgroup/cpu/docker/654bd6413abb005ccb2e93e096151650e022132b7186171fd871cc8d5692e356
cgroup.clone_children  cpu.cfs_period_us  cpu.shares  notify_on_release
cgroup.procs           cpu.cfs_quota_us   cpu.stat    tasks
$ cat /sys/fs/cgroup/cpu/docker/654bd6413abb005ccb2e93e096151650e022132b7186171fd871cc8d5692e356/cpu.cfs_quota_us
-1
</code></pre><p>　　此时 cpu.cfs_quota_us 的内容为-1，表示默认情况下并没有限制容器的CPU使用。在容器被 stopped 后，该目录被删除。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>　　本篇文章主要是涉及docker的基础理论知识，讲述了docker的出现，docker与LXC以及Microservice的关系，同时从what, why上理解了docker，最后涉及了cgroup和namespaces两个Linux内核机制。</p>
<p>　　<a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">下一篇</a>将讲述Docker的基本操作。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="https://docs.docker.com/engine/faq/#what-does-docker-technology-add-to-just-plain-lxc" target="_blank" rel="external">what-does-docker-technology-add-to-just-plain-lxc</a></li>
<li><a href="https://waylau.com/ahout-docker/" target="_blank" rel="external">简述Docker</a></li>
<li><a href="https://www.qcloud.com/community/article/597293" target="_blank" rel="external">什么是Docker</a></li>
<li><a href="http://dockone.io/article/126" target="_blank" rel="external">八个Docker的真实应用场景</a></li>
<li><a href="https://www.toptal.com/linux/separation-anxiety-isolating-your-system-with-linux-namespaces" target="_blank" rel="external">Namespace isolation</a></li>
<li><a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="external">Docker背后的内核知识——cgroups资源限制</a></li>
<li><a href="http://blog.opskumu.com/docker.html#16-资源配额cgroups" target="_blank" rel="external">Docker资源配额</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;　　容器技术已经出现了相当一段时间了，例如LXC, BSD Jails, Solaris Zones… 那为什么出现了Docker，中间缺失了什么呢？&lt;br&gt;　　&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇&lt;/a&gt;讲述了容器相关的知识，练习了LXC容器的相关指令，本篇接着讲述Docker的出现以及Docker相关的理论基础。&lt;/p&gt;
&lt;h3 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h3&gt;&lt;p&gt;　　该系列《Docker in Prodcution》内容包含如下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;容器简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker简介&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker的基本操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker数据存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;多主机部署&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;日志、跟踪、监控&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;三、从Linux容器到Docker&quot;&gt;&lt;a href=&quot;#三、从Linux容器到Docker&quot; class=&quot;headerlink&quot; title=&quot;三、从Linux容器到Docker&quot;&gt;&lt;/a&gt;三、从Linux容器到Docker&lt;/h3&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Workshop（一）容器简介</title>
    <link href="http://yoursite.com/2017/07/09/Docker-workshop-1-%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/07/09/Docker-workshop-1-容器简介/</id>
    <published>2017-07-09T10:25:04.000Z</published>
    <updated>2017-12-27T07:12:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>　　“不想在自己电脑上装一堆东西，恩，弄个docker容器，随便安装，随便破坏，随便试验的玩吧！”，这是笔者了解docker的初衷。<br>　　后来回到武汉弄起了《Docker in Production》的workshop，正好项目也用到了docker，这才有股动力push我系统的了解一下docker。</p>
<h3 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h3><p>　　该系列《Docker in Prodcution》内容包含如下部分：</p>
<ul>
<li><strong>容器简介</strong></li>
<li><a href="http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">Docker简介</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">Docker的基本操作</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" target="_blank" rel="external">Docker数据存储</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/" target="_blank" rel="external">Docker网络</a></li>
<li><a href="http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/" target="_blank" rel="external">Docker安全</a></li>
<li>多主机部署</li>
<li>服务发现</li>
<li>日志、跟踪、监控</li>
</ul>
<p>　　本篇主要讲述容器相关的知识，比较容器和虚拟机，练习LXC容器的相关指令，最后引出Docker。</p>
<h3 id="三、容器的定义"><a href="#三、容器的定义" class="headerlink" title="三、容器的定义"></a>三、容器的定义</h3><a id="more"></a>
<p>　　容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。开发人员在自己笔记本上创建并测试好的容器，无需任何修改就能够在生产系统的虚拟机、物理服务器或公有云主机上运行。</p>
<img src="/imgs/container-structure.png" width="400" height="250">
<p>　　容器是轻量级的操作系统级虚拟化，可以让我们在一个资源隔离的进程中运行应用及其依赖项。运行应用程序所必需的组件都将打包成一个镜像并可以复用。执行镜像时，它运行在一个隔离环境中，并且不会共享宿主机的内存、CPU 以及磁盘，这就保证了容器内进程不能监控容器外的任何进程。</p>
<h3 id="四、容器解决的问题"><a href="#四、容器解决的问题" class="headerlink" title="四、容器解决的问题"></a>四、容器解决的问题</h3><p>　　为什么需要容器？容器到底解决的是什么问题？<br>　　一句话回答是：容器使软件具备了超强的可移植能力。</p>
<h4 id="1-从运输行业的集装箱说起"><a href="#1-从运输行业的集装箱说起" class="headerlink" title="1. 从运输行业的集装箱说起"></a>1. 从运输行业的集装箱说起</h4><p>　　20世纪60年代以前，运输行业几乎所有的货物都是以<em>散件</em>方式运输。</p>
<p>　　每一次运输，一方面货主与承运方会担心因货物类型的不同而导致损失，如几个铁桶压在了一堆香蕉上。另外一方面，运输过程中需要使用不同的交通工具严重浪费了大量的时间和精力，如货物先搬上车，到了码头由码头工人卸货，然后装上船，到岸之后卸下船，再装上火车，到达目的地，最后卸货……中间可能还有更多种类的交通工具，涉及到更多次的装、卸货、转移过程。</p>
<img src="/imgs/container-in-transportation1.png" width="400" height="250">
<p>　　幸运的是，集装箱的发现解决了这个难题。</p>
<img src="/imgs/container-in-transportation2.png" width="400" height="250">
<p>　　无论货物的体积、形状差异有多大，最终都被装载进集装箱里。由于要实现标准尺寸集装箱的运输，堆场、码头、起吊、船舶、汽车乃至公路桥梁、隧道等，都必须适应它在全球范围内的应用而逐渐加以标准化，形成影响国际贸易的全球物流系统。由此带来的是系统效率大幅度提升，运输费大幅度下降，地球上任何一个地方生产的产品都可以快速而低廉地运送到有需求的地方。</p>
<table>
<thead>
<tr>
<th>比较</th>
<th style="text-align:right">散货运输</th>
<th style="text-align:center">集装箱运输</th>
</tr>
</thead>
<tbody>
<tr>
<td>货物装卸时间</td>
<td style="text-align:right">几天到一个星期，分拣、合并、装卸过程繁琐</td>
<td style="text-align:center">几个小时</td>
</tr>
<tr>
<td>货物装卸时间占整个运输过程的比例</td>
<td style="text-align:right">&gt;50%</td>
<td style="text-align:center">&lt;10%</td>
</tr>
<tr>
<td>所需劳动力</td>
<td style="text-align:right">大量的码头工人</td>
<td style="text-align:center">少数的码头工人和起重机操作员</td>
</tr>
<tr>
<td>自动化程度</td>
<td style="text-align:right">低</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td>安全性</td>
<td style="text-align:right">低，装卸时常有物品损毁和盗窃</td>
<td style="text-align:center">高，货物被隔离在封闭的集装箱内</td>
</tr>
<tr>
<td>成本</td>
<td style="text-align:right">货物越多，成本越高，耗时越长</td>
<td style="text-align:center">前期固定成本投入较高，随着集装箱规模、运货量的增加，分摊到运送每个集装箱的成本极低，总成本几乎不变</td>
</tr>
</tbody>
</table>
<h4 id="2-应用程序中的容器"><a href="#2-应用程序中的容器" class="headerlink" title="2. 应用程序中的容器"></a>2. 应用程序中的容器</h4><p>　　同样，我们看看今天的软件开发面临的挑战。</p>
<p>　　以前几乎所有的应用都采用三层架构（Presentation/Appliation/Data），系统部署到有限的几台物理服务器上。如今，开发人员通常使用多种服务（如MQ、cache、DB）构建和组装应用，此外应用很可能部署到不同的环境（如虚拟服务器、私有云和公有云）。一方面应用包含多种服务，这些服务有自己所依赖的库和软件包；另一方面存在多种部署环境，服务在运行时可能需要动态迁移到不同的环境中。如何让每种服务能够在所有的部署环境中顺利运行？<br>　　“服务”和“应用环境”对应到前面运输行业的“货物类型”和“运输工具”，容器则对应“集装箱”。<br><img src="/imgs/container-in-application.png" width="400" height="250"></p>
<h3 id="五、为什么容器技术如此诱人？"><a href="#五、为什么容器技术如此诱人？" class="headerlink" title="五、为什么容器技术如此诱人？"></a>五、为什么容器技术如此诱人？</h3><h4 id="1-封装、隔离"><a href="#1-封装、隔离" class="headerlink" title="1. 封装、隔离"></a>1. 封装、隔离</h4><p>　　各个容器之间，资源独立、隔离，不同的应用以container为单位进行部署，环境互不影响。</p>
<h4 id="2-轻量、可移植"><a href="#2-轻量、可移植" class="headerlink" title="2. 轻量、可移植"></a>2. 轻量、可移植</h4><p>　　相比于传统的虚拟化技术，容器在cpu、memory、network IO上的性能损耗都有同样水平甚至更优，容器的创建、启动、销毁都很快。</p>
<h4 id="3-标准化、run-on-any-hardware"><a href="#3-标准化、run-on-any-hardware" class="headerlink" title="3. 标准化、run on any hardware"></a>3. 标准化、run on any hardware</h4><p>　　开发人员只需为按照一定的标准为应用创建一次运行环境，然后打包成容器便可在其他机器上运行。</p>
<h4 id="4-一致性、可重复性"><a href="#4-一致性、可重复性" class="headerlink" title="4. 一致性、可重复性"></a>4. 一致性、可重复性</h4><p>　　标准化的容器消除了开发、测试、生产环境的不一致性。</p>
<h3 id="六、容器与虚拟机"><a href="#六、容器与虚拟机" class="headerlink" title="六、容器与虚拟机"></a>六、容器与虚拟机</h3><p>　　谈到容器，就不得不将它与虚拟机进行对比，因为两者都是为应用提供封装和隔离。<br>　　一句话解释区别：容器能做的事少得多并且使用起来相当廉价。而虚拟机提供整个虚拟化硬件层，可以做更多的事情但是使用成本显著。</p>
<img src="/imgs/container-vs-vms.png" width="400" height="250">
<p>主要区别如下：</p>
<ol>
<li>容器实例与主机共享操作系统内核，通过内核提供的运行时隔离能力为服务提供独立的用户域、文件系统、网络以及进程运行空间。<br>虚拟机的每个实例自带操作系统，因而是一种硬件级的虚拟化隔离。</li>
<li>容器通常是专用于运行特定服务的，它的镜像通常只包含运行该服务所需的上下文内容，许多广泛使用的镜像都只有几十MB，甚至几MB大小。<br>虚拟机则需要提供包括内核在内的通用进程运行环境，它的镜像偏向于大而完整的全功能集合，即使一个最小的精简镜像的体积也有几百MB。</li>
<li>容器的使用方式倾向于开箱即用，镜像提供的是一个『不可变的基础设施环境』。<br>虚拟机则倾向于让用户根据所用的系统，自定义初始化操作，使用Ansible、Puppet这样的配置工具来进行基础设施的管理</li>
<li>容器在启动速度和运行性能上更有优势，虚拟机在安全性上更有优势。</li>
</ol>
<h3 id="七、容器的分类"><a href="#七、容器的分类" class="headerlink" title="七、容器的分类"></a>七、容器的分类</h3><h4 id="1-操作系统容器"><a href="#1-操作系统容器" class="headerlink" title="1. 操作系统容器"></a>1. 操作系统容器</h4><p>　　操作系统层虚拟化是一种计算机虚拟化技术，这种技术将操作系统内核虚拟化，可以允许多个独立用户空间的存在，而不是只有一个。这些实例有时会被称为容器、虚拟引擎、虚拟专用服务器或是 jails（FreeBSD jail 或者 chroot jail）。从运行在容器中的程序角度来看，这些实例就如同真正的计算机。</p>
<p>　　容器技术如 LXC，OpenVZ，Linux VServer，BSD Jails 和 Solaris 区域就是操作系统容器。</p>
<h4 id="2-应用容器"><a href="#2-应用容器" class="headerlink" title="2. 应用容器"></a>2. 应用容器</h4><p>　　应用程序虚拟化是从其所执行的底层操作系统封装计算机程序的软件技术。一个完全虚拟化的应用，尽管仍像原来一样执行，但是并不会进行传统意义上的安装。应用在运行时的行为就像它直接与原始操作系统以及操作系统所管理的所有资源进行交互一样，但可以实现不同程度的隔离或者沙盒化。</p>
<p>　　容器技术如 Docker 和 Rocket 就是应用程序容器的示例。</p>
<h3 id="八、LXC的练习"><a href="#八、LXC的练习" class="headerlink" title="八、LXC的练习"></a>八、LXC的练习</h3><p>　　LXC是Linux containers的简称，是一种基于容器的操作系统层级的虚拟化技术。</p>
<p>　　LXC 与虚拟机的不同之处在于，它是一个操作系统级别的虚拟化环境，而不是硬件虚拟化环境。他们都做同样的事情，但 LXC 是操作系统级别的虚拟化环境，虚拟环境有它自己的进程和网络空间，而不是创建一个完整成熟的虚拟机。因此，一个 LXC 虚拟操作系统具有最小的资源需求，并启动只需几秒钟。</p>
<h4 id="【练习1】创建LXC容器"><a href="#【练习1】创建LXC容器" class="headerlink" title="【练习1】创建LXC容器"></a>【练习1】创建LXC容器</h4><ol>
<li>Ubuntu系统上安装好lxc</li>
<li><p>宿主机上操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 列出所有的容器:</span></div><div class="line">sudo lxc-ls --fancy</div><div class="line"><span class="meta">#</span><span class="bash"> 启动一个后台运行的容器demo-container:</span></div><div class="line">sudo lxc-start --name demo-container --daemon</div><div class="line"><span class="meta">#</span><span class="bash"> 查看运行的容器的相关信息:</span></div><div class="line">sudo lxc-info --name demo-container</div><div class="line"><span class="meta">#</span><span class="bash"> 进入到容器:</span></div><div class="line">sudo lxc-console -n demo-container</div><div class="line"><span class="meta">#</span><span class="bash"> 登陆时候输入:</span></div><div class="line">Username: ubuntu</div><div class="line">Password: ubuntu</div></pre></td></tr></table></figure>
</li>
<li><p>LXC容器中操作</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># 查看容器的hostname</span></div><div class="line">hostname</div><div class="line"><span class="meta"># 在容器中创建一个文件</span></div><div class="line">echo <span class="string">"hello"</span> &gt; my_text.txt</div><div class="line">cat my_text.txt</div></pre></td></tr></table></figure>
</li>
<li><p>退出容器<br>先按下<code>ctrl+a</code>，然后再按<code>q</code>。</p>
</li>
</ol>
<h4 id="【练习2】克隆LXC容器"><a href="#【练习2】克隆LXC容器" class="headerlink" title="【练习2】克隆LXC容器"></a>【练习2】克隆LXC容器</h4><ol>
<li><p>宿主机上操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 冻结运行的容器</span></div><div class="line">sudo lxc-freeze -n demo-container</div><div class="line"><span class="meta">#</span><span class="bash"> 列出所有的容器:</span></div><div class="line">sudo lxc-ls --fancy</div><div class="line"><span class="meta">#</span><span class="bash"> 克隆容器之前，必须要先停止容器</span></div><div class="line">sudo lxc-stop --name demo-container</div><div class="line">sudo lxc-clone -o demo-container -n cloned-container</div><div class="line"><span class="meta">#</span><span class="bash"> 列出所有的容器:</span></div><div class="line">sudo lxc-ls --fancy</div><div class="line"><span class="meta">#</span><span class="bash"> 启动复制的容器</span></div><div class="line">sudo lxc-start --name cloned-container --daemon</div><div class="line"><span class="meta">#</span><span class="bash"> 进入到复制的容器:</span></div><div class="line">sudo lxc-console -n cloned-container</div><div class="line"><span class="meta">#</span><span class="bash"> 登陆时候输入:</span></div><div class="line">Username: ubuntu</div><div class="line">Password: ubuntu</div></pre></td></tr></table></figure>
</li>
<li><p>克隆的容器中操作</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看克隆的容器是否也一起克隆了之前创建的文件</span></div><div class="line"><span class="keyword">ls</span></div></pre></td></tr></table></figure>
</li>
<li><p>退出容器<br>先按下<code>ctrl+a</code>，然后再按<code>q</code>。</p>
</li>
<li><p>停止克隆的容器</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo lxc-<span class="keyword">stop</span> --<span class="keyword">name</span> cloned-container</div></pre></td></tr></table></figure>
</li>
<li><p>销毁克隆的容器</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo lxc-destroy <span class="comment">--name cloned-container</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>　　本篇文章主要是涉及容器，从what, why, how上讲述了容器的相关知识。<br>至于容器的历史，有兴趣的读者可以自己查看一下相关资料。<br><a href="http://www.dockone.io/article/1522" target="_blank" rel="external">容器简史：从20世纪70年代的chroot到2016的Docker</a>以及<a href="http://www.alauda.cn/2016/01/18/container-history/" target="_blank" rel="external">【容器那些事儿】容器技术的前世今生</a><br>　　下一篇将讲述Docker的出现以及相关的基本理论知识。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="http://dockone.io/article/803" target="_blank" rel="external">为什么容器技术将主宰世界？</a></li>
<li><a href="http://dockone.io/article/2442" target="_blank" rel="external">容器技术概览</a></li>
<li><a href="https://www.ibm.com/developerworks/community/blogs/132cfa78-44b0-4376-85d0-d3096cd30d3f/entry/%E5%AE%B9%E5%99%A8_What_Why_How_%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF_6?lang=zh" target="_blank" rel="external">容器What, Why, How - 每天5分钟玩转容器技术 - IBM</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-lxc-containers/" target="_blank" rel="external">LXC：Linux 容器工具</a></li>
<li><a href="http://17173ops.com/2013/11/14/linux-lxc-install-guide.shtml#toc2" target="_blank" rel="external">LXC基础学习教程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;　　“不想在自己电脑上装一堆东西，恩，弄个docker容器，随便安装，随便破坏，随便试验的玩吧！”，这是笔者了解docker的初衷。&lt;br&gt;　　后来回到武汉弄起了《Docker in Production》的workshop，正好项目也用到了docker，这才有股动力push我系统的了解一下docker。&lt;/p&gt;
&lt;h3 id=&quot;二、背景&quot;&gt;&lt;a href=&quot;#二、背景&quot; class=&quot;headerlink&quot; title=&quot;二、背景&quot;&gt;&lt;/a&gt;二、背景&lt;/h3&gt;&lt;p&gt;　　该系列《Docker in Prodcution》内容包含如下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器简介&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/10/Docker-workshop-2-Docker%E7%AE%80%E4%BB%8B/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/11/Docker-workshop-3-Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker的基本操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/13/Docker-workshop-4-Docker%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker数据存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/17/Docker-workshop-5-Docker%E7%BD%91%E7%BB%9C/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2017/07/20/Docker-workshop-6-Docker%E5%AE%89%E5%85%A8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;多主机部署&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;日志、跟踪、监控&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　本篇主要讲述容器相关的知识，比较容器和虚拟机，练习LXC容器的相关指令，最后引出Docker。&lt;/p&gt;
&lt;h3 id=&quot;三、容器的定义&quot;&gt;&lt;a href=&quot;#三、容器的定义&quot; class=&quot;headerlink&quot; title=&quot;三、容器的定义&quot;&gt;&lt;/a&gt;三、容器的定义&lt;/h3&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>基于RabbitMQ topic的消息发送与接收</title>
    <link href="http://yoursite.com/2017/01/14/%E5%9F%BA%E4%BA%8ERabbitMQ%20topic%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6/"/>
    <id>http://yoursite.com/2017/01/14/基于RabbitMQ topic的消息发送与接收/</id>
    <published>2017-01-14T08:19:46.000Z</published>
    <updated>2017-01-14T07:57:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><h4 id="1-项目结构："><a href="#1-项目结构：" class="headerlink" title="1.项目结构："></a>1.项目结构：</h4><img src="/imgs/rabbit-1.png" width="400" height="250">
<p>A是消息的生产者，B、C则是消息的consumer。A会通过queue（不关心其产品类型）发送消息给B、C。</p>
<h4 id="2-需求"><a href="#2-需求" class="headerlink" title="2.需求"></a>2.需求</h4><p>近期项目上，新增的D应用程序需要监听原有A应用程序的消息。按照以往的做法，我需要做如下两件事：</p>
<ul>
<li>向某个团队，给每该D应用的每个region（dev、intg、sys、prod等），申请新的queue A.D。（这中间可能需要两个星期时间）</li>
<li>改变应用A的代码，让其每次发消息时候还需要再给D发消息。</li>
<li>给应用A准备一次deploymen plan，并做相应的回归测试。</li>
<li>改变应用D的代码，让其从新建的queue里面接收处理消息。</li>
</ul>
<h4 id="3-痛点"><a href="#3-痛点" class="headerlink" title="3.痛点"></a>3.痛点</h4><p>这一做法，主要有两大痛点：</p>
<ul>
<li>每增加一个新应用，都需要申请queue</li>
<li>每增加一个新应用，都需要改动应用A的代码，还需要单独安排一次上线。生产者和消费者之间的耦合非常大。</li>
</ul>
<h4 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h4><p>因此，在兼容以前的基础上，我试图用下面的结构图解决上述痛点：<br><img src="/imgs/rabbit-2.png" width="400" height="250"><br>保持原有应用程序B和C的接收消息方式不变，新的应用程序开始改用topic的方法，这样可以兼容既有的应用程序，也可以将新应用程序的生产者和消费者解耦。但是还是存在一些问题：</p>
<ul>
<li>A的消息那么多，全部放在一个topic可能负载过大，那么应该采取分布式的方法？</li>
<li>如果消费者之一中途down了一段时间，该消息的等待时间又如何处理？是一直停留在topic中进行等待吗？</li>
</ul>
<p>最后，考虑到上述因素以及实际项目的其他因素，我将结构变成了如下：<br><img src="/imgs/rabbit-3.png" width="400" height="250"><br>虽然把最开始的痛点1又引入了，但是解耦的好处还是非常有意义的。</p>
<p>本文旨在spike上述想法，证明该想法的可能性。</p>
<h3 id="二、搭建外部环境"><a href="#二、搭建外部环境" class="headerlink" title="二、搭建外部环境"></a>二、搭建外部环境</h3><p>笔者采用vagrant + VirtualBox搭建一个含有rabbitmq server的虚拟机：<br>总体说来，所有的命令如下：</p>
<h4 id="1-创建虚拟机"><a href="#1-创建虚拟机" class="headerlink" title="1.创建虚拟机"></a>1.创建虚拟机</h4><pre><code>$ mkdir rabbit
$ cd rabbit
$ vagrant box list
$ vagrant init yungsang/coreos
</code></pre><p>然后注意取消注释<code>config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot;</code></p>
<h4 id="2-登陆到虚拟机"><a href="#2-登陆到虚拟机" class="headerlink" title="2.登陆到虚拟机"></a>2.登陆到虚拟机</h4><pre><code>vagrant ssh
</code></pre><h4 id="3-外部访问rabbitmq的管理页面"><a href="#3-外部访问rabbitmq的管理页面" class="headerlink" title="3.外部访问rabbitmq的管理页面"></a>3.外部访问rabbitmq的管理页面</h4><p>URL：<code>http://192.168.33.10:15672/#/</code><br>用户名：<code>guest</code><br>密码：<code>guest</code></p>
<h3 id="三、Spike"><a href="#三、Spike" class="headerlink" title="三、Spike"></a>三、Spike</h3><p>在编写本文时候，笔者顺便了解了一下Rabbit MQ的相关基础模式与用法，可以参见上一篇文章<a href="http://zhangyuyu.github.io/2017/01/14/RabbitMQ%E5%88%9D%E6%8E%A2/" target="_blank" rel="external">RabbitMQ初探</a></p>
<p>再回过头来看这个spike，发现其实本文要实现的就是<a href="http://zhangyuyu.github.io/2017/01/14/RabbitMQ%E5%88%9D%E6%8E%A2/" target="_blank" rel="external">RabbitMQ初探</a>中的Topic Exchange模式。</p>
<p>其实说起来，就是JMS和AMQP的一个较大的区别：</p>
<ul>
<li>JMS有队列(Queues)和主题(Topics)两种形式，发送到JMS队列的消息最多只能被一个Client消费，发送到JMS主题的消息可能会被多个Clients消费；</li>
<li>AMQP只有队列(Queues)，队列的消息只能被单个接受者消费，发送者并不直接把消息发送到队列中，而是发送到Exchange中，该Exchage会与一个或多个队列绑定，能够实现与JMS队列和主题同样的功能。</li>
</ul>
<h3 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h3><p>本文只是针对其中的一点，进行了可行性的spike，但是实际应用中往往还涉及到很多复杂因素，比如技术上消息的事务处理和消息负载，另外还有项目进度、人员安排以及后续维护等问题。笔者不再过多阐述，谨以此文的小demo探究一些不一样的架构。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;h4 id=&quot;1-项目结构：&quot;&gt;&lt;a href=&quot;#1-项目结构：&quot; class=&quot;headerlink&quot; title=&quot;1.项
    
    </summary>
    
      <category term="Message" scheme="http://yoursite.com/categories/Message/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ初探</title>
    <link href="http://yoursite.com/2017/01/14/RabbitMQ%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2017/01/14/RabbitMQ初探/</id>
    <published>2017-01-14T02:19:46.000Z</published>
    <updated>2017-01-14T07:20:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>在准备<code>基于RabbitMQ topic的消息发送与接收</code>的时候，顺便开始了这篇RabbitMQ初探。<br>安装过程这里就不再赘述，本博客主要记录一些初探过程。</p>
<h3 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h3><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。<br>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。<br>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<h3 id="三、几种模式"><a href="#三、几种模式" class="headerlink" title="三、几种模式"></a>三、几种模式</h3><p>Rabbit MQ<a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="external">官网教程</a>上，从六个方面给出了讲解和demo。但是这些demo都是从最基础的层面进行编写，所以我自己尝试时候用了spring boot的相关支持，简化了很多代码。同时在尝试之后，我大概将其分为三类：</p>
<ul>
<li>Hello World(Queue)</li>
<li>Publish/Subscribe(Exchange)</li>
<li>RPC</li>
</ul>
<p>下面分别回顾一下上述三类情况：</p>
<h4 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1.Hello World"></a>1.Hello World</h4><p>我把官网上的<a href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html" target="_blank" rel="external">Hello World</a>和<a href="https://www.rabbitmq.com/tutorials/tutorial-two-java.html" target="_blank" rel="external">Work Queues</a>归到这一类。结构如下：</p>
<img src="/imgs/rabbitmq-hello-world.png" width="400" height="250">
<p align="center">Hello World</p>

<img src="/imgs/rabbitmq-work-queues.png" width="400" height="250">
<p align="center">Work Queues</p>

<p>它们都属于直接把消息发送给一个queue，然后consumers会与queue相连接。<br>相关代码可参考：<a href="https://github.com/zhangyuyu/learnrabbitmq/commits/master" target="_blank" rel="external">https://github.com/zhangyuyu/learnrabbitmq/commits/master</a> 的第一次、第二次提交。</p>
<h4 id="2-Publish-Subscribe-Exchange"><a href="#2-Publish-Subscribe-Exchange" class="headerlink" title="2.Publish/Subscribe(Exchange)"></a>2.Publish/Subscribe(Exchange)</h4><p>这种模式使用了Exchange，可以把它理解为消息交换机，它指定消息按什么规则，路由到哪个队列。<br>因此我把官网上的<a href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html" target="_blank" rel="external">Publish/Subscribe</a>、<a href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html" target="_blank" rel="external">Routing</a>、<a href="https://www.rabbitmq.com/tutorials/tutorial-five-java.html" target="_blank" rel="external">Topics</a>放到这一类中。</p>
<img src="/imgs/rabbitmq-exchanges.png" width="400" height="250">
<p>根据Exchange的类型，可以分为四类：</p>
<ul>
<li>Fanout</li>
<li>Direct</li>
<li>Topic</li>
<li>Headers</li>
</ul>
<h5 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h5><p>该类型路由规则非常简单，会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，相当于广播功能<br>相关代码可参考：<a href="https://github.com/zhangyuyu/learnrabbitmq/commits/master" target="_blank" rel="external">https://github.com/zhangyuyu/learnrabbitmq/commits/master</a> 的Rabbitmq Fanout Exchange。</p>
<h5 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h5><p>该类型路由规则，会把消息路由到那些binding key与routing key完全匹配的Queue中。<br>相关代码可参考：<a href="https://github.com/zhangyuyu/learnrabbitmq/commits/master" target="_blank" rel="external">https://github.com/zhangyuyu/learnrabbitmq/commits/master</a> 的Rabbitmq Direct Exchange。</p>
<h5 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h5><p>该类型路由规则与上述Direct Exchange规则类似，只是在binding key与routing key的匹配规则上进行了扩展，它约定：</p>
<ul>
<li>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“routing.key.for.fist.queue”</li>
<li>binding key与routing key一样也是句点号“. ”分隔的字符串</li>
<li>binding key中可以存在两种特殊字符“*”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）。</li>
</ul>
<p>相关代码可参考：<a href="https://github.com/zhangyuyu/learnrabbitmq/commits/master" target="_blank" rel="external">https://github.com/zhangyuyu/learnrabbitmq/commits/master</a> 的Rabbitmq Topic Exchange。</p>
<h5 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h5><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。<br>相关代码可参考：<a href="https://github.com/zhangyuyu/learnrabbitmq/commits/master" target="_blank" rel="external">https://github.com/zhangyuyu/learnrabbitmq/commits/master</a> 的Rabbitmq Headers Exchange。</p>
<h4 id="3-RPC"><a href="#3-RPC" class="headerlink" title="3.RPC"></a>3.RPC</h4><p>MQ本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到RabbitMQ后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。<br>但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用），可直接参考<a href="https://www.rabbitmq.com/tutorials/tutorial-six-java.html" target="_blank" rel="external">官方教程</a>。</p>
<p>RabbitMQ中实现RPC的机制是：</p>
<ul>
<li>客户端发送请求（消息）时，在消息的属性（MessageProperties，在AMQP协议中定义了14中properties，这些属性会随着消息一起发送）中设置两个值replyTo（一个Queue名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue中）和correlationId（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败）</li>
<li>服务器端收到消息并处理</li>
<li>服务器端处理完消息之后，将生成一条应答消息到replyTo指定的Queue，同时带上correlationId属性。</li>
<li>客户端之前已订阅replyTo指定的Queue，从中收到服务器的应答消息后，根据其中的correlationId属性分析哪条请求被执行了，根据执行结果进行后续业务处理</li>
</ul>
<h3 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h3><h4 id="Dashboard："><a href="#Dashboard：" class="headerlink" title="Dashboard："></a>Dashboard：</h4><img src="/imgs/rabbitmq-terms.png" width="600" height="250">
<p>其中：</p>
<ul>
<li>Connection： 就是一个TCP的连接。Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。</li>
<li>Channels： 虚拟连接。它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</li>
</ul>
<h4 id="术语："><a href="#术语：" class="headerlink" title="术语："></a>术语：</h4><ul>
<li>Broker：简单来说就是消息队列服务器实体。</li>
<li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</li>
<li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li>
<li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li>
<li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。</li>
<li>vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li>
<li>producer：消息生产者，就是投递消息的程序。</li>
<li>consumer：消息消费者，就是接受消息的程序。</li>
<li>channel：消息通道，在客户端的每个连接里，可以建立多个channel，每个channel代表一个会话任务。</li>
</ul>
<h4 id="消息队列的使用过程大概如下："><a href="#消息队列的使用过程大概如下：" class="headerlink" title="消息队列的使用过程大概如下："></a>消息队列的使用过程大概如下：</h4><ul>
<li>客户端连接到消息队列服务器，打开一个channel。</li>
<li>客户端声明一个exchange，并设置相关属性。</li>
<li>客户端声明一个queue，并设置相关属性。</li>
<li>客户端使用routing key，在exchange和queue之间建立好绑定关系。</li>
<li>客户端投递消息到exchange。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;在准备&lt;code&gt;基于RabbitMQ topic的消息发送与接收&lt;/code&gt;的时候，顺便开始了这篇RabbitMQ初探。
    
    </summary>
    
      <category term="Message" scheme="http://yoursite.com/categories/Message/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程初探（二）</title>
    <link href="http://yoursite.com/2016/11/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A22/"/>
    <id>http://yoursite.com/2016/11/12/函数式编程初探2/</id>
    <published>2016-11-12T11:35:10.000Z</published>
    <updated>2016-11-13T13:13:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://zhangyuyu.github.io/2016/11/12/函数式编程初探1" target="_blank" rel="external">上一篇</a>文章中介绍函数式编程的概念以及三个具有普遍意义的基本构造单元，本篇文章会接着讲述一些柯里化与部分施用、缓存、缓求值、函数式的数据结构。</p>
<h3 id="一、柯里化与部分施用"><a href="#一、柯里化与部分施用" class="headerlink" title="一、柯里化与部分施用"></a>一、柯里化与部分施用</h3><p>柯里化（currying）和函数的部分施用（partial application）都是从数学里借用过来的编程语言技法（基于20世纪haskell Curry等数学家的研究成果）。它们两者都有能力操纵函数的参数条目，一般是通过向一部分参数带入一个或多个默认值的办法来实现的。</p>
<p>柯里化指的是从一个多参数函数变成一连串单参数函数的变化。调用者可以决定对多少个参数实施变换，余下的部分将衍生为一个参数数目较少的新函数。如函数process(x,y,z)完全柯里化之后变成process(x)(y)(z)。<br>部分施用是指提前带入一部分参数值，使一个多参数函数得以省略部分参数，从而转化为一个参数数目较少的函数。如在函数process(x,y,z)上部分施用一个参数，那么我们将得到process(y,z)。</p>
<p>Groovy语言中部分施用与柯里化的对比：<br><figure class="highlight flix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">volume</span> </span>= &#123;h, w, l -&gt; h * w * l&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span> </span>= volume.curry(<span class="number">1</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthPA</span> </span>= volume.curry(<span class="number">1</span>, <span class="number">1</span>)         <span class="comment">// &lt;1&gt;</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthC</span> </span>= volume.curry(<span class="number">1</span>).curry(<span class="number">1</span>)    <span class="comment">// &lt;2&gt;</span></div><div class="line"></div><div class="line">println <span class="string">"The volume of the 2x3x4 rectangular solid is $&#123;volume(2, 3, 4)&#125;"</span></div><div class="line">println <span class="string">"The area of the 3x4 rectangle is $&#123;area(3, 4)&#125;"</span></div><div class="line">println <span class="string">"The length of the 6 line is $&#123;lengthPA(6)&#125;"</span></div></pre></td></tr></table></figure></p>
<p>代码可参见《函数式编程思想》的<a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/groovy/currying.groovy" target="_blank" rel="external">github</a><br>柯里化常见的应用场景：函数工厂、模板方法模式、隐藏参数。</p>
<h3 id="二、缓存"><a href="#二、缓存" class="headerlink" title="二、缓存"></a>二、缓存</h3><p>缓存是很常见的一种需求（同时也是制造隐晦错误的源头）。缓存有两种实现方式：一种是手工进行状态管理，另一种是采用记忆机制。</p>
<h4 id="手工进行状态管理"><a href="#手工进行状态管理" class="headerlink" title="手工进行状态管理"></a>手工进行状态管理</h4><p>在代码里面增加一个filed，每次计算之前之前先去检查是否存在于缓存中。但是当我们将缓存的取值范围增大时，可能报出OutOfMemoryError的错误。</p>
<p>缓存可以提高性能，但是缓存有代价：它提高了代码的非本质复杂性和维护负担。同时，编写缓存的代码还要兼顾执行的环境（比如缓存范围）。<br>代码示例参考下文<a href="#完美数的手工缓存实现">完美数的手工缓存实现</a></p>
<h4 id="记忆机制"><a href="#记忆机制" class="headerlink" title="记忆机制"></a>记忆机制</h4><p>Groovy语言记忆函数的办法是，先将要记忆的函数定义成闭包，然后对该闭包执行memoize()方法来获得一个新函数，以后我们调用这个新函数的时候，其结果就会被缓存起来。<br>请保证所有被记忆的函数：</p>
<ul>
<li>没有副作用</li>
<li>不依赖任何外部信息<br>代码示例参考下文<a href="#完美数的记忆实现">完美数的记忆实现</a></li>
</ul>
<h3 id="三、缓求值"><a href="#三、缓求值" class="headerlink" title="三、缓求值"></a>三、缓求值</h3><p>缓求值指尽可能地推迟求解表达式。缓求值的集合不会预先算好所有的元素，而是在用到的时才落实下来。这样做有几个好处：</p>
<ul>
<li>昂贵的运算只有到了绝对必要的时候才执行</li>
<li>我们可以建立无限大的集合，只要一直接到请求，就一直送出元素</li>
<li>按缓求值的方式来使用映射、筛选等函数式概念，可以产生更高效的代码。</li>
</ul>
<p>例如：<code>print length([2+1, 3*2, 1/0, 5-4])</code><br>对于严格求值的编程语言，执行（甚至编译）时，会发生<code>被零除</code>的异常；<br>对于非严格（也叫缓求值）的里，则会得出<code>4</code>的结果。</p>
<p>缓求值在Groovy中的应用：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def prepend(val, closure) &#123; new LazyList(val, closure) &#125;</div><div class="line">def integers(n) &#123; prepend(n, &#123; integers(n + <span class="number">1</span>) &#125;) &#125;</div><div class="line"></div><div class="line">@Test</div><div class="line">public void lazy_list_acts_like_a_list() &#123;</div><div class="line">    def naturalNumbers = integers(<span class="number">1</span>)</div><div class="line">    assertEquals('<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>', naturalNumbers.getHead(<span class="number">10</span>).join(' '))</div><div class="line">    def evenNumbers = naturalNumbers.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</div><div class="line">    assertEquals('<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span> <span class="number">20</span>', evenNumbers.getHead(<span class="number">10</span>).join(' '))</div></pre></td></tr></table></figure></p>
<h3 id="四、函数式的数据结构"><a href="#四、函数式的数据结构" class="headerlink" title="四、函数式的数据结构"></a>四、函数式的数据结构</h3><p>函数式语言里经常遇到返回两种截然不同的值的需求，它们用来建模这种行为的常用数据结构是Either。<br>使用Either表示两种结果的返回值，使用Option来表示有为空返回值的类型。Option类可近似看作为Either的子类。</p>
<p>用Java的泛型来自己实现Either类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Either</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> A left = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> B right = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Either</span><span class="params">(A a,B b)</span> </span>&#123;</div><div class="line">        left = a;</div><div class="line">        right = b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A,B&gt; <span class="function">Either&lt;A,B&gt; <span class="title">left</span><span class="params">(A a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;A,B&gt;(a,<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">left</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeft</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> right != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">right</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A,B&gt; <span class="function">Either&lt;A,B&gt; <span class="title">right</span><span class="params">(B b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;A,B&gt;(<span class="keyword">null</span>,b);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fold</span><span class="params">(F&lt;A&gt; leftOption, F&lt;B&gt; rightOption)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)</div><div class="line">            leftOption.f(left);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            rightOption.f(right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码可参见《函数式编程思想》的<a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/errorhandling/Either.java" target="_blank" rel="external">github</a><br>使用：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Either&lt;Exception, Integer&gt; parseNumberDefaults(final <span class="keyword">String</span> s) &#123;</div><div class="line">    <span class="keyword">if</span> (不满足)</div><div class="line">        <span class="keyword">return</span> Either.left(<span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">"Invalid Number"</span>));</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        int number = <span class="keyword">new</span> <span class="type">RomanNumeral</span>(s).toInt();</div><div class="line">        <span class="keyword">return</span> Either.right(<span class="keyword">new</span> <span class="type">RomanNumeral</span>(number &gt;= MAX ? MAX : <span class="type">number</span>).toInt());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="五、完美数的示例"><a href="#五、完美数的示例" class="headerlink" title="五、完美数的示例"></a>五、完美数的示例</h3><p>案例：</p>
<blockquote>
<p>自然数分类规则：<br>完美数： 真约数之和 = 数本身<br>过剩数： 真约数之和 &gt; 数本身<br>不足数： 真约数之和 &lt; 数本身<br>真约数和：除了数本身之外，其余正约数的和。</p>
</blockquote>
<p>代码比较长，可以直接查看《函数式编程思想》的<a href="https://github.com/oreillymedia/functional_thinking/" target="_blank" rel="external">github</a>总结如下：<br>1.完美数的命令式解法<br><a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier/ImpNumberClassifierSimple.java" target="_blank" rel="external">https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier/ImpNumberClassifierSimple.java</a><br>2.稍向函数式靠拢的完美数分类实现<br><a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier/NumberClassifier.java" target="_blank" rel="external">https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier/NumberClassifier.java</a><br>3.完美数分类的Java8实现<br><a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier8/NumberClassifier.java" target="_blank" rel="external">https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/number_classifier8/NumberClassifier.java</a><br><span id="完美数的手工缓存实现">4.完美数的手工缓存实现</span><br><a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/groovy/memoization/ClassifierCached.groovy" target="_blank" rel="external">https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/groovy/memoization/ClassifierCached.groovy</a><br><span id="完美数的记忆实现">5.完美数的记忆实现</span><br><a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/groovy/memoization/ClassifierMemoized.groovy" target="_blank" rel="external">https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/groovy/memoization/ClassifierMemoized.groovy</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://zhangyuyu.github.io/2016/11/12/函数式编程初探1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇&lt;/a&gt;文章中介绍函数式编程的概念以及三个具有普遍意义的基本构造单元，本篇文章会接着讲述一些
    
    </summary>
    
      <category term="函数式编程" scheme="http://yoursite.com/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="函数式编程" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程初探（一）</title>
    <link href="http://yoursite.com/2016/11/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A21/"/>
    <id>http://yoursite.com/2016/11/12/函数式编程初探1/</id>
    <published>2016-11-12T09:35:13.000Z</published>
    <updated>2016-11-12T13:42:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>作为一名从业以来一直在编写Java的程序媛，虽然项目里经常用java8的lambda，可是在引入<a href="http://zhangyuyu.github.io/2016/11/01/RxJava/" target="_blank" rel="external">RxJava</a>之后，函数作为参数传递更加普遍，故阅读《函数式编程思维》一书，以求了解函数式编程。</p>
<h3 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h3><p><code>函数式编程</code>(Functional Programming)是一种<code>编程范式</code>（programming paradigm），也就是如何编写程序的方法论。<br>主要思想是把运算过程尽量写成一系列嵌套的函数调用。</p>
<h3 id="三、背景"><a href="#三、背景" class="headerlink" title="三、背景"></a>三、背景</h3><p>函数式编程（Functional Programming）其实相对于计算机的历史而言是一个非常古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于 λ 演算，而 λ 演算并非设计于在计算机上执行，它是由 Alonzo Church 和 Stephen Cole Kleene 在 20 世纪三十年代引入的一套用于研究函数定义、函数应用和递归的形式系统。</p>
<h3 id="四、为什么？"><a href="#四、为什么？" class="headerlink" title="四、为什么？"></a>四、为什么？</h3><p>在《函数式编程思维》这本书中，多处指出<code>函数式编程思维</code>的好处之一,是能够将低层次细节的控制权移交给运行时,从而消弭了一大批注定会发生的程序错误。这使得程序员得以在更高的抽象层次上工作，同时运行时也有了执行复杂优化的自由空间。</p>
<p>在阮一峰的<a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="external">《函数式编程初探》</a>一文中，<br>函数式编程的五大特点如下：</p>
<ol>
<li>函数是”第一等公民”</li>
<li>只用”表达式”，不用”语句”</li>
<li>没有”副作用”</li>
<li>不修改状态</li>
<li>引用透明<br>函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</li>
</ol>
<p>函数式编程的好处如下：</p>
<ol>
<li>代码简洁，开发快速</li>
<li>接近自然语言，易于理解</li>
<li>更方便的代码管理(每一个函数都可以被看做独立单元，很有利于进行单元测试以及模块化组合)</li>
<li>易于”并发编程”</li>
<li>代码的热升级（函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的）</li>
</ol>
<h3 id="五、转变思维"><a href="#五、转变思维" class="headerlink" title="五、转变思维"></a>五、转变思维</h3><p>先大致说明一下函数式编程与命令式编程的区别吧！</p>
<p>命令式编程：按照“程序是一系列改变状态的命令”来建模的一种编程风格。<br>函数式编程将程序描述为表达式和变换，以数学方程的形式建立模型，并且尽量避免可变的状态。</p>
<p>《Working with Lagacy Code》的作者Michael Feathers的用以下一句话说明了函数式抽象和面向对象抽象的关键区别：</p>
<blockquote>
<p>面向对象编程通过封装不确定因素来使代码能被人理解；函数式编程通过尽量减少不确定因素来使代码能被人理解。——Michael Feathers</p>
</blockquote>
<p>在面向对象的命令式编程语言里面，重用的单元是类和类之间沟通用的消息。所以OOP的世界提倡开发人员针对具体问题<strong>建立专门的数据结构</strong>，相关的专门操作以“方法”的形式附加在数据结构上。<br>函数式编程语言重用的思路很不一样，它提倡在<strong>有限的几种关键数据结构</strong>（如list、set、map）上运用针对这些数据结构高度优化过的操作，以此构成基本运转结构。</p>
<h3 id="六、基本概念及使用介绍"><a href="#六、基本概念及使用介绍" class="headerlink" title="六、基本概念及使用介绍"></a>六、基本概念及使用介绍</h3><h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>程序员往往都是讨厌看文档而偏爱看代码的，上述那么多文字，你不一定看的下去，还是首先来一个hello world吧。<br>对于计算表达式（1+2）* 3，</p>
<p>传统的编程方式是：<br>int a = 1 + 2<br>int b = a * 3</p>
<p>而对于函数式编程方式是：<br>int result = multiply(add(1,2), 3)<br>这里函数作为参数进行传递。</p>
<h4 id="函数式编程的常见函数"><a href="#函数式编程的常见函数" class="headerlink" title="函数式编程的常见函数"></a>函数式编程的常见函数</h4><p>从一个例子说起，假设我们有一个名字列表，其中一些条目由单个字符构成。现在的任务是：</p>
<ul>
<li>除去单字符条目</li>
<li>放在一个逗号分隔的字符串中进行返回</li>
<li>每个名字的首字母都是大写<br>代码可参考《函数式编程思维》的<a href="https://github.com/oreillymedia/functional_thinking/blob/master/functional_thinking_examples/java/trans/TheCompanyProcess.java" target="_blank" rel="external">github</a><br>传统的java实现<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">String</span> cleanNames(List&lt;<span class="keyword">String</span>&gt; listOfNames) &#123;</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; listOfNames.<span class="built_in">size</span>(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (listOfNames.<span class="built_in">get</span>(i).length() &gt; <span class="number">1</span>) &#123;</div><div class="line">            result.<span class="built_in">append</span>(capitalizeString(listOfNames.<span class="built_in">get</span>(i))).<span class="built_in">append</span>(<span class="string">","</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result.substring(<span class="number">0</span>, result.length() - <span class="number">1</span>).toString();</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">String</span> capitalizeString(<span class="keyword">String</span> s) &#123;</div><div class="line">    <span class="keyword">return</span> s.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + s.substring(<span class="number">1</span>, s.length());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>命令式编程鼓励程序员将操作安排在循环内部执行，本例中的三个操作filter、transform、convert都必须依赖于相同的低层次机制。</p>
<p>Java8的实现：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="built_in">String</span> cleanNames(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; names) &#123;</div><div class="line">    <span class="keyword">if</span> (names == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    <span class="keyword">return</span> names</div><div class="line">            .stream()</div><div class="line">            .filter(name -&gt; name.length() &gt; <span class="number">1</span>)</div><div class="line">            .<span class="built_in">map</span>(name -&gt; capitalize(name))</div><div class="line">            .collect(Collectors.joining(<span class="string">","</span>));</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="built_in">String</span> capitalize(<span class="built_in">String</span> e) &#123;</div><div class="line">    <span class="keyword">return</span> e.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + e.substring(<span class="number">1</span>, e.length());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>两者的对比，可以发现后者这种更高层次的抽象思考有一些好处：</p>
<ul>
<li>促使我们换一种角度去归类问题，看到问题的共性。</li>
<li>让运行时有更大的余地去做只能的优化（有时候调整作业的先后顺序会更有效率）。</li>
<li>让埋头实现细节的开发者看到原本视野之外的解决方案（比如，如果改用多线程，传统的方式可能需要自己手动穿插一些线程相关的代码）</li>
</ul>
<p>可以从上述例子中，看到三个函数filter、map、fold/reduce的影子。</p>
<ol>
<li><p>filter——筛选<br>根据用户定义的条件来筛选列表中的条目，并由此产生一个较小的新列表。</p>
</li>
<li><p>map——映射<br>对原集合的每一个元素执行给定的函数，从而变换成一个新的集合。</p>
</li>
<li><p>fold/reduce——折叠/化约<br>用一个累积量来“收集”集合元素。</p>
</li>
</ol>
<p>总而言之，函数式编程以参数传递和函数的复合作为主要的表现手段，我们不需要掌握太多作为“不确定因素”存在的其他语言构造之间的交互规则。</p>
<p>本篇只讲述了函数式编程的概念、背景和三个具有普遍意义的基本构造单元，<a href="http://zhangyuyu.github.io/2016/11/12/函数式编程初探2" target="_blank" rel="external">下一篇</a>我会讲述一些柯里化与部分施用、缓存、缓求值、 函数式的数据结构。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;作为一名从业以来一直在编写Java的程序媛，虽然项目里经常用java8的lambda，可是在引入&lt;a href=&quot;http:
    
    </summary>
    
      <category term="函数式编程" scheme="http://yoursite.com/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="函数式编程" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>RxJava</title>
    <link href="http://yoursite.com/2016/11/01/RxJava/"/>
    <id>http://yoursite.com/2016/11/01/RxJava/</id>
    <published>2016-11-01T14:19:46.000Z</published>
    <updated>2016-11-12T09:55:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>最近，项目（Java编写的Spring boot API）引入了RXJava，使用了它的异步性操作以及它的一些流式写法。<br>使用过程中，有过疑惑，有过释然，有过吐槽，有过赞赏。学习应该是一个追根溯源的过程，而不是随便了解一下大致的用法就不了了之，故以此记之。</p>
<h3 id="二、响应式编程"><a href="#二、响应式编程" class="headerlink" title="二、响应式编程"></a>二、响应式编程</h3><p>响应式编程是一种面向数据流和变化传播的编程范式，数据更新是相关联的。<br>在交互式编程中，A = B + C这样的表达式意味着将B与C之和赋给A，而此后B与C的改变都与A无关。<br>而在响应式编程中，A会去“响应”B或C的变化，即一旦B或C改变之后，A的值也会随之变化。</p>
<h3 id="三、定义"><a href="#三、定义" class="headerlink" title="三、定义"></a>三、定义</h3><p>我的理解是，RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。（其实初学者把握两点就好了：观察者模式和异步）</p>
<h3 id="四、背景"><a href="#四、背景" class="headerlink" title="四、背景"></a>四、背景</h3><p>Rx的全称是Reactive Extensions。直译过来就是响应式扩展。<br>Rx基于观察者模式，是一种编程模型。其目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。<br>Rx最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源。<br>Rx的大部分语言库由ReactiveX这个组织负责维护，比较流行的有RxJava/RxJS/Rx.NET，社区网站是 reactivex.io。<br>RxJava是 ReactiveX 在JVM上的一个实现。</p>
<h3 id="五、为什么"><a href="#五、为什么" class="headerlink" title="五、为什么?"></a>五、为什么?</h3><ul>
<li>函数式风格</li>
<li>简化代码</li>
<li>异步错误处理</li>
<li>轻松使用并发</li>
</ul>
<h3 id="六、基本概念及使用介绍"><a href="#六、基本概念及使用介绍" class="headerlink" title="六、基本概念及使用介绍"></a>六、基本概念及使用介绍</h3><h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>说了很多，其实对RxJava是什么，其实还不是很明确，我们先来一个Hello world。</p>
<pre><code>Observable
    .create(new OnSubscribe&lt;String&gt;() {
        @Override
        public void call(Subscriber&lt;? super String&gt; subscriber) {
            subscriber.onNext(&quot;Hello World&quot;);
        }
    })
    .subscribe(new Subscriber&lt;String&gt;() {
        @Override
        public void onNext(String s) {
            System.out.println(s);
        }
    });
</code></pre><p>简化下来就是：</p>
<pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(&quot;Hello World!&quot;);
}).subscribe(System.out::println);
</code></pre><p>执行的过程就是创建、监听、订阅。</p>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul>
<li>Observable：被观察者</li>
<li>Observer: 观察者</li>
<li>Subscriber：观察者，implements Observer。 </li>
<li>OnSubscribe：一个接口类，是连接被观察者和观察者的桥梁，另外要说明的是onSubscribe是Observable的一个局部变量。</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="第1步：创建观察者Observer"><a href="#第1步：创建观察者Observer" class="headerlink" title="第1步：创建观察者Observer"></a>第1步：创建观察者Observer</h5><pre><code>Observer&lt;Object&gt; observer = new Observer&lt;Object&gt;() {

    @Override
    public void onCompleted() {

    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onNext(Object s) {

    }
};
</code></pre><h5 id="第2步：创建被观察者Observable"><a href="#第2步：创建被观察者Observable" class="headerlink" title="第2步：创建被观察者Observable"></a>第2步：创建被观察者Observable</h5><p>Observable.create()方法可以创建一个Observable，<br>使用create()创建Observable需要一个OnSubscribe对象，这个对象继承Action1。<br>当观察者订阅我们的Observable时，它作为一个参数传入并执行call()函数。</p>
<pre><code>Observable&lt;Object&gt; observable = Observable.create(new Observable.OnSubscribe&lt;Object&gt;() {         
    @Override
    public void call(Subscriber&lt;? super Object&gt; subscriber) {

    }
});
</code></pre><p>除了create()，just()和from()同样可以创建Observable。看看下面两个例子：</p>
<p>just(T…)将传入的参数依次发送</p>
<pre><code>Observable observable = Observable.just(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;);
//上面这行代码会依次调用
//onNext(&quot;One&quot;);
//onNext(&quot;Two&quot;);
//onNext(&quot;Three&quot;);
//onCompleted();
</code></pre><p>from(T[])/from(Iterable&lt;? extends T&gt;)将传入的数组或者Iterable拆分成Java对象依次发送</p>
<pre><code>String[] parameters = {&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;};
Observable observable = Observable.from(parameters);
//上面这行代码会依次调用
//onNext(&quot;One&quot;);
//onNext(&quot;Two&quot;);
//onNext(&quot;Three&quot;);
//onCompleted();
</code></pre><h5 id="第3步：被观察者Observable订阅观察者Observer"><a href="#第3步：被观察者Observable订阅观察者Observer" class="headerlink" title="第3步：被观察者Observable订阅观察者Observer"></a>第3步：被观察者Observable订阅观察者Observer</h5><p>你没看错，不同于普通的观察者模式，这里是被观察者订阅观察者：</p>
<pre><code>observable.subscribe(observer);
</code></pre><p>连起来就是：</p>
<pre><code>Observable.create(new OnSubscribe&lt;String&gt;() {
        @Override
        public void call(Subscriber&lt;? super String&gt; subscriber) {
            subscriber.onNext(&quot;Hello World!&quot;);
            subscriber.onCompleted();
        }

    }).subscribe(new Subscriber&lt;String&gt;() {

        @Override
        public void onCompleted() {
            System.out.println(&quot;Done&quot;);
        }

        @Override
        public void onError(Throwable e) {
            e.printStackTrace();
        }

        @Override
        public void onNext(String t) {
            System.out.println(t);
        }

    });
</code></pre><p>这里表面是被观察者订阅观察者，是为了更好的链式结构。<br>实际上，过程如下：</p>
<ul>
<li>创建一个被观察者，并传入一个OnSubcribe。</li>
<li>创建一个观察者Subscriber。</li>
<li>一旦发生subscribe时，会自动触发上述的OnSubcribe的call方法。</li>
<li>而OnSubcribe的call方法中的参数subscriber就是第二步中的被观察者Subscriber。</li>
<li>然后就调用上述代码中的<code>subscriber.onNext(&quot;Hello World!&quot;);</code></li>
<li>也就是真实上述代码中<code>Override</code>的<code>onNext()</code>方法了。<br>所以本质上来讲，还是被观察者执行订阅操作的。</li>
</ul>
<h3 id="七、操作符"><a href="#七、操作符" class="headerlink" title="七、操作符"></a>七、操作符</h3><p>有了对上一步调用的理解，再去看源代码中操作符的实质，就很简单了。</p>
<p>RxJava的操作符分为如下几类：</p>
<ul>
<li>转换类操作符<br>map、flatMap、concatMap等等</li>
<li>过滤类操作符<br>filter、find等等</li>
<li>组合类操作符<br>concat、merge、zip等等</li>
<li>数学类操作符<br>count、max等等</li>
<li>布尔类操作符<br>includes、some等等</li>
</ul>
<p>对于这些操作符的调用分析，读者可以自己查看源代码。<br>对于操作符的用法，可以参考<a href="https://github.com/zhangyuyu/learnrxjava" target="_blank" rel="external">Github TDD 练习</a>。<br>对于操作符形象化的理解，可以参考一个交互式的动画网站<a href="http://rxmarbles.com/" target="_blank" rel="external">http://rxmarbles.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;最近，项目（Java编写的Spring boot API）引入了RXJava，使用了它的异步性操作以及它的一些流式写法。&lt;b
    
    </summary>
    
      <category term="RxJava" scheme="http://yoursite.com/categories/RxJava/"/>
    
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Consul架构</title>
    <link href="http://yoursite.com/2016/04/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1-consul%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2016/04/27/微服务-consul架构/</id>
    <published>2016-04-27T11:10:52.000Z</published>
    <updated>2016-04-27T12:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li><a href="#agent">Agent</a></li>
<li><a href="#client">Client</a></li>
<li><a href="#server">Server</a></li>
<li><a href="#datacenter">DataCenter</a></li>
<li><a href="#gossip">Gossip</a></li>
<li><a href="#consensus">Consensus</a></li>
<li><a href="#rpc">RPC</a></li>
</ul>
<h4 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a><p id="agent"></p>Agent</h4><p>　　<code>Consul agent</code>有两种运行模式：<a href="#server">Server</a> 和 <a href="#client">Client</a>。这里的Server和Client只是Consul集群层面的区分，与搭建在Cluster之上的应用服务无关。<br>　　agent负责节点以及节点上服务的健康检查，健康检查是每个服务发现框架中重要组成部分，因为只有健康的服务才应该被clients发现，不健康的主机会被Consul服务注销.Agent之间是通过指定的端口以及TCP和UDP协议进行通信的。</p>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a><p id="client"></p>Client</h4><p>　　Client节点是相对无状态的，Client的唯一活动就是转发请求给<code>Server agent</code>节点，以保持低延迟和少资源消耗。</p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a><p id="server"></p>Server</h4><p>　　以Server模式运行的Consul agent节点用于维护Consul集群的状态，官方建议每个Consul Cluster至少有3个或以上的运行在Server模式的Agent,Client节点则不限。<br>　　每个<a href="#datacenter">DataCenter</a>的Consul Cluster都会在<code>server agent</code>节点中选出一个Leader节点，这个选举过程通过Consul实现的<a href="https://raft.github.io/" target="_blank" rel="external">Raft Protocol</a>保证，多个<code>server agent</code>节点上的Consul数据信息是强一致的。</p>
<h4 id="DataCenter"><a href="#DataCenter" class="headerlink" title="DataCenter"></a><p id="datacenter"></p>DataCenter</h4><p>　　数据中心似乎是显而易见的，但也有微妙的细节，如EC2多个可用区。 我们定义了一个数据中心是一个联网环境是私有的，低延迟和高带宽。 这不包括通信，将穿越公共互联网。</p>
<h4 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a><p id="gossip"></p>Gossip</h4><p>　　Gossip协议是电脑之间的通信协议，受启发于现实社会的流言蜚语。现代分布式系统通常用Gossip协议来解决一些用其他方法难以解决的问题，可能是因为当前网络有一个不便的问题——过于庞大，或许是因为Gossip协议有时候是最为行之有效的方法。<br>　　“传染病协议”(Epidemic protocol)有时候也是Gossip协议的同义词，因为gossip协议传播信息的方式，有时候很类似于生物体内的病毒传播。<br>　　简言之，Gossip就是p2p协议。它主要要做的事情是，去中心化。<br>这个协议就是模拟人类中传播谣言的行为而来。首先要传播谣言就要有种子节点。种子节点每秒都会随机向其他节点发送自己所拥有的节点列表，以及需要传播的消息。任何新加入的节点，就在这种传播方式下很快地被全网所知道。<br>　　LAN gossip pool包含了同一局域网内所有节点，包括<code>server agent</code>与<code>client agent</code>。这基本上是位于同一个数据中心DC。<br>　　WAN gossip pool一般仅包含<code>server agent</code>，将跨越多个DC数据中心，通过互联网或广域网进行通信。</p>
<h4 id="Consensus"><a href="#Consensus" class="headerlink" title="Consensus"></a><p id="consensus"></p>Consensus</h4><p>　　一致性协议使用的是<a href="https://raft.github.io/" target="_blank" rel="external">Raft Protocol</a></p>
<h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a><p id="rpc"></p>RPC</h4><p>　　RPC(Remote Procedure Call)远程过程调用,这是一个请求/响应机制，允许一个客户端，向一个服务器发送请求。<br><code>Leader server agent</code>负责所有的RPC请求，查询并相应。所以其他服务器收到<code>client agent</code>的RPC请求时，会转发到<code>Leader server agent</code>。<br>　　同事整理的RPC文档→<a href="http://koly.me/2016/04/22/RPC-and-Apache-Thrift/" target="_blank" rel="external">Remote Procedure Call</a></p>
<p>　　下图为Consul的架构图：<br><img src="/imgs/consul-arch.jpg" width="400" height="250"></p>
<h3 id="使用Consul发现服务的三个组件"><a href="#使用Consul发现服务的三个组件" class="headerlink" title="使用Consul发现服务的三个组件"></a>使用Consul发现服务的三个组件</h3><ol>
<li><p>Consul 存储服务信息<br>　　tool to store information about services</p>
</li>
<li><p>Registrator 注册Docker服务<br>　　tool to register Docker servicecs</p>
</li>
<li><p>Consul-template 查询注册的服务并应用配置<br>　　tool to query registered services and apply configuration</p>
</li>
</ol>
<p>　　下图为Consul和ECS之间一起运作的架构：<br><img src="/imgs/consul-EC2.png" width="400" height="250"></p>
<blockquote>
<p>Consul官网对于Consul架构的解释:<br><br><a href="https://www.consul.io/docs/internals/architecture.html" target="_blank" rel="external">CONSUL ARCHITECTURE</a><br></p>
<p>Amazon官网上的博客:<br><br><a href="https://aws.amazon.com/blogs/compute/service-discovery-via-consul-with-amazon-ecs/" target="_blank" rel="external">Service Discovery via Consul with Amazon ECS</a><br><br>翻译的中文版地址:<br><br><a href="http://yaowenjie.github.io/cloud/service-discovery-via-consul-with-amazon-ecs" target="_blank" rel="external">在ECS上使用Consul实现服务发现</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#agent&quot;&gt;Agent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#client&quot;&gt;Client&lt;/a&gt;
    
    </summary>
    
      <category term="MicroServices" scheme="http://yoursite.com/categories/MicroServices/"/>
    
    
      <category term="MicroServices Consul" scheme="http://yoursite.com/tags/MicroServices-Consul/"/>
    
  </entry>
  
</feed>
